<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elemental SVG Editor for FileMaker</title>
    <style>
        :root {
            /* Dark theme (default) */
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --accent: #f97316;
            --accent-hover: #fb923c;
            --accent-rgb: 249, 115, 22;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --border-color: #2a2a4a;
            --success: #4ade80;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            --checker-color: #252540;
        }

        [data-theme="light"] {
            --bg-primary: #f5f5f7;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8e8ed;
            --accent: #ea580c;
            --accent-hover: #c2410c;
            --accent-rgb: 234, 88, 12;
            --text-primary: #1a1a2e;
            --text-secondary: #5a5a6e;
            --border-color: #d1d1d6;
            --success: #22c55e;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --checker-color: #e0e0e5;
        }

        /* Accent color variants - Dark mode */
        [data-theme="dark"][data-accent="red"] {
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --accent-rgb: 233, 69, 96;
        }

        [data-theme="dark"][data-accent="blue"] {
            --accent: #3b82f6;
            --accent-hover: #60a5fa;
            --accent-rgb: 59, 130, 246;
        }

        [data-theme="dark"][data-accent="green"] {
            --accent: #22c55e;
            --accent-hover: #4ade80;
            --accent-rgb: 34, 197, 94;
        }

        [data-theme="dark"][data-accent="purple"] {
            --accent: #8b5cf6;
            --accent-hover: #a78bfa;
            --accent-rgb: 139, 92, 246;
        }

        [data-theme="dark"][data-accent="pink"] {
            --accent: #ec4899;
            --accent-hover: #f472b6;
            --accent-rgb: 236, 72, 153;
        }

        /* Accent color variants - Light mode */
        [data-theme="light"][data-accent="red"] {
            --accent: #e94560;
            --accent-hover: #d63850;
            --accent-rgb: 233, 69, 96;
        }

        [data-theme="light"][data-accent="blue"] {
            --accent: #2563eb;
            --accent-hover: #1d4ed8;
            --accent-rgb: 37, 99, 235;
        }

        [data-theme="light"][data-accent="green"] {
            --accent: #16a34a;
            --accent-hover: #15803d;
            --accent-rgb: 22, 163, 74;
        }

        [data-theme="light"][data-accent="purple"] {
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --accent-rgb: 124, 58, 237;
        }

        [data-theme="light"][data-accent="pink"] {
            --accent: #db2777;
            --accent-hover: #be185d;
            --accent-rgb: 219, 39, 119;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100%;
        }

        /* Hidden state before initialization */
        .editor-container {
            display: none;
        }

        .editor-container.initialized {
            /* Reset inherited styles from parent pages (e.g., Squarespace) */
            /* Using explicit resets instead of 'all: initial' to preserve CSS variable inheritance */
            margin: 0;
            padding: 16px;
            border: none;
            text-decoration: none;
            text-align: left;
            text-indent: 0;
            text-transform: none;
            letter-spacing: normal;
            word-spacing: normal;
            line-height: normal;
            font-style: normal;
            font-variant: normal;
            font-size: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            /* Explicit background to prevent parent page bleed-through */
            background-color: var(--bg-primary);
            color: var(--text-primary);
            /* Layout */
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            /* Dynamic viewport height for iOS */
            gap: 16px;
            box-sizing: border-box;
            /* Rounded corners for embedded appearance */
            border-radius: 12px;
            overflow: hidden;
            /* Prevent scroll chaining to parent page */
            overscroll-behavior: contain;
        }

        /* iOS safe area support */
        @supports (padding: env(safe-area-inset-bottom)) {
            .editor-container.initialized {
                padding-bottom: calc(16px + env(safe-area-inset-bottom));
            }
        }

        /* Scoped reset for child elements to prevent parent page styles (e.g., Squarespace) leaking in */
        .editor-container.initialized *,
        .editor-container.initialized *::before,
        .editor-container.initialized *::after {
            box-sizing: border-box;
        }

        /* Title Bar */
        .title-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .title-bar-icon {
            height: 22px;
            width: 22px;
            flex-shrink: 0;
        }

        .title-bar-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Header */
        .header {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-primary);
        }

        .header-branding {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .header-icon {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
            white-space: nowrap;
        }

        .header-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }

        .header-row-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-row-right {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .btn-coffee {
            background: #28a745;
            color: white;
            border: none;
            text-decoration: none;
            font-size: 12px;
            font-weight: 600;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            flex-shrink: 0;
            width: 260px;
            box-sizing: border-box;
        }

        .btn-coffee:hover {
            background: #218838;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .btn-coffee .coffee-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .btn-coffee .coffee-steam {
            transform-origin: center bottom;
            animation: steam 2s ease-in-out infinite;
        }

        .btn-coffee .coffee-steam:nth-child(2) {
            animation-delay: 0.4s;
        }

        .btn-coffee .coffee-steam:nth-child(3) {
            animation-delay: 0.8s;
        }

        @keyframes steam {

            0%,
            100% {
                opacity: 0.3;
                transform: translateY(0);
            }

            50% {
                opacity: 1;
                transform: translateY(-2px);
            }
        }

        .header-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* Theme Toggle Container */
        .theme-container {
            position: relative;
            display: flex;
            align-items: stretch;
        }

        .btn.theme-toggle {
            white-space: nowrap;
            border-radius: 6px 0 0 6px;
            border-right: none;
        }

        .theme-toggle .icon-sun,
        .theme-toggle .icon-moon,
        .theme-toggle .label-light,
        .theme-toggle .label-dark {
            display: none;
        }

        [data-theme="dark"] .theme-toggle .icon-sun,
        [data-theme="dark"] .theme-toggle .label-light {
            display: block;
        }

        [data-theme="light"] .theme-toggle .icon-moon,
        [data-theme="light"] .theme-toggle .label-dark {
            display: block;
        }

        .theme-dropdown-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-left: none;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-top-right-radius: 6px;
            border-bottom-right-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            transition: background 0.2s;
        }

        .theme-dropdown-toggle:hover {
            background: var(--bg-primary);
        }

        .theme-dropdown-toggle svg {
            width: 12px;
            height: 12px;
            transition: transform 0.2s;
        }

        .theme-container.open .theme-dropdown-toggle svg {
            transform: rotate(180deg);
        }

        /* Theme Dropdown Menu */
        .theme-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            min-width: 140px;
        }

        .theme-container.open .theme-dropdown {
            display: block;
        }

        .theme-dropdown-label {
            font-size: 10px;
            text-transform: uppercase;
            color: var(--text-secondary);
            padding: 4px 8px;
            letter-spacing: 0.5px;
        }

        .accent-colors {
            display: flex;
            gap: 6px;
            padding: 6px 8px;
        }

        .accent-swatch {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
            position: relative;
        }

        .accent-swatch:hover {
            transform: scale(1.15);
        }

        .accent-swatch.active {
            border-color: var(--text-primary);
        }

        .accent-swatch.active::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        .accent-swatch[data-color="red"] {
            background: #e94560;
        }

        .accent-swatch[data-color="blue"] {
            background: #3b82f6;
        }

        .accent-swatch[data-color="green"] {
            background: #22c55e;
        }

        .accent-swatch[data-color="purple"] {
            background: #8b5cf6;
        }

        .accent-swatch[data-color="pink"] {
            background: #ec4899;
        }

        .accent-swatch[data-color="orange"] {
            background: #f97316;
        }

        /* Main Content Area */
        .main-content {
            display: flex;
            flex: 1;
            gap: 16px;
            min-height: 0;
            background-color: var(--bg-primary);
        }

        /* Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .preview-header h2 {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .preview-filename {
            font-size: 14px;
            font-weight: 400;
            color: var(--text-secondary);
            opacity: 0.7;
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .zoom-btn:hover:not(:disabled) {
            background: var(--accent);
            color: white;
        }

        .zoom-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .history-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-right: 12px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.2s ease;
        }

        .modal-overlay.visible .modal-card {
            transform: scale(1) translateY(0);
        }

        .modal-icon {
            width: 48px;
            height: 48px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
        }

        .modal-icon svg {
            width: 24px;
            height: 24px;
            color: var(--accent);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .modal-message {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 24px;
            white-space: pre-line;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .modal-btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .modal-btn-cancel:hover {
            background: var(--bg-primary);
        }

        .modal-btn-confirm {
            background: var(--accent);
            color: white;
        }

        .modal-btn-confirm:hover {
            background: var(--accent-hover);
        }

        .zoom-level {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: center;
        }

        .preview-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            position: relative;
            overflow: hidden;
            transition: background 0.2s ease;
        }

        /* Drag-over visual cue */
        .preview-container.drag-over {
            background: rgba(var(--accent-rgb), 0.1);
        }

        .preview-container.drag-over::after {
            content: '';
            position: absolute;
            inset: 12px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            pointer-events: none;
            animation: pulse-border 1.5s ease-in-out infinite;
        }

        @keyframes pulse-border {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }
        }

        .preview-bg {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(45deg, var(--checker-color) 25%, transparent 25%),
                linear-gradient(-45deg, var(--checker-color) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, var(--checker-color) 75%),
                linear-gradient(-45deg, transparent 75%, var(--checker-color) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            opacity: 0.5;
        }

        .preview-wrapper {
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        #preview-svg {
            max-width: 100%;
            max-height: 100%;
            transition: transform 0.3s ease;
        }

        /* When showing grid, preview-svg needs to fill the space */
        #preview-svg.grid-mode {
            position: absolute;
            inset: 0;
            max-width: none;
            max-height: none;
            width: 100%;
            height: 100%;
        }

        /* Multi-SVG Preview Grid */
        .preview-grid {
            --tile-size: 100px;
            /* Base tile size, modified by zoom */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(calc(var(--tile-size) + 16px), 1fr));
            gap: 12px;
            padding: 16px;
            overflow-y: auto;
            width: 100%;
            height: 100%;
            align-content: start;
            position: absolute;
            inset: 0;
        }

        .preview-tile {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: fit-content;
        }

        .colored-bg-active .preview-tile {
            background: transparent;
        }

        .colored-bg-active .tile-filename {
            color: var(--preview-text-color, var(--text-secondary));
        }

        .colored-bg-active .preview-filename {
            color: var(--preview-text-color, var(--text-secondary));
        }

        .tile-svg {
            width: var(--tile-size);
            height: var(--tile-size);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tile-svg svg {
            max-width: 100%;
            max-height: 100%;
        }

        .tile-filename {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 6px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            max-width: 100%;
            text-align: center;
        }

        /* Controls Panel */
        .controls-panel {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            background-color: var(--bg-primary);
        }

        .controls-panel.hidden {
            display: none;
        }

        .control-section {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 12px;
            box-shadow: var(--shadow);
        }

        .control-section h3 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        /* Transform Controls (compact inline style) */
        .transform-grid {
            display: flex;
            gap: 6px;
            margin-top: 10px;
        }

        .transform-btn {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
        }

        .transform-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .transform-btn:active {
            transform: translateY(0);
        }

        .transform-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Rotation Controls */
        .rotation-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rotation-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }

        .rotation-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .rotation-btn svg {
            width: 16px;
            height: 16px;
        }

        .rotation-value {
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            padding: 6px;
            background: var(--bg-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
        }

        .rotation-increment {
            margin-top: 10px;
        }

        .rotation-increment label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .increment-options {
            display: flex;
            gap: 4px;
        }

        .increment-btn {
            flex: 1;
            padding: 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .increment-btn:hover,
        .increment-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* Color Controls */
        .color-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .color-row:last-child {
            margin-bottom: 0;
        }

        .color-row label {
            flex: 1;
            font-size: 11px;
            color: var(--text-primary);
        }

        .color-picker-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .color-preview input[type="color"] {
            display: none;
        }

        .cp-popup {
            position: fixed;
            z-index: 1001;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            box-shadow: var(--shadow);
            display: none;
            flex-direction: column;
            gap: 8px;
            width: 220px;
        }

        .cp-popup.open { display: flex; }

        .cp-sat-canvas {
            width: 200px;
            height: 150px;
            border-radius: 4px;
            cursor: crosshair;
        }

        .cp-hue-canvas {
            width: 200px;
            height: 14px;
            border-radius: 4px;
            cursor: crosshair;
        }

        .cp-swatches {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .cp-swatch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(128,128,128,0.3);
            cursor: pointer;
            padding: 0;
        }

        .cp-swatch:hover {
            transform: scale(1.2);
        }

        .color-hex {
            width: 75px;
            padding: 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 11px;
            font-family: monospace;
        }

        .color-hex:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Background Controls */
        .bg-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .bg-toggle span {
            font-size: 11px;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: var(--bg-primary);
            border-radius: 24px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: var(--text-secondary);
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked+.toggle-slider {
            background: var(--accent);
        }

        .toggle-switch input:checked+.toggle-slider:before {
            transform: translateX(20px);
            background: white;
        }

        .bg-options {
            display: none;
        }

        .bg-options.visible {
            display: block;
        }

        .shape-options {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .shape-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            padding: 8px 6px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .shape-btn:hover,
        .shape-btn.active {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .shape-btn svg {
            width: 18px;
            height: 18px;
        }

        .shape-btn span {
            font-size: 9px;
        }

        .edges-stepper {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
        }

        .edges-stepper button {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }

        .edges-stepper button:hover {
            border-color: var(--accent);
        }

        .edges-stepper .edges-value {
            width: 32px;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .edges-stepper .edges-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 2px;
        }

        /* Stroke Controls */
        .stroke-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .stroke-row label {
            width: 70px;
            font-size: 11px;
            color: var(--text-primary);
        }

        .adjustment-row {
            margin-bottom: 10px;
        }

        .adjustment-row label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stroke-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: var(--bg-primary);
            border-radius: 3px;
            outline: none;
        }

        .stroke-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .stroke-value {
            min-width: 35px;
            text-align: right;
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 6px;
        }

        .action-buttons .btn {
            flex: 1;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-primary);
        }

        .btn-secondary:disabled {
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(var(--accent-rgb), 0.4);
        }

        .btn-primary:disabled {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn svg {
            width: 14px;
            height: 14px;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            color: var(--text-secondary);
            text-align: center;
            padding: 40px;
            cursor: pointer;
            border-radius: 12px;
            transition: background 0.2s ease;
            z-index: 2;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .empty-state.hidden {
            display: none;
        }

        .empty-state:hover {
            background: rgba(var(--accent-rgb), 0.1);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            transform: translateZ(0);
        }

        .empty-state:hover svg {
            opacity: 0.8;
        }

        .empty-state p {
            font-size: 14px;
            line-height: 1.5;
        }

        .empty-state .click-hint {
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.7;
        }

        /* Responsive - tablets */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
                overflow: hidden;
            }

            .preview-panel {
                flex: 1;
                min-height: 150px;
            }

            .controls-panel {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                flex: none;
                max-height: 45%;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }

            .control-section {
                flex: 1;
                min-width: 200px;
            }
        }

        /* Extra small screens (phones) */
        @media (max-width: 480px) {
            .editor-container.initialized {
                padding: 8px;
                gap: 8px;
            }

            .header {
                flex-wrap: wrap;
                gap: 8px;
                flex-shrink: 0;
            }

            .header-actions {
                flex-wrap: wrap;
            }

            .controls-panel {
                flex-direction: column;
                max-height: 50%;
                padding-bottom: env(safe-area-inset-bottom, 20px);
            }

            .control-section {
                min-width: 100%;
            }
        }

        /* Size Display */
        .size-info {
            display: flex;
            gap: 16px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .size-info span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .report-issue-btn {
            margin-left: auto;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 600;
            padding: 5px 10px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .report-issue-btn:hover {
            color: var(--text-primary);
            background: var(--bg-primary);
            border-color: #f59e0b;
        }

        [data-theme="light"] .report-issue-btn {
            background: #ffffff;
        }

        .report-issue-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Issue Report Modal */
        .issue-report-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 460px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.2s ease;
        }

        .modal-overlay.visible .issue-report-card {
            transform: scale(1) translateY(0);
        }

        .issue-report-card .modal-icon svg {
            color: var(--accent);
        }

        .issue-report-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .issue-report-field {
            margin-bottom: 12px;
        }

        .issue-report-field label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .issue-report-field input,
        .issue-report-field textarea {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        .issue-report-field input:focus,
        .issue-report-field textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .issue-report-field textarea {
            resize: vertical;
            min-height: 80px;
        }

        .issue-report-field .field-hint {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .issue-report-info {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.4;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 16px;
        }

        /* Padding Control */
        .padding-control {
            margin-top: 8px;
        }

        .padding-control label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .corner-radius-control {
            margin-top: 8px;
        }

        .corner-radius-control label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        /* Collapsible Control Sections */
        .control-section h3 {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }

        .control-section h3 .chevron {
            width: 12px;
            height: 12px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            color: var(--text-secondary);
        }

        .control-section.collapsed h3 .chevron {
            transform: rotate(-90deg);
        }

        .control-section.collapsed h3 {
            margin-bottom: 0;
        }

        .control-section-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease;
            opacity: 1;
        }

        .control-section.collapsed .control-section-content {
            max-height: 0;
            opacity: 0;
        }

        /* Preview Background Toggle */
        .preview-bg-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .preview-bg-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .preview-bg-btn:hover {
            background: var(--accent);
            color: white;
        }

        .preview-bg-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            min-width: 160px;
        }

        .preview-bg-container.open .preview-bg-dropdown {
            display: block;
        }

        .preview-bg-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-primary);
            transition: background 0.15s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .preview-bg-option:hover {
            background: var(--bg-tertiary);
        }

        .preview-bg-option.active {
            color: var(--accent);
        }

        .preview-bg-option .swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .preview-bg-option .swatch.checkerboard {
            background-image:
                linear-gradient(45deg, #808080 25%, transparent 25%),
                linear-gradient(-45deg, #808080 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #808080 75%),
                linear-gradient(-45deg, transparent 75%, #808080 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
        }

        .preview-bg-custom-color {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
        }

        .preview-bg-custom-color input[type="color"] {
            width: 24px;
            height: 24px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
            background: none;
        }

        /* Preview background modes */
        .preview-bg.bg-white {
            background-image: none;
            background-color: #ffffff;
            opacity: 1;
        }

        .preview-bg.bg-black {
            background-image: none;
            background-color: #000000;
            opacity: 1;
        }

        .preview-bg.bg-custom {
            background-image: none;
            opacity: 1;
        }

        /* Remove X Button */
        .preview-tile {
            position: relative;
        }

        .tile-remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 2;
            padding: 0;
        }

        .preview-tile:hover .tile-remove-btn {
            opacity: 1;
        }

        .tile-remove-btn:hover {
            background: var(--accent);
        }

        .single-remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 3;
            padding: 0;
        }

        .preview-container:hover .single-remove-btn {
            opacity: 1;
        }

        .single-remove-btn:hover {
            background: var(--accent);
        }

        /* Tile hover action buttons (copy, view code) */
        .tile-actions {
            position: absolute;
            top: 4px;
            left: 4px;
            display: flex;
            gap: 3px;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 2;
        }

        .preview-tile:hover .tile-actions {
            opacity: 1;
        }

        .tile-action-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .tile-action-btn:hover {
            background: var(--accent);
        }

        .tile-action-btn svg {
            width: 11px;
            height: 11px;
        }

        /* Single-mode hover actions */
        .single-actions {
            position: absolute;
            top: 8px;
            left: 8px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 3;
        }

        .preview-container:hover .single-actions {
            opacity: 1;
        }

        .single-action-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .single-action-btn:hover {
            background: var(--accent);
        }

        .single-action-btn svg {
            width: 13px;
            height: 13px;
        }

        /* Preview toast notification */
        .preview-toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .preview-toast.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Drag Reorder */
        .preview-tile[draggable="true"] {
            cursor: grab;
        }

        .preview-tile[draggable="true"]:active {
            cursor: grabbing;
        }

        .preview-tile.dragging {
            opacity: 0.4;
        }

        .preview-tile.drag-over-tile {
            border: 2px solid var(--accent);
            border-radius: 8px;
        }

        /* Code View Modal */
        .code-view-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .code-view-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .code-view-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.2s ease;
        }

        .code-view-overlay.visible .code-view-card {
            transform: scale(1) translateY(0);
        }

        .code-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .code-view-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .code-view-actions {
            display: flex;
            gap: 8px;
        }

        .code-view-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: background 0.2s;
        }

        .code-view-close:hover {
            background: var(--accent);
            color: white;
        }

        .code-view-pre {
            flex: 1;
            overflow: auto;
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 16px;
            margin: 0;
            font-size: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            color: var(--text-primary);
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-all;
            border: 1px solid var(--border-color);
        }

        /* SVG Selection Modal (shared for Copy & Code View) */
        .svg-selection-list {
            list-style: none;
            padding: 0;
            margin: 0 0 16px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .svg-selection-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
            font-size: 13px;
            color: var(--text-primary);
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .svg-selection-item:hover {
            background: var(--bg-tertiary);
        }

        .svg-selection-item .item-index {
            min-width: 24px;
            height: 24px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        /* Preview header toolbar buttons */
        .preview-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-toolbar-separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
        }
    </style>
</head>

<body data-theme="dark">
    <div class="editor-container" id="editor-container">
        <header class="header">
            <div class="header-row">
                <div class="header-row-left">
                    <a href="https://www.elemental-fm.com/svg" target="_blank"
                        title="Elemental SVG Editor for FileMaker"
                        style="display:inline-flex;align-items:center;cursor:pointer;">
                        <svg width="36" height="36" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="m19.26875 13h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-6.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1v6.8c0 1.5-.6375 2.1-2.23125 2.1z"
                                fill="#6282c1" />
                            <path
                                d="m11 13.1v6.8c0 1.5-.6375 2.1-2.23125 2.1h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-6.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1z"
                                fill="#c0cdea" />
                            <path
                                d="m19.26875 22h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-2.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1v2.8c0 1.5-.6375 2.1-2.23125 2.1z"
                                fill="#f7b115" />
                            <path
                                d="m8.76875 9h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-2.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1v2.8c0 1.5-.6375 2.1-2.23125 2.1z"
                                fill="#ef7a1b" />
                        </svg>
                    </a>
                    <span class="header-title">Elemental SVG Editor</span>
                </div>
                <div class="header-row-right">
                    <div class="header-actions">
                        <button class="btn btn-secondary" onclick="triggerFileLoad()" title="Load SVG files">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                                <polyline points="17 8 12 3 7 8" />
                                <line x1="12" y1="3" x2="12" y2="15" />
                            </svg>
                            Load SVGs
                        </button>
                        <button class="btn btn-secondary" id="clear-btn" onclick="clearAllSVGs()"
                            title="Clear all loaded SVGs" style="display: none;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18" />
                                <line x1="6" y1="6" x2="18" y2="18" />
                            </svg>
                            Clear
                        </button>
                        <button class="btn btn-secondary" id="reset-btn" onclick="resetAll()" title="Reset all changes"
                            style="display: none;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                                <path d="M3 3v5h5" />
                            </svg>
                            Reset
                        </button>
                        <div class="theme-container" id="theme-container">
                            <button class="btn btn-secondary theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                                <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <circle cx="12" cy="12" r="5" />
                                    <line x1="12" y1="1" x2="12" y2="3" />
                                    <line x1="12" y1="21" x2="12" y2="23" />
                                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
                                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
                                    <line x1="1" y1="12" x2="3" y2="12" />
                                    <line x1="21" y1="12" x2="23" y2="12" />
                                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
                                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
                                </svg>
                                <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
                                </svg>
                                <span class="label-light">Light</span>
                                <span class="label-dark">Dark</span>
                            </button>
                            <button class="theme-dropdown-toggle" onclick="toggleThemeDropdown(event)"
                                title="Color options">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9" />
                                </svg>
                            </button>
                            <div class="theme-dropdown">
                                <div class="theme-dropdown-label">Accent Color</div>
                                <div class="accent-colors">
                                    <button class="accent-swatch" data-color="red" onclick="setAccentColor('red')"
                                        title="Red"></button>
                                    <button class="accent-swatch" data-color="blue" onclick="setAccentColor('blue')"
                                        title="Blue"></button>
                                    <button class="accent-swatch" data-color="green" onclick="setAccentColor('green')"
                                        title="Green"></button>
                                    <button class="accent-swatch" data-color="purple" onclick="setAccentColor('purple')"
                                        title="Purple"></button>
                                    <button class="accent-swatch" data-color="pink" onclick="setAccentColor('pink')"
                                        title="Pink"></button>
                                    <button class="accent-swatch active" data-color="orange"
                                        onclick="setAccentColor('orange')" title="Orange"></button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <a class="btn-coffee"
                    href="https://giraffe-flounder-f3lg.squarespace.com/checkout/donate?donatePageId=6984434f14f9465769febd49"
                    target="_blank" rel="noopener noreferrer">
                    <svg class="coffee-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path class="coffee-steam" d="M6 4c0-1 .5-2 1.5-2s1.5 1 1.5 2" opacity="0.6" />
                        <path class="coffee-steam" d="M10 4c0-1 .5-2 1.5-2s1.5 1 1.5 2" opacity="0.6" />
                        <path class="coffee-steam" d="M14 4c0-1 .5-2 1.5-2s1.5 1 1.5 2" opacity="0.6" />
                        <path d="M4 7h16v6a6 6 0 0 1-6 6H10a6 6 0 0 1-6-6V7z" />
                        <path d="M20 10h1a2 2 0 0 1 0 4h-1" />
                    </svg>
                    Like this? Buy me a Coffee&hellip;
                </a>
            </div>
        </header>

        <div class="main-content">
            <div class="preview-panel">
                <div class="preview-header">
                    <div style="display:flex;align-items:center;gap:4px;min-width:0">
                        <h2>Preview</h2>
                        <span class="preview-filename" id="preview-filename"></span>
                    </div>
                    <div class="zoom-controls">
                        <div class="history-controls">
                            <button class="zoom-btn" id="undo-btn" onclick="undo()" title="Undo (Ctrl+Z)" disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <path d="M3 7v6h6" />
                                    <path d="M3 13a9 9 0 1 0 2.5-6.3L3 9" />
                                </svg>
                            </button>
                            <button class="zoom-btn" id="redo-btn" onclick="redo()" title="Redo (Ctrl+Shift+Z)"
                                disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <path d="M21 7v6h-6" />
                                    <path d="M21 13a9 9 0 1 1-2.5-6.3L21 9" />
                                </svg>
                            </button>
                        </div>
                        <div class="preview-toolbar">
                            <button class="zoom-btn" id="paste-btn" onclick="handlePasteButton()"
                                title="Paste SVG from clipboard">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <path
                                        d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
                                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
                                </svg>
                            </button>
                            <button class="zoom-btn" id="code-view-btn" onclick="showCodeView()" title="View SVG Code"
                                disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <polyline points="16 18 22 12 16 6" />
                                    <polyline points="8 6 2 12 8 18" />
                                </svg>
                            </button>
                            <div class="preview-bg-container" id="preview-bg-container">
                                <button class="zoom-btn preview-bg-btn" onclick="togglePreviewBgDropdown(event)"
                                    title="Preview background">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                        width="16" height="16">
                                        <rect x="3" y="3" width="18" height="18" rx="2" />
                                        <path d="M3 3l18 18" />
                                    </svg>
                                </button>
                                <div class="preview-bg-dropdown">
                                    <button class="preview-bg-option active" data-bg="checkerboard"
                                        onclick="setPreviewBg('checkerboard')">
                                        <span class="swatch checkerboard"></span> Checkerboard
                                    </button>
                                    <button class="preview-bg-option" data-bg="white" onclick="setPreviewBg('white')">
                                        <span class="swatch" style="background: #fff;"></span> White
                                    </button>
                                    <button class="preview-bg-option" data-bg="black" onclick="setPreviewBg('black')">
                                        <span class="swatch" style="background: #000;"></span> Black
                                    </button>
                                    <button class="preview-bg-option" data-bg="custom" onclick="setPreviewBg('custom')">
                                        <span class="swatch" id="preview-bg-custom-swatch"
                                            style="background: #808080;"></span> Custom
                                    </button>
                                    <div class="preview-bg-custom-color" id="preview-bg-custom-picker"
                                        style="display: none;">
                                        <input type="color" id="preview-bg-custom-color" value="#808080"
                                            oninput="updatePreviewBgCustomColor(this.value)"
                                            onchange="updatePreviewBgCustomColor(this.value)">
                                        <span style="font-size: 11px; color: var(--text-secondary);">Pick color</span>
                                    </div>
                                </div>
                            </div>
                            <div class="preview-toolbar-separator"></div>
                        </div>
                        <button class="zoom-btn" onclick="adjustZoom(-0.25)"></button>
                        <span class="zoom-level" id="zoom-level">100%</span>
                        <button class="zoom-btn" onclick="adjustZoom(0.25)">+</button>
                        <button class="zoom-btn" onclick="resetZoom()" title="Fit to view">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                height="16">
                                <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="preview-container" id="drop-zone">
                    <div class="preview-bg"></div>
                    <div class="preview-wrapper" id="preview-wrapper">
                        <div id="preview-svg"></div>
                        <div id="empty-state" class="empty-state" onclick="triggerFileLoad()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <rect x="3" y="3" width="18" height="18" rx="2" />
                                <path d="M12 8v8M8 12h8" />
                            </svg>
                            <p>Drag & drop one or more SVG files here</p>
                            <p class="click-hint">or click to browse</p>
                        </div>
                    </div>
                </div>
                <!-- Hidden file input for SVG loading (multiple selection enabled) -->
                <input type="file" id="svg-file-input" accept=".svg,image/svg+xml" style="display: none;" multiple
                    onchange="handleFileSelect(event)">
                <div class="size-info">
                    <span id="svg-dimensions" style="display:none">Dimensions: --</span>
                    <span id="svg-size" style="display:none">Size: --</span>
                    <button class="report-issue-btn" onclick="showIssueReport()"
                        title="Report an issue with SVG output">
                        <svg viewBox="0 0 1200 1200" fill="#f59e0b" stroke="none">
                            <path
                                d="m1128.9 905.81-424.31-734.63c-21.75-37.875-60.938-60.375-104.62-60.375s-82.875 22.5-104.62 60.375l-424.31 734.63c-21.75 37.875-21.75 83.062 0 120.94 21.938 37.875 61.125 60.562 104.81 60.562h848.26c43.688 0 82.875-22.688 104.81-60.562 21.75-37.875 21.75-83.062 0-120.94zm-597.19-6.375c0-37.688 30.562-68.25 68.25-68.25s68.25 30.562 68.25 68.25-30.562 68.438-68.25 68.438-68.25-30.75-68.25-68.438zm127.69-155.63c-1.5 31.875-27.562 56.812-59.438 56.812s-57.938-24.938-59.438-56.812l-14.625-322.13c-0.9375-20.438 6.1875-39.938 20.438-54.75 14.062-14.625 33.188-22.875 53.625-22.875s39.562 8.25 53.625 22.875c14.25 14.812 21.375 34.312 20.438 54.75z" />
                        </svg>
                        Report an Issue
                    </button>
                </div>
            </div>

            <div class="controls-panel">
                <!-- Rotate & Transform Section -->
                <div class="control-section">
                    <h3>Rotate & Transform</h3>
                    <div class="rotation-controls">
                        <button class="rotation-btn" onclick="rotate(-1)" title="Rotate Counter-clockwise">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                                <path d="M3 3v5h5" />
                            </svg>
                        </button>
                        <div class="rotation-value" id="rotation-value">0</div>
                        <button class="rotation-btn" onclick="rotate(1)" title="Rotate Clockwise">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 12a9 9 0 1 1-9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                                <path d="M21 3v5h-5" />
                            </svg>
                        </button>
                    </div>
                    <div class="rotation-increment">
                        <label>Increment</label>
                        <div class="increment-options">
                            <button class="increment-btn" onclick="setIncrement(15)">15</button>
                            <button class="increment-btn active" onclick="setIncrement(30)">30</button>
                            <button class="increment-btn" onclick="setIncrement(45)">45</button>
                            <button class="increment-btn" onclick="setIncrement(90)">90</button>
                        </div>
                    </div>
                    <div class="transform-grid">
                        <button class="transform-btn" onclick="flipHorizontal()" title="Flip Horizontal">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 3v18M16 7l4 5-4 5M8 7l-4 5 4 5" />
                            </svg>
                            Flip H
                        </button>
                        <button class="transform-btn" onclick="flipVertical()" title="Flip Vertical">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12h18M7 8l5-4 5 4M7 16l5 4 5-4" />
                            </svg>
                            Flip V
                        </button>
                    </div>
                </div>

                <!-- Adjustments Section -->
                <div class="control-section">
                    <h3>Adjustments</h3>
                    <div class="adjustment-row">
                        <label>Opacity</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="opacity-slider" min="0" max="100" step="1"
                                value="100" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateOpacity(this.value, true)" oninput="updateOpacity(this.value)">
                            <span class="stroke-value" id="opacity-value">100%</span>
                        </div>
                    </div>
                    <div class="adjustment-row">
                        <label>Scale</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="scale-slider" min="50" max="150" step="1"
                                value="100" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateScale(this.value, true)" oninput="updateScale(this.value)">
                            <span class="stroke-value" id="scale-value">100%</span>
                        </div>
                    </div>
                    <div class="adjustment-row">
                        <label>X Offset</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="offset-x-slider" min="-50" max="50" step="1"
                                value="0" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateOffsetX(this.value, true)" oninput="updateOffsetX(this.value)">
                            <span class="stroke-value" id="offset-x-value">0</span>
                        </div>
                    </div>
                    <div class="adjustment-row">
                        <label>Y Offset</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="offset-y-slider" min="-50" max="50" step="1"
                                value="0" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateOffsetY(this.value, true)" oninput="updateOffsetY(this.value)">
                            <span class="stroke-value" id="offset-y-value">0</span>
                        </div>
                    </div>
                    <div class="transform-grid" style="margin-top: 8px;">
                        <button class="transform-btn" onclick="invertColors()" title="Invert Colors (swap black/white)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="9" />
                                <path d="M12 3v18" />
                                <path d="M12 3a9 9 0 0 1 0 18" fill="currentColor" />
                            </svg>
                            Invert
                        </button>
                        <button class="transform-btn" onclick="resetAdjustments()"
                            title="Reset all adjustments to defaults">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                                <path d="M3 3v5h5" />
                            </svg>
                            Reset Adj.
                        </button>
                    </div>
                </div>

                <!-- Colors Section -->
                <div class="control-section">
                    <h3>Colors</h3>
                    <div class="color-row">
                        <label>Icon Fill</label>
                        <div class="color-picker-wrapper">
                            <div class="color-preview" style="background: #000000">
                                <input type="color" id="fill-color" value="#000000">
                            </div>
                            <input type="text" class="color-hex" id="fill-hex" value="#000000"
                                onchange="this.value=normalizeHex(this.value); updateFillColor(this.value)">
                        </div>
                    </div>
                    <div class="color-row" style="margin-top: 8px;">
                        <label>Stroke</label>
                        <div class="color-picker-wrapper">
                            <div class="color-preview" style="background: #000000">
                                <input type="color" id="stroke-color" value="#000000">
                            </div>
                            <input type="text" class="color-hex" id="stroke-hex" value="#000000"
                                onchange="this.value=normalizeHex(this.value); updateStrokeColor(this.value)">
                        </div>
                    </div>
                    <div class="stroke-row">
                        <label>Stroke Width</label>
                        <input type="range" class="stroke-slider" id="stroke-width" min="0" max="10" step="0.5"
                            value="0" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                            onchange="updateStrokeWidth(this.value, true)" oninput="updateStrokeWidth(this.value)">
                        <span class="stroke-value" id="stroke-value">0</span>
                    </div>
                </div>

                <!-- Background Section -->
                <div class="control-section">
                    <h3>Background</h3>
                    <div class="bg-toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="bg-enabled" onchange="toggleBackground(this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Enable Background</span>
                    </div>
                    <div class="bg-options" id="bg-options">
                        <div class="color-row">
                            <label>Color</label>
                            <div class="color-picker-wrapper">
                                <div class="color-preview" id="bg-color-preview" style="background: #ffffff">
                                    <input type="color" id="bg-color" value="#ffffff">
                                </div>
                                <input type="text" class="color-hex" id="bg-hex" value="#ffffff"
                                    onchange="this.value=normalizeHex(this.value); updateBgColor(this.value)">
                            </div>
                        </div>
                        <div class="shape-options">
                            <button class="shape-btn" onclick="setBgEdges(0)" id="shape-edges-0">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <circle cx="12" cy="12" r="10" />
                                </svg>
                                <span>Circle</span>
                            </button>
                            <button class="shape-btn" onclick="setBgEdges(3)" id="shape-edges-3">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <polygon points="12,2 22,20 2,20" />
                                </svg>
                                <span>Tri</span>
                            </button>
                            <button class="shape-btn active" onclick="setBgEdges(4)" id="shape-edges-4">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <rect x="3" y="3" width="18" height="18" rx="2" />
                                </svg>
                                <span>Square</span>
                            </button>
                            <button class="shape-btn" onclick="setBgEdges(5)" id="shape-edges-5">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <polygon points="12,2 21.5,9.5 18,20.5 6,20.5 2.5,9.5" />
                                </svg>
                                <span>Pent</span>
                            </button>
                            <button class="shape-btn" onclick="setBgEdges(6)" id="shape-edges-6">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <polygon points="12,2 20.7,6 20.7,18 12,22 3.3,18 3.3,6" />
                                </svg>
                                <span>Hex</span>
                            </button>
                        </div>
                        <div class="edges-stepper">
                            <button onclick="adjustBgEdges(-1)">&#8722;</button>
                            <span class="edges-value" id="edges-value">4</span>
                            <button onclick="adjustBgEdges(1)">+</button>
                            <span class="edges-label" id="edges-label">Square</span>
                        </div>
                        <div class="padding-control">
                            <label>Icon Padding</label>
                            <div class="stroke-row" style="margin-bottom: 0;">
                                <input type="range" class="stroke-slider" id="icon-padding" min="0" max="30" step="1"
                                    value="10" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                    onchange="updatePadding(this.value, true)" oninput="updatePadding(this.value)">
                                <span class="stroke-value" id="padding-value">10%</span>
                            </div>
                        </div>
                        <div class="corner-radius-control" id="corner-radius-control">
                            <label>Corner Radius</label>
                            <div class="stroke-row" style="margin-bottom: 0;">
                                <input type="range" class="stroke-slider" id="corner-radius" min="0" max="50" step="1"
                                    value="10" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                    onchange="updateCornerRadius(this.value, true)"
                                    oninput="updateCornerRadius(this.value)">
                                <span class="stroke-value" id="radius-value">10%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Export Options Section -->
                <div class="control-section">
                    <h3>Export Options</h3>
                    <div style="margin-bottom: 10px;">
                        <div class="increment-options">
                            <button class="increment-btn active" id="format-svg"
                                onclick="setOutputFormat('svg')">SVG</button>
                            <button class="increment-btn" id="format-png" onclick="setOutputFormat('png')">PNG</button>
                        </div>
                    </div>
                    <div id="png-size-section" style="display: none; margin-bottom: 10px;">
                        <label
                            style="display: block; font-size: 10px; color: var(--text-secondary); margin-bottom: 6px;">PNG
                            Size</label>
                        <div class="increment-options" style="flex-wrap: wrap; gap: 4px;">
                            <button class="increment-btn" id="size-32" onclick="setOutputSize(32)">32</button>
                            <button class="increment-btn" id="size-64" onclick="setOutputSize(64)">64</button>
                            <button class="increment-btn" id="size-128" onclick="setOutputSize(128)">128</button>
                            <button class="increment-btn" id="size-256" onclick="setOutputSize(256)">256</button>
                            <button class="increment-btn active" id="size-512" onclick="setOutputSize(512)">512</button>
                            <button class="increment-btn" id="size-1024" onclick="setOutputSize(1024)">1024</button>
                        </div>
                    </div>
                    <div id="svg-options-section">
                        <div class="bg-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="fm-compat" checked onchange="toggleFMCompat(this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                            <span title="Adds fm_fill class for FileMaker styling">FileMaker Compatible</span>
                        </div>
                        <div class="bg-toggle" style="margin-top: 10px;">
                            <label class="toggle-switch">
                                <input type="checkbox" id="fm-dynamic" checked onchange="toggleFMDynamic(this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                            <span>Dynamic Fill</span>
                        </div>
                        <p style="font-size: 10px; color: var(--text-secondary); margin-top: 6px; line-height: 1.3;">
                            Remove fills so FileMaker can apply colors at runtime. Turn off to keep your chosen color.
                        </p>
                        <div id="fm-target-section" style="display: none; margin-top: 10px;">
                            <label
                                style="display: block; font-size: 10px; color: var(--text-secondary); margin-bottom: 6px;">FileMaker
                                controls:</label>
                            <div class="increment-options">
                                <button class="increment-btn active" id="target-icon"
                                    onclick="setFMTarget('icon')">Icon</button>
                                <button class="increment-btn" id="target-background"
                                    onclick="setFMTarget('background')">Background</button>
                            </div>
                            <p style="font-size: 10px; color: var(--text-secondary); margin-top: 6px; line-height: 1.3;"
                                id="fm-target-hint">
                                FileMaker will dynamically change the icon color. Background keeps its set color.
                            </p>
                        </div>
                        <div id="stroke-convert-section"
                            style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                            <div class="bg-toggle">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="convert-strokes" checked
                                        onchange="toggleStrokeConversion(this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span>Convert Strokes to Fills</span>
                            </div>
                            <p
                                style="font-size: 10px; color: var(--text-secondary); margin-top: 6px; line-height: 1.3;">
                                Stroke-based SVGs detected. Strokes will be converted to filled paths for better
                                FileMaker compatibility.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="btn btn-secondary" id="copy-btn" onclick="copySVGToClipboard()" disabled
                        title="Copy SVG to clipboard">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                        </svg>
                        <span id="copy-btn-text">Copy</span>
                    </button>
                    <button class="btn btn-primary" id="save-btn" onclick="saveSVG()" disabled>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                            <polyline points="17 21 17 13 7 13 7 21" />
                            <polyline points="7 3 7 8 15 8" />
                        </svg>
                        <span id="save-btn-text">Save SVG</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal-card">
            <div class="modal-icon" id="modal-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                    <path d="M3 3v5h5" />
                </svg>
            </div>
            <div class="modal-title" id="modal-title">Reset to Original?</div>
            <div class="modal-message" id="modal-message">
                You have unsaved changes. Are you sure you want to reset to the original SVG? This action cannot be
                undone.
            </div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" id="modal-cancel-btn" onclick="hideConfirmModal()">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="modal-confirm-btn"
                    onclick="confirmModalAction()">Reset</button>
            </div>
        </div>
    </div>

    <!-- Code View Modal -->
    <div class="code-view-overlay" id="code-view-modal">
        <div class="code-view-card">
            <div class="code-view-header">
                <h3 id="code-view-title">SVG Code</h3>
                <div class="code-view-actions">
                    <button class="btn btn-secondary" id="code-view-copy-btn" onclick="copyCodeViewContent()"
                        style="padding: 6px 12px; font-size: 11px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12"
                            height="12">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                        </svg>
                        Copy
                    </button>
                    <button class="code-view-close" onclick="hideCodeView()">&times;</button>
                </div>
            </div>
            <pre class="code-view-pre" id="code-view-content"></pre>
        </div>
    </div>

    <!-- SVG Selection Modal -->
    <div class="modal-overlay" id="svg-selection-modal">
        <div class="modal-card" style="max-width: 360px;">
            <div class="modal-title" id="svg-selection-title">Select SVG</div>
            <div class="modal-message" id="svg-selection-message">Choose an SVG:</div>
            <ul class="svg-selection-list" id="svg-selection-list"></ul>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" onclick="hideSVGSelectionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Issue Report Modal -->
    <div class="modal-overlay" id="issue-report-modal">
        <div class="issue-report-card">
            <div class="modal-icon">
                <svg viewBox="0 0 1200 1200" fill="#f59e0b" stroke="none">
                    <path
                        d="m1128.9 905.81-424.31-734.63c-21.75-37.875-60.938-60.375-104.62-60.375s-82.875 22.5-104.62 60.375l-424.31 734.63c-21.75 37.875-21.75 83.062 0 120.94 21.938 37.875 61.125 60.562 104.81 60.562h848.26c43.688 0 82.875-22.688 104.81-60.562 21.75-37.875 21.75-83.062 0-120.94zm-597.19-6.375c0-37.688 30.562-68.25 68.25-68.25s68.25 30.562 68.25 68.25-30.562 68.438-68.25 68.438-68.25-30.75-68.25-68.438zm127.69-155.63c-1.5 31.875-27.562 56.812-59.438 56.812s-57.938-24.938-59.438-56.812l-14.625-322.13c-0.9375-20.438 6.1875-39.938 20.438-54.75 14.062-14.625 33.188-22.875 53.625-22.875s39.562 8.25 53.625 22.875c14.25 14.812 21.375 34.312 20.438 54.75z" />
                </svg>
            </div>
            <div class="modal-title">Report an Issue</div>
            <div class="issue-report-description">
                Having trouble with your SVG output? Not looking like what you'd expect in FileMaker? Submit a report
                and I'll diagnose and address the problem. Your current SVG(s) and editor settings will be included
                automatically. Thanks! &mdash; Daniel (FM Weetbicks)
            </div>
            <div class="issue-report-field">
                <label for="issue-report-email">Email <span
                        style="font-weight:400;color:var(--text-secondary)">(optional)</span></label>
                <input type="email" id="issue-report-email" placeholder="you@example.com">
                <div class="field-hint">Get notified when a fix is available</div>
            </div>
            <div class="issue-report-field">
                <label for="issue-report-details">What's the problem?</label>
                <textarea id="issue-report-details"
                    placeholder="Describe what you're seeing, e.g. &quot;The icon loses its fill color when saved&quot; or &quot;Arcs look distorted in FileMaker&quot;"></textarea>
            </div>
            <div class="issue-report-info">
                This report will include: your loaded SVG file(s), the processed output, and current editor settings. No
                other data is collected.
            </div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" onclick="hideIssueReport()">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="issue-report-submit-btn"
                    onclick="submitIssueReport()">Submit Report</button>
            </div>
        </div>
    </div>

    <!-- Potrace library for stroke-to-fill conversion (bitmap tracing) -->
    <script>
        /* 
         * A javascript port of Potrace (http://potrace.sourceforge.net).
         * 
         * Licensed under the GPL
         * 
         * Usage
         *   loadImageFromFile(file) : load image from File API
         *   loadImageFromUrl(url): load image from URL
         *     because of the same-origin policy, can not load image from another domain.
         *     input color/grayscale image is simply converted to binary image. no pre-
         *     process is performed.
         * 
         *   setParameter({para1: value, ...}) : set parameters
         *     parameters:
         *        turnpolicy ("black" / "white" / "left" / "right" / "minority" / "majority")
         *          how to resolve ambiguities in path decomposition. (default: "minority")       
         *        turdsize
         *          suppress speckles of up to this size (default: 2)
         *        optcurve (true / false)
         *          turn on/off curve optimization (default: true)
         *        alphamax
         *          corner threshold parameter (default: 1)
         *        opttolerance 
         *          curve optimization tolerance (default: 0.2)
         *       
         *   process(callback) : wait for the image be loaded, then run potrace algorithm,
         *                       then call callback function.
         * 
         *   getSVG: getSVG(size, opt_type) : return a string of generated SVG image.
         *                                    result_image_size = original_image_size * size
         *                                    optional parameter opt_type can be "curve"
         */

        var Potrace = (function () {

            function Point(x, y) {
                this.x = x;
                this.y = y;
            }

            Point.prototype.copy = function () {
                return new Point(this.x, this.y);
            };

            function Bitmap(w, h) {
                this.w = w;
                this.h = h;
                this.size = w * h;
                this.arraybuffer = new ArrayBuffer(this.size);
                this.data = new Int8Array(this.arraybuffer);
            }

            Bitmap.prototype.at = function (x, y) {
                return (x >= 0 && x < this.w && y >= 0 && y < this.h) &&
                    this.data[this.w * y + x] === 1;
            };

            Bitmap.prototype.index = function (i) {
                var point = new Point();
                point.y = Math.floor(i / this.w);
                point.x = i - point.y * this.w;
                return point;
            };

            Bitmap.prototype.flip = function (x, y) {
                if (this.at(x, y)) {
                    this.data[this.w * y + x] = 0;
                } else {
                    this.data[this.w * y + x] = 1;
                }
            };

            Bitmap.prototype.copy = function () {
                var bm = new Bitmap(this.w, this.h), i;
                for (i = 0; i < this.size; i++) {
                    bm.data[i] = this.data[i];
                }
                return bm;
            };

            function Path() {
                this.area = 0;
                this.len = 0;
                this.curve = {};
                this.pt = [];
                this.minX = 100000;
                this.minY = 100000;
                this.maxX = -1;
                this.maxY = -1;
            }

            function Curve(n) {
                this.n = n;
                this.tag = new Array(n);
                this.c = new Array(n * 3);
                this.alphaCurve = 0;
                this.vertex = new Array(n);
                this.alpha = new Array(n);
                this.alpha0 = new Array(n);
                this.beta = new Array(n);
            }

            var imgElement = document.createElement("img"),
                imgCanvas = document.createElement("canvas"),
                bm = null,
                pathlist = [],
                callback,
                info = {
                    isReady: false,
                    turnpolicy: "minority",
                    turdsize: 2,
                    optcurve: true,
                    alphamax: 1,
                    opttolerance: 0.2
                };

            imgElement.onload = function () {
                loadCanvas();
                loadBm();
            };

            function loadImageFromFile(file) {
                if (info.isReady) {
                    clear();
                }
                imgElement.file = file;
                var reader = new FileReader();
                reader.onload = (function (aImg) {
                    return function (e) {
                        aImg.src = e.target.result;
                    };
                })(imgElement);
                reader.readAsDataURL(file);
            }

            function loadImageFromUrl(url) {
                if (info.isReady) {
                    clear();
                }
                imgElement.src = url;

            }

            function setParameter(obj) {
                var key;
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        info[key] = obj[key];
                    }
                }
            }

            function loadCanvas() {
                imgCanvas.width = imgElement.width;
                imgCanvas.height = imgElement.height;
                var ctx = imgCanvas.getContext('2d');
                ctx.drawImage(imgElement, 0, 0);
            }

            function loadBm() {
                var ctx = imgCanvas.getContext('2d');
                bm = new Bitmap(imgCanvas.width, imgCanvas.height);
                var imgdataobj = ctx.getImageData(0, 0, bm.w, bm.h);
                var l = imgdataobj.data.length, i, j, color;
                for (i = 0, j = 0; i < l; i += 4, j++) {
                    color = 0.2126 * imgdataobj.data[i] + 0.7153 * imgdataobj.data[i + 1] +
                        0.0721 * imgdataobj.data[i + 2];
                    bm.data[j] = (color < 128 ? 1 : 0);
                }
                info.isReady = true;
            }


            function bmToPathlist() {

                var bm1 = bm.copy(),
                    currentPoint = new Point(0, 0),
                    path;

                function findNext(point) {
                    var i = bm1.w * point.y + point.x;
                    while (i < bm1.size && bm1.data[i] !== 1) {
                        i++;
                    }
                    return i < bm1.size && bm1.index(i);
                }

                function majority(x, y) {
                    var i, a, ct;
                    for (i = 2; i < 5; i++) {
                        ct = 0;
                        for (a = -i + 1; a <= i - 1; a++) {
                            ct += bm1.at(x + a, y + i - 1) ? 1 : -1;
                            ct += bm1.at(x + i - 1, y + a - 1) ? 1 : -1;
                            ct += bm1.at(x + a - 1, y - i) ? 1 : -1;
                            ct += bm1.at(x - i, y + a) ? 1 : -1;
                        }
                        if (ct > 0) {
                            return 1;
                        } else if (ct < 0) {
                            return 0;
                        }
                    }
                    return 0;
                }

                function findPath(point) {
                    var path = new Path(),
                        x = point.x, y = point.y,
                        dirx = 0, diry = 1, tmp;

                    path.sign = bm.at(point.x, point.y) ? "+" : "-";

                    while (1) {
                        path.pt.push(new Point(x, y));
                        if (x > path.maxX)
                            path.maxX = x;
                        if (x < path.minX)
                            path.minX = x;
                        if (y > path.maxY)
                            path.maxY = y;
                        if (y < path.minY)
                            path.minY = y;
                        path.len++;

                        x += dirx;
                        y += diry;
                        path.area -= x * diry;

                        if (x === point.x && y === point.y)
                            break;

                        var l = bm1.at(x + (dirx + diry - 1) / 2, y + (diry - dirx - 1) / 2);
                        var r = bm1.at(x + (dirx - diry - 1) / 2, y + (diry + dirx - 1) / 2);

                        if (r && !l) {
                            if (info.turnpolicy === "right" ||
                                (info.turnpolicy === "black" && path.sign === '+') ||
                                (info.turnpolicy === "white" && path.sign === '-') ||
                                (info.turnpolicy === "majority" && majority(x, y)) ||
                                (info.turnpolicy === "minority" && !majority(x, y))) {
                                tmp = dirx;
                                dirx = -diry;
                                diry = tmp;
                            } else {
                                tmp = dirx;
                                dirx = diry;
                                diry = -tmp;
                            }
                        } else if (r) {
                            tmp = dirx;
                            dirx = -diry;
                            diry = tmp;
                        } else if (!l) {
                            tmp = dirx;
                            dirx = diry;
                            diry = -tmp;
                        }
                    }
                    return path;
                }

                function xorPath(path) {
                    var y1 = path.pt[0].y,
                        len = path.len,
                        x, y, maxX, minY, i, j;
                    for (i = 1; i < len; i++) {
                        x = path.pt[i].x;
                        y = path.pt[i].y;

                        if (y !== y1) {
                            minY = y1 < y ? y1 : y;
                            maxX = path.maxX;
                            for (j = x; j < maxX; j++) {
                                bm1.flip(j, minY);
                            }
                            y1 = y;
                        }
                    }

                }

                while (currentPoint = findNext(currentPoint)) {

                    path = findPath(currentPoint);

                    xorPath(path);

                    if (path.area > info.turdsize) {
                        pathlist.push(path);
                    }
                }

            }


            function processPath() {

                function Quad() {
                    this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                }

                Quad.prototype.at = function (x, y) {
                    return this.data[x * 3 + y];
                };

                function Sum(x, y, xy, x2, y2) {
                    this.x = x;
                    this.y = y;
                    this.xy = xy;
                    this.x2 = x2;
                    this.y2 = y2;
                }

                function mod(a, n) {
                    return a >= n ? a % n : a >= 0 ? a : n - 1 - (-1 - a) % n;
                }

                function xprod(p1, p2) {
                    return p1.x * p2.y - p1.y * p2.x;
                }

                function cyclic(a, b, c) {
                    if (a <= c) {
                        return (a <= b && b < c);
                    } else {
                        return (a <= b || b < c);
                    }
                }

                function sign(i) {
                    return i > 0 ? 1 : i < 0 ? -1 : 0;
                }

                function quadform(Q, w) {
                    var v = new Array(3), i, j, sum;

                    v[0] = w.x;
                    v[1] = w.y;
                    v[2] = 1;
                    sum = 0.0;

                    for (i = 0; i < 3; i++) {
                        for (j = 0; j < 3; j++) {
                            sum += v[i] * Q.at(i, j) * v[j];
                        }
                    }
                    return sum;
                }

                function interval(lambda, a, b) {
                    var res = new Point();

                    res.x = a.x + lambda * (b.x - a.x);
                    res.y = a.y + lambda * (b.y - a.y);
                    return res;
                }

                function dorth_infty(p0, p2) {
                    var r = new Point();

                    r.y = sign(p2.x - p0.x);
                    r.x = -sign(p2.y - p0.y);

                    return r;
                }

                function ddenom(p0, p2) {
                    var r = dorth_infty(p0, p2);

                    return r.y * (p2.x - p0.x) - r.x * (p2.y - p0.y);
                }

                function dpara(p0, p1, p2) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p2.x - p0.x;
                    y2 = p2.y - p0.y;

                    return x1 * y2 - x2 * y1;
                }

                function cprod(p0, p1, p2, p3) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p3.x - p2.x;
                    y2 = p3.y - p2.y;

                    return x1 * y2 - x2 * y1;
                }

                function iprod(p0, p1, p2) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p2.x - p0.x;
                    y2 = p2.y - p0.y;

                    return x1 * x2 + y1 * y2;
                }

                function iprod1(p0, p1, p2, p3) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p3.x - p2.x;
                    y2 = p3.y - p2.y;

                    return x1 * x2 + y1 * y2;
                }

                function ddist(p, q) {
                    return Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
                }

                function bezier(t, p0, p1, p2, p3) {
                    var s = 1 - t, res = new Point();

                    res.x = s * s * s * p0.x + 3 * (s * s * t) * p1.x + 3 * (t * t * s) * p2.x + t * t * t * p3.x;
                    res.y = s * s * s * p0.y + 3 * (s * s * t) * p1.y + 3 * (t * t * s) * p2.y + t * t * t * p3.y;

                    return res;
                }

                function tangent(p0, p1, p2, p3, q0, q1) {
                    var A, B, C, a, b, c, d, s, r1, r2;

                    A = cprod(p0, p1, q0, q1);
                    B = cprod(p1, p2, q0, q1);
                    C = cprod(p2, p3, q0, q1);

                    a = A - 2 * B + C;
                    b = -2 * A + 2 * B;
                    c = A;

                    d = b * b - 4 * a * c;

                    if (a === 0 || d < 0) {
                        return -1.0;
                    }

                    s = Math.sqrt(d);

                    r1 = (-b + s) / (2 * a);
                    r2 = (-b - s) / (2 * a);

                    if (r1 >= 0 && r1 <= 1) {
                        return r1;
                    } else if (r2 >= 0 && r2 <= 1) {
                        return r2;
                    } else {
                        return -1.0;
                    }
                }

                function calcSums(path) {
                    var i, x, y;
                    path.x0 = path.pt[0].x;
                    path.y0 = path.pt[0].y;

                    path.sums = [];
                    var s = path.sums;
                    s.push(new Sum(0, 0, 0, 0, 0));
                    for (i = 0; i < path.len; i++) {
                        x = path.pt[i].x - path.x0;
                        y = path.pt[i].y - path.y0;
                        s.push(new Sum(s[i].x + x, s[i].y + y, s[i].xy + x * y,
                            s[i].x2 + x * x, s[i].y2 + y * y));
                    }
                }

                function calcLon(path) {

                    var n = path.len, pt = path.pt, dir,
                        pivk = new Array(n),
                        nc = new Array(n),
                        ct = new Array(4);
                    path.lon = new Array(n);

                    var constraint = [new Point(), new Point()],
                        cur = new Point(),
                        off = new Point(),
                        dk = new Point(),
                        foundk;

                    var i, j, k1, a, b, c, d, k = 0;
                    for (i = n - 1; i >= 0; i--) {
                        if (pt[i].x != pt[k].x && pt[i].y != pt[k].y) {
                            k = i + 1;
                        }
                        nc[i] = k;
                    }

                    for (i = n - 1; i >= 0; i--) {
                        ct[0] = ct[1] = ct[2] = ct[3] = 0;
                        dir = (3 + 3 * (pt[mod(i + 1, n)].x - pt[i].x) +
                            (pt[mod(i + 1, n)].y - pt[i].y)) / 2;
                        ct[dir]++;

                        constraint[0].x = 0;
                        constraint[0].y = 0;
                        constraint[1].x = 0;
                        constraint[1].y = 0;

                        k = nc[i];
                        k1 = i;
                        while (1) {
                            foundk = 0;
                            dir = (3 + 3 * sign(pt[k].x - pt[k1].x) +
                                sign(pt[k].y - pt[k1].y)) / 2;
                            ct[dir]++;

                            if (ct[0] && ct[1] && ct[2] && ct[3]) {
                                pivk[i] = k1;
                                foundk = 1;
                                break;
                            }

                            cur.x = pt[k].x - pt[i].x;
                            cur.y = pt[k].y - pt[i].y;

                            if (xprod(constraint[0], cur) < 0 || xprod(constraint[1], cur) > 0) {
                                break;
                            }

                            if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) {

                            } else {
                                off.x = cur.x + ((cur.y >= 0 && (cur.y > 0 || cur.x < 0)) ? 1 : -1);
                                off.y = cur.y + ((cur.x <= 0 && (cur.x < 0 || cur.y < 0)) ? 1 : -1);
                                if (xprod(constraint[0], off) >= 0) {
                                    constraint[0].x = off.x;
                                    constraint[0].y = off.y;
                                }
                                off.x = cur.x + ((cur.y <= 0 && (cur.y < 0 || cur.x < 0)) ? 1 : -1);
                                off.y = cur.y + ((cur.x >= 0 && (cur.x > 0 || cur.y < 0)) ? 1 : -1);
                                if (xprod(constraint[1], off) <= 0) {
                                    constraint[1].x = off.x;
                                    constraint[1].y = off.y;
                                }
                            }
                            k1 = k;
                            k = nc[k1];
                            if (!cyclic(k, i, k1)) {
                                break;
                            }
                        }
                        if (foundk === 0) {
                            dk.x = sign(pt[k].x - pt[k1].x);
                            dk.y = sign(pt[k].y - pt[k1].y);
                            cur.x = pt[k1].x - pt[i].x;
                            cur.y = pt[k1].y - pt[i].y;

                            a = xprod(constraint[0], cur);
                            b = xprod(constraint[0], dk);
                            c = xprod(constraint[1], cur);
                            d = xprod(constraint[1], dk);

                            j = 10000000;
                            if (b < 0) {
                                j = Math.floor(a / -b);
                            }
                            if (d > 0) {
                                j = Math.min(j, Math.floor(-c / d));
                            }
                            pivk[i] = mod(k1 + j, n);
                        }
                    }

                    j = pivk[n - 1];
                    path.lon[n - 1] = j;
                    for (i = n - 2; i >= 0; i--) {
                        if (cyclic(i + 1, pivk[i], j)) {
                            j = pivk[i];
                        }
                        path.lon[i] = j;
                    }

                    for (i = n - 1; cyclic(mod(i + 1, n), j, path.lon[i]); i--) {
                        path.lon[i] = j;
                    }
                }

                function bestPolygon(path) {

                    function penalty3(path, i, j) {

                        var n = path.len, pt = path.pt, sums = path.sums;
                        var x, y, xy, x2, y2,
                            k, a, b, c, s,
                            px, py, ex, ey,
                            r = 0;
                        if (j >= n) {
                            j -= n;
                            r = 1;
                        }

                        if (r === 0) {
                            x = sums[j + 1].x - sums[i].x;
                            y = sums[j + 1].y - sums[i].y;
                            x2 = sums[j + 1].x2 - sums[i].x2;
                            xy = sums[j + 1].xy - sums[i].xy;
                            y2 = sums[j + 1].y2 - sums[i].y2;
                            k = j + 1 - i;
                        } else {
                            x = sums[j + 1].x - sums[i].x + sums[n].x;
                            y = sums[j + 1].y - sums[i].y + sums[n].y;
                            x2 = sums[j + 1].x2 - sums[i].x2 + sums[n].x2;
                            xy = sums[j + 1].xy - sums[i].xy + sums[n].xy;
                            y2 = sums[j + 1].y2 - sums[i].y2 + sums[n].y2;
                            k = j + 1 - i + n;
                        }

                        px = (pt[i].x + pt[j].x) / 2.0 - pt[0].x;
                        py = (pt[i].y + pt[j].y) / 2.0 - pt[0].y;
                        ey = (pt[j].x - pt[i].x);
                        ex = -(pt[j].y - pt[i].y);

                        a = ((x2 - 2 * x * px) / k + px * px);
                        b = ((xy - x * py - y * px) / k + px * py);
                        c = ((y2 - 2 * y * py) / k + py * py);

                        s = ex * ex * a + 2 * ex * ey * b + ey * ey * c;

                        return Math.sqrt(s);
                    }

                    var i, j, m, k,
                        n = path.len,
                        pen = new Array(n + 1),
                        prev = new Array(n + 1),
                        clip0 = new Array(n),
                        clip1 = new Array(n + 1),
                        seg0 = new Array(n + 1),
                        seg1 = new Array(n + 1),
                        thispen, best, c;

                    for (i = 0; i < n; i++) {
                        c = mod(path.lon[mod(i - 1, n)] - 1, n);
                        if (c == i) {
                            c = mod(i + 1, n);
                        }
                        if (c < i) {
                            clip0[i] = n;
                        } else {
                            clip0[i] = c;
                        }
                    }

                    j = 1;
                    for (i = 0; i < n; i++) {
                        while (j <= clip0[i]) {
                            clip1[j] = i;
                            j++;
                        }
                    }

                    i = 0;
                    for (j = 0; i < n; j++) {
                        seg0[j] = i;
                        i = clip0[i];
                    }
                    seg0[j] = n;
                    m = j;

                    i = n;
                    for (j = m; j > 0; j--) {
                        seg1[j] = i;
                        i = clip1[i];
                    }
                    seg1[0] = 0;

                    pen[0] = 0;
                    for (j = 1; j <= m; j++) {
                        for (i = seg1[j]; i <= seg0[j]; i++) {
                            best = -1;
                            for (k = seg0[j - 1]; k >= clip1[i]; k--) {
                                thispen = penalty3(path, k, i) + pen[k];
                                if (best < 0 || thispen < best) {
                                    prev[i] = k;
                                    best = thispen;
                                }
                            }
                            pen[i] = best;
                        }
                    }
                    path.m = m;
                    path.po = new Array(m);

                    for (i = n, j = m - 1; i > 0; j--) {
                        i = prev[i];
                        path.po[j] = i;
                    }
                }

                function adjustVertices(path) {

                    function pointslope(path, i, j, ctr, dir) {

                        var n = path.len, sums = path.sums,
                            x, y, x2, xy, y2,
                            k, a, b, c, lambda2, l, r = 0;

                        while (j >= n) {
                            j -= n;
                            r += 1;
                        }
                        while (i >= n) {
                            i -= n;
                            r -= 1;
                        }
                        while (j < 0) {
                            j += n;
                            r -= 1;
                        }
                        while (i < 0) {
                            i += n;
                            r += 1;
                        }

                        x = sums[j + 1].x - sums[i].x + r * sums[n].x;
                        y = sums[j + 1].y - sums[i].y + r * sums[n].y;
                        x2 = sums[j + 1].x2 - sums[i].x2 + r * sums[n].x2;
                        xy = sums[j + 1].xy - sums[i].xy + r * sums[n].xy;
                        y2 = sums[j + 1].y2 - sums[i].y2 + r * sums[n].y2;
                        k = j + 1 - i + r * n;

                        ctr.x = x / k;
                        ctr.y = y / k;

                        a = (x2 - x * x / k) / k;
                        b = (xy - x * y / k) / k;
                        c = (y2 - y * y / k) / k;

                        lambda2 = (a + c + Math.sqrt((a - c) * (a - c) + 4 * b * b)) / 2;

                        a -= lambda2;
                        c -= lambda2;

                        if (Math.abs(a) >= Math.abs(c)) {
                            l = Math.sqrt(a * a + b * b);
                            if (l !== 0) {
                                dir.x = -b / l;
                                dir.y = a / l;
                            }
                        } else {
                            l = Math.sqrt(c * c + b * b);
                            if (l !== 0) {
                                dir.x = -c / l;
                                dir.y = b / l;
                            }
                        }
                        if (l === 0) {
                            dir.x = dir.y = 0;
                        }
                    }

                    var m = path.m, po = path.po, n = path.len, pt = path.pt,
                        x0 = path.x0, y0 = path.y0,
                        ctr = new Array(m), dir = new Array(m),
                        q = new Array(m),
                        v = new Array(3), d, i, j, k, l,
                        s = new Point();

                    path.curve = new Curve(m);

                    for (i = 0; i < m; i++) {
                        j = po[mod(i + 1, m)];
                        j = mod(j - po[i], n) + po[i];
                        ctr[i] = new Point();
                        dir[i] = new Point();
                        pointslope(path, po[i], j, ctr[i], dir[i]);
                    }

                    for (i = 0; i < m; i++) {
                        q[i] = new Quad();
                        d = dir[i].x * dir[i].x + dir[i].y * dir[i].y;
                        if (d === 0.0) {
                            for (j = 0; j < 3; j++) {
                                for (k = 0; k < 3; k++) {
                                    q[i].data[j * 3 + k] = 0;
                                }
                            }
                        } else {
                            v[0] = dir[i].y;
                            v[1] = -dir[i].x;
                            v[2] = - v[1] * ctr[i].y - v[0] * ctr[i].x;
                            for (l = 0; l < 3; l++) {
                                for (k = 0; k < 3; k++) {
                                    q[i].data[l * 3 + k] = v[l] * v[k] / d;
                                }
                            }
                        }
                    }

                    var Q, w, dx, dy, det, min, cand, xmin, ymin, z;
                    for (i = 0; i < m; i++) {
                        Q = new Quad();
                        w = new Point();

                        s.x = pt[po[i]].x - x0;
                        s.y = pt[po[i]].y - y0;

                        j = mod(i - 1, m);

                        for (l = 0; l < 3; l++) {
                            for (k = 0; k < 3; k++) {
                                Q.data[l * 3 + k] = q[j].at(l, k) + q[i].at(l, k);
                            }
                        }

                        while (1) {

                            det = Q.at(0, 0) * Q.at(1, 1) - Q.at(0, 1) * Q.at(1, 0);
                            if (det !== 0.0) {
                                w.x = (-Q.at(0, 2) * Q.at(1, 1) + Q.at(1, 2) * Q.at(0, 1)) / det;
                                w.y = (Q.at(0, 2) * Q.at(1, 0) - Q.at(1, 2) * Q.at(0, 0)) / det;
                                break;
                            }

                            if (Q.at(0, 0) > Q.at(1, 1)) {
                                v[0] = -Q.at(0, 1);
                                v[1] = Q.at(0, 0);
                            } else if (Q.at(1, 1)) {
                                v[0] = -Q.at(1, 1);
                                v[1] = Q.at(1, 0);
                            } else {
                                v[0] = 1;
                                v[1] = 0;
                            }
                            d = v[0] * v[0] + v[1] * v[1];
                            v[2] = - v[1] * s.y - v[0] * s.x;
                            for (l = 0; l < 3; l++) {
                                for (k = 0; k < 3; k++) {
                                    Q.data[l * 3 + k] += v[l] * v[k] / d;
                                }
                            }
                        }
                        dx = Math.abs(w.x - s.x);
                        dy = Math.abs(w.y - s.y);
                        if (dx <= 0.5 && dy <= 0.5) {
                            path.curve.vertex[i] = new Point(w.x + x0, w.y + y0);
                            continue;
                        }

                        min = quadform(Q, s);
                        xmin = s.x;
                        ymin = s.y;

                        if (Q.at(0, 0) !== 0.0) {
                            for (z = 0; z < 2; z++) {
                                w.y = s.y - 0.5 + z;
                                w.x = - (Q.at(0, 1) * w.y + Q.at(0, 2)) / Q.at(0, 0);
                                dx = Math.abs(w.x - s.x);
                                cand = quadform(Q, w);
                                if (dx <= 0.5 && cand < min) {
                                    min = cand;
                                    xmin = w.x;
                                    ymin = w.y;
                                }
                            }
                        }

                        if (Q.at(1, 1) !== 0.0) {
                            for (z = 0; z < 2; z++) {
                                w.x = s.x - 0.5 + z;
                                w.y = - (Q.at(1, 0) * w.x + Q.at(1, 2)) / Q.at(1, 1);
                                dy = Math.abs(w.y - s.y);
                                cand = quadform(Q, w);
                                if (dy <= 0.5 && cand < min) {
                                    min = cand;
                                    xmin = w.x;
                                    ymin = w.y;
                                }
                            }
                        }

                        for (l = 0; l < 2; l++) {
                            for (k = 0; k < 2; k++) {
                                w.x = s.x - 0.5 + l;
                                w.y = s.y - 0.5 + k;
                                cand = quadform(Q, w);
                                if (cand < min) {
                                    min = cand;
                                    xmin = w.x;
                                    ymin = w.y;
                                }
                            }
                        }

                        path.curve.vertex[i] = new Point(xmin + x0, ymin + y0);
                    }
                }

                function reverse(path) {
                    var curve = path.curve, m = curve.n, v = curve.vertex, i, j, tmp;

                    for (i = 0, j = m - 1; i < j; i++, j--) {
                        tmp = v[i];
                        v[i] = v[j];
                        v[j] = tmp;
                    }
                }

                function smooth(path) {
                    var m = path.curve.n, curve = path.curve;

                    var i, j, k, dd, denom, alpha,
                        p2, p3, p4;

                    for (i = 0; i < m; i++) {
                        j = mod(i + 1, m);
                        k = mod(i + 2, m);
                        p4 = interval(1 / 2.0, curve.vertex[k], curve.vertex[j]);

                        denom = ddenom(curve.vertex[i], curve.vertex[k]);
                        if (denom !== 0.0) {
                            dd = dpara(curve.vertex[i], curve.vertex[j], curve.vertex[k]) / denom;
                            dd = Math.abs(dd);
                            alpha = dd > 1 ? (1 - 1.0 / dd) : 0;
                            alpha = alpha / 0.75;
                        } else {
                            alpha = 4 / 3.0;
                        }
                        curve.alpha0[j] = alpha;

                        if (alpha >= info.alphamax) {
                            curve.tag[j] = "CORNER";
                            curve.c[3 * j + 1] = curve.vertex[j];
                            curve.c[3 * j + 2] = p4;
                        } else {
                            if (alpha < 0.55) {
                                alpha = 0.55;
                            } else if (alpha > 1) {
                                alpha = 1;
                            }
                            p2 = interval(0.5 + 0.5 * alpha, curve.vertex[i], curve.vertex[j]);
                            p3 = interval(0.5 + 0.5 * alpha, curve.vertex[k], curve.vertex[j]);
                            curve.tag[j] = "CURVE";
                            curve.c[3 * j + 0] = p2;
                            curve.c[3 * j + 1] = p3;
                            curve.c[3 * j + 2] = p4;
                        }
                        curve.alpha[j] = alpha;
                        curve.beta[j] = 0.5;
                    }
                    curve.alphacurve = 1;
                }

                function optiCurve(path) {
                    function Opti() {
                        this.pen = 0;
                        this.c = [new Point(), new Point()];
                        this.t = 0;
                        this.s = 0;
                        this.alpha = 0;
                    }

                    function opti_penalty(path, i, j, res, opttolerance, convc, areac) {
                        var m = path.curve.n, curve = path.curve, vertex = curve.vertex,
                            k, k1, k2, conv, i1,
                            area, alpha, d, d1, d2,
                            p0, p1, p2, p3, pt,
                            A, R, A1, A2, A3, A4,
                            s, t;

                        if (i == j) {
                            return 1;
                        }

                        k = i;
                        i1 = mod(i + 1, m);
                        k1 = mod(k + 1, m);
                        conv = convc[k1];
                        if (conv === 0) {
                            return 1;
                        }
                        d = ddist(vertex[i], vertex[i1]);
                        for (k = k1; k != j; k = k1) {
                            k1 = mod(k + 1, m);
                            k2 = mod(k + 2, m);
                            if (convc[k1] != conv) {
                                return 1;
                            }
                            if (sign(cprod(vertex[i], vertex[i1], vertex[k1], vertex[k2])) !=
                                conv) {
                                return 1;
                            }
                            if (iprod1(vertex[i], vertex[i1], vertex[k1], vertex[k2]) <
                                d * ddist(vertex[k1], vertex[k2]) * -0.999847695156) {
                                return 1;
                            }
                        }

                        p0 = curve.c[mod(i, m) * 3 + 2].copy();
                        p1 = vertex[mod(i + 1, m)].copy();
                        p2 = vertex[mod(j, m)].copy();
                        p3 = curve.c[mod(j, m) * 3 + 2].copy();

                        area = areac[j] - areac[i];
                        area -= dpara(vertex[0], curve.c[i * 3 + 2], curve.c[j * 3 + 2]) / 2;
                        if (i >= j) {
                            area += areac[m];
                        }

                        A1 = dpara(p0, p1, p2);
                        A2 = dpara(p0, p1, p3);
                        A3 = dpara(p0, p2, p3);

                        A4 = A1 + A3 - A2;

                        if (A2 == A1) {
                            return 1;
                        }

                        t = A3 / (A3 - A4);
                        s = A2 / (A2 - A1);
                        A = A2 * t / 2.0;

                        if (A === 0.0) {
                            return 1;
                        }

                        R = area / A;
                        alpha = 2 - Math.sqrt(4 - R / 0.3);

                        res.c[0] = interval(t * alpha, p0, p1);
                        res.c[1] = interval(s * alpha, p3, p2);
                        res.alpha = alpha;
                        res.t = t;
                        res.s = s;

                        p1 = res.c[0].copy();
                        p2 = res.c[1].copy();

                        res.pen = 0;

                        for (k = mod(i + 1, m); k != j; k = k1) {
                            k1 = mod(k + 1, m);
                            t = tangent(p0, p1, p2, p3, vertex[k], vertex[k1]);
                            if (t < -0.5) {
                                return 1;
                            }
                            pt = bezier(t, p0, p1, p2, p3);
                            d = ddist(vertex[k], vertex[k1]);
                            if (d === 0.0) {
                                return 1;
                            }
                            d1 = dpara(vertex[k], vertex[k1], pt) / d;
                            if (Math.abs(d1) > opttolerance) {
                                return 1;
                            }
                            if (iprod(vertex[k], vertex[k1], pt) < 0 ||
                                iprod(vertex[k1], vertex[k], pt) < 0) {
                                return 1;
                            }
                            res.pen += d1 * d1;
                        }

                        for (k = i; k != j; k = k1) {
                            k1 = mod(k + 1, m);
                            t = tangent(p0, p1, p2, p3, curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
                            if (t < -0.5) {
                                return 1;
                            }
                            pt = bezier(t, p0, p1, p2, p3);
                            d = ddist(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
                            if (d === 0.0) {
                                return 1;
                            }
                            d1 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], pt) / d;
                            d2 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], vertex[k1]) / d;
                            d2 *= 0.75 * curve.alpha[k1];
                            if (d2 < 0) {
                                d1 = -d1;
                                d2 = -d2;
                            }
                            if (d1 < d2 - opttolerance) {
                                return 1;
                            }
                            if (d1 < d2) {
                                res.pen += (d1 - d2) * (d1 - d2);
                            }
                        }

                        return 0;
                    }

                    var curve = path.curve, m = curve.n, vert = curve.vertex,
                        pt = new Array(m + 1),
                        pen = new Array(m + 1),
                        len = new Array(m + 1),
                        opt = new Array(m + 1),
                        om, i, j, r,
                        o = new Opti(), p0,
                        i1, area, alpha, ocurve,
                        s, t;

                    var convc = new Array(m), areac = new Array(m + 1);

                    for (i = 0; i < m; i++) {
                        if (curve.tag[i] == "CURVE") {
                            convc[i] = sign(dpara(vert[mod(i - 1, m)], vert[i], vert[mod(i + 1, m)]));
                        } else {
                            convc[i] = 0;
                        }
                    }

                    area = 0.0;
                    areac[0] = 0.0;
                    p0 = curve.vertex[0];
                    for (i = 0; i < m; i++) {
                        i1 = mod(i + 1, m);
                        if (curve.tag[i1] == "CURVE") {
                            alpha = curve.alpha[i1];
                            area += 0.3 * alpha * (4 - alpha) *
                                dpara(curve.c[i * 3 + 2], vert[i1], curve.c[i1 * 3 + 2]) / 2;
                            area += dpara(p0, curve.c[i * 3 + 2], curve.c[i1 * 3 + 2]) / 2;
                        }
                        areac[i + 1] = area;
                    }

                    pt[0] = -1;
                    pen[0] = 0;
                    len[0] = 0;


                    for (j = 1; j <= m; j++) {
                        pt[j] = j - 1;
                        pen[j] = pen[j - 1];
                        len[j] = len[j - 1] + 1;

                        for (i = j - 2; i >= 0; i--) {
                            r = opti_penalty(path, i, mod(j, m), o, info.opttolerance, convc,
                                areac);
                            if (r) {
                                break;
                            }
                            if (len[j] > len[i] + 1 ||
                                (len[j] == len[i] + 1 && pen[j] > pen[i] + o.pen)) {
                                pt[j] = i;
                                pen[j] = pen[i] + o.pen;
                                len[j] = len[i] + 1;
                                opt[j] = o;
                                o = new Opti();
                            }
                        }
                    }
                    om = len[m];
                    ocurve = new Curve(om);
                    s = new Array(om);
                    t = new Array(om);

                    j = m;
                    for (i = om - 1; i >= 0; i--) {
                        if (pt[j] == j - 1) {
                            ocurve.tag[i] = curve.tag[mod(j, m)];
                            ocurve.c[i * 3 + 0] = curve.c[mod(j, m) * 3 + 0];
                            ocurve.c[i * 3 + 1] = curve.c[mod(j, m) * 3 + 1];
                            ocurve.c[i * 3 + 2] = curve.c[mod(j, m) * 3 + 2];
                            ocurve.vertex[i] = curve.vertex[mod(j, m)];
                            ocurve.alpha[i] = curve.alpha[mod(j, m)];
                            ocurve.alpha0[i] = curve.alpha0[mod(j, m)];
                            ocurve.beta[i] = curve.beta[mod(j, m)];
                            s[i] = t[i] = 1.0;
                        } else {
                            ocurve.tag[i] = "CURVE";
                            ocurve.c[i * 3 + 0] = opt[j].c[0];
                            ocurve.c[i * 3 + 1] = opt[j].c[1];
                            ocurve.c[i * 3 + 2] = curve.c[mod(j, m) * 3 + 2];
                            ocurve.vertex[i] = interval(opt[j].s, curve.c[mod(j, m) * 3 + 2],
                                vert[mod(j, m)]);
                            ocurve.alpha[i] = opt[j].alpha;
                            ocurve.alpha0[i] = opt[j].alpha;
                            s[i] = opt[j].s;
                            t[i] = opt[j].t;
                        }
                        j = pt[j];
                    }

                    for (i = 0; i < om; i++) {
                        i1 = mod(i + 1, om);
                        ocurve.beta[i] = s[i] / (s[i] + t[i1]);
                    }
                    ocurve.alphacurve = 1;
                    path.curve = ocurve;
                }

                for (var i = 0; i < pathlist.length; i++) {
                    var path = pathlist[i];
                    calcSums(path);
                    calcLon(path);
                    bestPolygon(path);
                    adjustVertices(path);

                    if (path.sign === "-") {
                        reverse(path);
                    }

                    smooth(path);

                    if (info.optcurve) {
                        optiCurve(path);
                    }
                }

            }

            function process(c) {
                if (c) {
                    callback = c;
                }
                if (!info.isReady) {
                    setTimeout(process, 100);
                    return;
                }
                bmToPathlist();
                processPath();
                callback();
                callback = null;
            }

            function clear() {
                bm = null;
                pathlist = [];
                callback = null;
                info.isReady = false;
            }

            function getSVG(size, opt_type) {

                function path(curve) {

                    function bezier(i) {
                        var b = 'C ' + (curve.c[i * 3 + 0].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 0].y * size).toFixed(3) + ',';
                        b += (curve.c[i * 3 + 1].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 1].y * size).toFixed(3) + ',';
                        b += (curve.c[i * 3 + 2].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 2].y * size).toFixed(3) + ' ';
                        return b;
                    }

                    function segment(i) {
                        var s = 'L ' + (curve.c[i * 3 + 1].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 1].y * size).toFixed(3) + ' ';
                        s += (curve.c[i * 3 + 2].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 2].y * size).toFixed(3) + ' ';
                        return s;
                    }

                    var n = curve.n, i;
                    var p = 'M' + (curve.c[(n - 1) * 3 + 2].x * size).toFixed(3) +
                        ' ' + (curve.c[(n - 1) * 3 + 2].y * size).toFixed(3) + ' ';
                    for (i = 0; i < n; i++) {
                        if (curve.tag[i] === "CURVE") {
                            p += bezier(i);
                        } else if (curve.tag[i] === "CORNER") {
                            p += segment(i);
                        }
                    }
                    //p += 
                    return p;
                }

                var w = bm.w * size, h = bm.h * size,
                    len = pathlist.length, c, i, strokec, fillc, fillrule;

                var svg = '<svg id="svg" version="1.1" width="' + w + '" height="' + h +
                    '" xmlns="http://www.w3.org/2000/svg">';
                svg += '<path d="';
                for (i = 0; i < len; i++) {
                    c = pathlist[i].curve;
                    svg += path(c);
                }
                if (opt_type === "curve") {
                    strokec = "black";
                    fillc = "none";
                    fillrule = '';
                } else {
                    strokec = "none";
                    fillc = "black";
                    fillrule = ' fill-rule="evenodd"';
                }
                svg += '" stroke="' + strokec + '" fill="' + fillc + '"' + fillrule + '/></svg>';
                return svg;
            }

            return {
                loadImageFromFile: loadImageFromFile,
                loadImageFromUrl: loadImageFromUrl,
                setParameter: setParameter,
                process: process,
                getSVG: getSVG,
                img: imgElement
            };
        })();
    </script>

    <script>
        const _proxyBase = 'https://elemental-svg-proxy.g7hjmj8t8f.workers.dev';

        // ============================================
        // SVG Editor State
        // ============================================
        const state = {
            initialized: false,
            theme: 'dark',
            accentColor: 'orange',
            svgItems: [],               // Array of {filename: string, originalSVG: string, currentSVG: SVGElement}
            rotation: 0,
            rotationIncrement: 30,
            flipH: false,
            flipV: false,
            opacity: 100,           // Icon opacity (0-100%)
            scale: 100,             // Icon scale (50-150%)
            offsetX: 0,             // X offset (-50 to +50% of viewBox)
            offsetY: 0,             // Y offset (-50 to +50% of viewBox)
            fillColor: '#000000',
            strokeColor: '#000000',
            strokeWidth: 0,
            bgEnabled: false,
            bgColor: '#ffffff',
            bgEdges: 4,
            iconPadding: 10,
            cornerRadius: 10,
            zoom: 1,
            fmCompatible: true,         // Apply FileMaker compatibility processing
            fmDynamicFill: true,        // Remove fills for FileMaker dynamic styling (vs baked-in color)
            fmDynamicTarget: 'icon',    // Which element FM controls: 'icon' or 'background'
            normalizePaths: false,      // Normalize path commands (can cause issues, off by default)
            fileMakerMode: false,       // True for FileMaker output, false for browser download. Set via initEditor({output_mode: 'fm'|'browser'})
            outputFormat: 'svg',        // 'svg' or 'png'
            outputSize: 512,            // Size for PNG export (e.g., 512 = 512x512)
            hasStrokeSVGs: false,       // True if any loaded SVGs are stroke-based
            convertStrokesToFills: true, // Convert stroke SVGs to filled paths on export
            previewBg: 'checkerboard',  // Preview background: 'checkerboard', 'white', 'black', 'custom'
            previewBgCustomColor: '#808080' // Custom preview background color
        };

        // ============================================
        // Undo/Redo History
        // ============================================
        const history = {
            undoStack: [],    // Stack of previous states
            redoStack: [],    // Stack of states for redo
            maxSize: 50       // Maximum history size
        };

        /**
         * Get the current state snapshot for history (only user-modifiable properties)
         */
        function getStateSnapshot() {
            return {
                rotation: state.rotation,
                flipH: state.flipH,
                flipV: state.flipV,
                opacity: state.opacity,
                scale: state.scale,
                offsetX: state.offsetX,
                offsetY: state.offsetY,
                fillColor: state.fillColor,
                strokeColor: state.strokeColor,
                strokeWidth: state.strokeWidth,
                bgEnabled: state.bgEnabled,
                bgColor: state.bgColor,
                bgEdges: state.bgEdges,
                iconPadding: state.iconPadding,
                cornerRadius: state.cornerRadius,
                svgItems: state.svgItems.map(item => ({
                    filename: item.filename,
                    originalSVG: item.originalSVG,
                    currentSVG: item.currentSVG.cloneNode(true)
                }))
            };
        }

        /**
         * Apply a state snapshot (restore from history)
         */
        function applyStateSnapshot(snapshot) {
            state.rotation = snapshot.rotation;
            state.flipH = snapshot.flipH;
            state.flipV = snapshot.flipV;
            state.opacity = snapshot.opacity !== undefined ? snapshot.opacity : 100;
            state.scale = snapshot.scale !== undefined ? snapshot.scale : 100;
            state.offsetX = snapshot.offsetX !== undefined ? snapshot.offsetX : 0;
            state.offsetY = snapshot.offsetY !== undefined ? snapshot.offsetY : 0;
            state.fillColor = snapshot.fillColor;
            state.strokeColor = snapshot.strokeColor;
            state.strokeWidth = snapshot.strokeWidth;
            state.bgEnabled = snapshot.bgEnabled;
            state.bgColor = snapshot.bgColor;
            // Support both new bgEdges and old bgShape format
            if (snapshot.bgEdges !== undefined) {
                state.bgEdges = snapshot.bgEdges;
            } else if (snapshot.bgShape !== undefined) {
                state.bgEdges = snapshot.bgShape === 'circle' ? 0 : 4;
            }
            state.iconPadding = snapshot.iconPadding;
            state.cornerRadius = snapshot.cornerRadius;

            // Restore svgItems if present in snapshot
            if (snapshot.svgItems) {
                state.svgItems = snapshot.svgItems.map(item => ({
                    filename: item.filename,
                    originalSVG: item.originalSVG,
                    currentSVG: item.currentSVG.cloneNode(true)
                }));
            }

            // Update UI to reflect restored state
            updateUIFromState();
            updateSaveButton();
            updateSizeInfo();
            renderPreview();

            // Show empty state if no SVGs remain
            if (!hasLoadedSVGs()) {
                showEmptyState();
            }
        }

        /**
         * Update all UI controls to reflect current state
         */
        function updateUIFromState() {
            // Rotation
            document.getElementById('rotation-value').textContent = state.rotation + '';

            // Adjustments
            document.getElementById('opacity-slider').value = state.opacity;
            document.getElementById('opacity-value').textContent = state.opacity + '%';
            document.getElementById('scale-slider').value = state.scale;
            document.getElementById('scale-value').textContent = state.scale + '%';
            document.getElementById('offset-x-slider').value = state.offsetX;
            document.getElementById('offset-x-value').textContent = state.offsetX;
            document.getElementById('offset-y-slider').value = state.offsetY;
            document.getElementById('offset-y-value').textContent = state.offsetY;

            // Fill color
            document.getElementById('fill-color').value = state.fillColor;
            document.getElementById('fill-hex').value = state.fillColor;
            document.getElementById('fill-color').parentElement.style.background = state.fillColor;

            // Stroke color
            document.getElementById('stroke-color').value = state.strokeColor;
            document.getElementById('stroke-hex').value = state.strokeColor;
            document.getElementById('stroke-color').parentElement.style.background = state.strokeColor;

            // Stroke width
            document.getElementById('stroke-width').value = state.strokeWidth;
            document.getElementById('stroke-value').textContent = state.strokeWidth;

            // Background
            document.getElementById('bg-enabled').checked = state.bgEnabled;
            document.getElementById('bg-options').classList.toggle('visible', state.bgEnabled);
            document.getElementById('bg-color').value = state.bgColor;
            document.getElementById('bg-hex').value = state.bgColor;
            document.getElementById('bg-color-preview').style.background = state.bgColor;

            // Padding and corner radius
            document.getElementById('icon-padding').value = state.iconPadding;
            document.getElementById('padding-value').textContent = state.iconPadding + '%';
            document.getElementById('corner-radius').value = state.cornerRadius;
            document.getElementById('radius-value').textContent = state.cornerRadius + '%';

            // Background edges
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === 'shape-edges-' + state.bgEdges);
            });
            document.getElementById('edges-value').textContent = state.bgEdges;
            document.getElementById('edges-label').textContent = getEdgesLabel(state.bgEdges);
            document.getElementById('corner-radius-control').style.display =
                (state.bgEdges === 0) ? 'none' : 'block';

            // Update FM target visibility
            updateFMTargetVisibility();
        }

        /**
         * Push current state to undo stack (call before making a change)
         */
        function pushToHistory() {
            const snapshot = getStateSnapshot();
            history.undoStack.push(snapshot);

            // Limit history size
            if (history.undoStack.length > history.maxSize) {
                history.undoStack.shift();
            }

            // Clear redo stack when new action is performed
            history.redoStack = [];

            updateHistoryButtons();
        }

        /**
         * Undo the last action
         */
        function undo() {
            if (history.undoStack.length === 0) return;

            // Save current state to redo stack
            history.redoStack.push(getStateSnapshot());

            // Pop and apply the previous state
            const previousState = history.undoStack.pop();
            applyStateSnapshot(previousState);

            updateHistoryButtons();
        }

        /**
         * Redo the last undone action
         */
        function redo() {
            if (history.redoStack.length === 0) return;

            // Save current state to undo stack
            history.undoStack.push(getStateSnapshot());

            // Pop and apply the redo state
            const redoState = history.redoStack.pop();
            applyStateSnapshot(redoState);

            updateHistoryButtons();
        }

        /**
         * Update the enabled/disabled state of undo/redo buttons
         */
        function updateHistoryButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');

            if (undoBtn) {
                undoBtn.disabled = history.undoStack.length === 0;
            }
            if (redoBtn) {
                redoBtn.disabled = history.redoStack.length === 0;
            }
        }

        /**
         * Clear all history
         */
        function clearHistory() {
            history.undoStack = [];
            history.redoStack = [];
            updateHistoryButtons();
        }

        /**
         * Check if there are changes that can be undone
         */
        function hasUndoableChanges() {
            return history.undoStack.length > 0;
        }

        // ============================================
        // Confirmation Modal
        // ============================================
        let modalConfirmCallback = null;

        /**
         * Show the confirmation modal
         * @param {Object} options - Modal configuration
         * @param {string} options.title - Modal title
         * @param {string} options.message - Modal message
         * @param {string} options.confirmText - Text for confirm button
         * @param {Function} options.onConfirm - Callback when confirmed
         */
        function showConfirmModal(options) {
            const modal = document.getElementById('confirm-modal');
            const titleEl = document.getElementById('modal-title');
            const messageEl = document.getElementById('modal-message');
            const confirmBtn = document.getElementById('modal-confirm-btn');
            const iconEl = document.getElementById('modal-icon');

            titleEl.textContent = options.title || 'Confirm';
            messageEl.textContent = options.message || 'Are you sure?';
            confirmBtn.textContent = options.confirmText || 'Confirm';
            modalConfirmCallback = options.onConfirm || null;

            if (options.icon) {
                iconEl.innerHTML = options.icon;
            } else {
                iconEl.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /></svg>';
            }

            document.getElementById('modal-cancel-btn').style.display = options.hideCancel ? 'none' : '';

            modal.classList.add('visible');

            // Close on escape key
            document.addEventListener('keydown', handleModalEscape);

            // Close on overlay click
            modal.addEventListener('click', handleModalOverlayClick);
        }

        /**
         * Hide the confirmation modal
         */
        function hideConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            modal.classList.remove('visible');
            modalConfirmCallback = null;

            document.removeEventListener('keydown', handleModalEscape);
            modal.removeEventListener('click', handleModalOverlayClick);
        }

        /**
         * Handle confirm button click
         */
        function confirmModalAction() {
            if (modalConfirmCallback) {
                modalConfirmCallback();
            }
            hideConfirmModal();
        }

        /**
         * Handle escape key to close modal
         */
        function handleModalEscape(e) {
            if (e.key === 'Escape') {
                hideConfirmModal();
            }
        }

        /**
         * Handle click on overlay (outside card) to close modal
         */
        function handleModalOverlayClick(e) {
            if (e.target.id === 'confirm-modal') {
                hideConfirmModal();
            }
        }

        // ============================================
        // Issue Report Modal
        // ============================================

        function showIssueReport() {
            const modal = document.getElementById('issue-report-modal');
            // Clear previous inputs
            document.getElementById('issue-report-email').value = '';
            document.getElementById('issue-report-details').value = '';
            modal.classList.add('visible');
            setTimeout(() => document.getElementById('issue-report-email').focus(), 200);

            document.addEventListener('keydown', handleIssueReportEscape);
            modal.addEventListener('click', handleIssueReportOverlayClick);
        }

        function hideIssueReport() {
            const modal = document.getElementById('issue-report-modal');
            modal.classList.remove('visible');
            document.removeEventListener('keydown', handleIssueReportEscape);
            modal.removeEventListener('click', handleIssueReportOverlayClick);
        }

        function handleIssueReportEscape(e) {
            if (e.key === 'Escape') {
                hideIssueReport();
            }
        }

        function handleIssueReportOverlayClick(e) {
            if (e.target.id === 'issue-report-modal') {
                hideIssueReport();
            }
        }

        /**
         * Build the diagnostic payload with all relevant info
         */
        function buildIssueReportPayload() {
            const serializer = new XMLSerializer();
            const svgs = state.svgItems.map(item => {
                // Generate the processed output the same way saveSVGFormat does
                let processedSVG = null;
                try {
                    const finalSVG = generateFinalSVG(item);
                    if (finalSVG) {
                        if (state.fmCompatible) {
                            processedSVG = serializer.serializeToString(processSVGForFileMaker(finalSVG));
                        } else {
                            processedSVG = serializer.serializeToString(finalSVG);
                        }
                    }
                } catch (e) {
                    processedSVG = '(error generating output: ' + e.message + ')';
                }

                return {
                    filename: item.filename,
                    original: item.originalSVG,
                    processed: processedSVG
                };
            });

            // Snapshot editor settings (exclude non-serializable stuff)
            const editorState = {
                rotation: state.rotation,
                rotationIncrement: state.rotationIncrement,
                flipH: state.flipH,
                flipV: state.flipV,
                opacity: state.opacity,
                scale: state.scale,
                offsetX: state.offsetX,
                offsetY: state.offsetY,
                fillColor: state.fillColor,
                strokeColor: state.strokeColor,
                strokeWidth: state.strokeWidth,
                bgEnabled: state.bgEnabled,
                bgColor: state.bgColor,
                bgEdges: state.bgEdges,
                iconPadding: state.iconPadding,
                cornerRadius: state.cornerRadius,
                fmCompatible: state.fmCompatible,
                fmDynamicFill: state.fmDynamicFill,
                fmDynamicTarget: state.fmDynamicTarget,
                normalizePaths: state.normalizePaths,
                fileMakerMode: state.fileMakerMode,
                outputFormat: state.outputFormat,
                outputSize: state.outputSize,
                hasStrokeSVGs: state.hasStrokeSVGs,
                convertStrokesToFills: state.convertStrokesToFills
            };

            // Environment info (same as usage tracking payload)
            const ua = navigator.userAgent;
            let browserName = 'Unknown', browserVersion = '';
            if (ua.match(/edg\//i)) { browserName = 'Edge'; browserVersion = (ua.match(/edg\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/opr\//i) || ua.match(/opera/i)) { browserName = 'Opera'; browserVersion = (ua.match(/(?:opr|opera)\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/chrome/i) && !ua.match(/edg/i)) { browserName = 'Chrome'; browserVersion = (ua.match(/chrome\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/safari/i) && !ua.match(/chrome/i)) { browserName = 'Safari'; browserVersion = (ua.match(/version\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/firefox/i)) { browserName = 'Firefox'; browserVersion = (ua.match(/firefox\/([\d.]+)/i) || [])[1]; }

            return {
                timestamp: new Date().toISOString(),
                email: document.getElementById('issue-report-email').value.trim() || null,
                description: document.getElementById('issue-report-details').value.trim() || null,
                svgCount: svgs.length,
                svgs: svgs,
                editorState: editorState,
                userAgent: ua,
                browser: browserName + (browserVersion ? ' ' + browserVersion : ''),
                platform: navigator.platform || '',
                language: navigator.language || '',
                screenWidth: screen.width,
                screenHeight: screen.height,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || '',
                referrer: document.referrer || '',
                colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light',
                touchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
                connectionType: (navigator.connection && navigator.connection.effectiveType) || ''
            };
        }

        const ISSUE_REPORT_WEBHOOK = _proxyBase + '/report';

        async function submitIssueReport() {
            const description = document.getElementById('issue-report-details').value.trim();
            if (!description) {
                document.getElementById('issue-report-details').focus();
                document.getElementById('issue-report-details').style.borderColor = 'var(--accent)';
                setTimeout(() => {
                    document.getElementById('issue-report-details').style.borderColor = '';
                }, 2000);
                return;
            }

            const submitBtn = document.getElementById('issue-report-submit-btn');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';

            const payload = buildIssueReportPayload();

            // Try to include public IP (best-effort, don't block on failure)
            try {
                const ipResp = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipResp.json();
                payload.ip = ipData.ip;
            } catch (e) { payload.ip = ''; }

            try {
                const response = await fetch(ISSUE_REPORT_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                hideIssueReport();

                if (response.ok) {
                    showConfirmModal({
                        title: 'Report Submitted',
                        message: 'Thank you! Your issue has been sent to me for further investigation.' +
                            (payload.email ? ' I\'ll contact you at ' + payload.email + ' when a fix is available.' : '') +
                            '\n\n- Daniel (FM Weetbicks)',
                        confirmText: 'OK',
                        hideCancel: true,
                        icon: '<svg viewBox="0 0 24 24" fill="#4ade80" stroke="none"><path d="M14 9V5.5A2.5 2.5 0 0 0 11.5 3c-.55 0-1.05.22-1.41.59L4 10v11h14.28a2 2 0 0 0 1.97-1.67l1.23-7A2 2 0 0 0 19.52 10H14zM4 10H2v11h2V10z"/></svg>',
                        onConfirm: () => { }
                    });
                } else {
                    showConfirmModal({
                        title: 'Submission Failed',
                        message: 'The report could not be sent (server returned ' + response.status + '). Please try again later.',
                        confirmText: 'OK',
                        hideCancel: true,
                        onConfirm: () => { }
                    });
                }
            } catch (e) {
                hideIssueReport();
                showConfirmModal({
                    title: 'Submission Failed',
                    message: 'Could not connect to the server. Please check your internet connection and try again.',
                    confirmText: 'OK',
                    hideCancel: true,
                    onConfirm: () => { }
                });
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        // Temporary storage for slider state before drag
        let sliderStateBeforeDrag = null;

        /**
         * Save state before slider drag starts
         * Called on mousedown/touchstart of sliders
         */
        function saveSliderState() {
            if (!sliderStateBeforeDrag) sliderStateBeforeDrag = getStateSnapshot();
        }

        /**
         * Commit slider state to history if it changed
         * Called by slider update functions with commit=true
         */
        function commitSliderState() {
            if (sliderStateBeforeDrag) {
                // Push the saved state before drag to history
                history.undoStack.push(sliderStateBeforeDrag);
                if (history.undoStack.length > history.maxSize) {
                    history.undoStack.shift();
                }
                history.redoStack = [];
                updateHistoryButtons();
                sliderStateBeforeDrag = null;
            }
        }

        // ============================================
        // Initialization
        // ============================================

        /**
         * Initialize the SVG Editor
         * @param {Object} config - Configuration object
         * @param {string} config.style - 'dark' or 'light' theme (defaults to OS preference)
         * @param {string} config.style_colour - Accent color: 'red', 'blue', 'green', 'purple', 'pink', 'orange' (defaults to 'orange')
         * @param {string} config.output_mode - 'fm' for FileMaker or 'browser' for local download (defaults to 'browser')
         * @param {string} config.output_format - 'svg' or 'png' (defaults to 'svg')
         * @param {number} config.output_size - Size for PNG export, e.g. 512 for 512x512 (defaults to 512)
         */
        function initEditor(config = {}) {
            const alreadyInitialized = state.initialized;

            // Parse config if it's a string (JSON)
            let cfg = config;
            if (typeof config === 'string') {
                try {
                    cfg = JSON.parse(config);
                } catch (e) {
                    console.warn('Invalid config JSON, using defaults');
                    cfg = {};
                }
            }

            // Set output mode - default to browser mode
            state.fileMakerMode = (cfg.output_mode === 'fm');

            // Set output format - default to 'svg'
            if (cfg.output_format === 'png') {
                state.outputFormat = 'png';
            } else {
                state.outputFormat = 'svg';
            }

            // Set output size for PNG - default to 512
            const validSizes = [32, 64, 128, 256, 512, 1024];
            if (cfg.output_size && validSizes.includes(cfg.output_size)) {
                state.outputSize = cfg.output_size;
            } else {
                state.outputSize = 512;
            }

            // Load saved preferences (localStorage) - used as fallback when config doesn't specify
            const savedPrefs = loadPreferences();

            // Set theme - config > saved prefs > OS preference
            let validTheme;
            if (cfg.style === 'light' || cfg.style === 'dark') {
                validTheme = cfg.style;
            } else if (savedPrefs && (savedPrefs.theme === 'light' || savedPrefs.theme === 'dark')) {
                validTheme = savedPrefs.theme;
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                validTheme = prefersDark ? 'dark' : 'light';
            }
            state.theme = validTheme;
            document.body.setAttribute('data-theme', validTheme);

            // Set accent color - config > saved prefs > default orange
            const validAccents = ['red', 'blue', 'green', 'purple', 'pink', 'orange'];
            let accentColor;
            if (validAccents.includes(cfg.style_colour)) {
                accentColor = cfg.style_colour;
            } else if (savedPrefs && validAccents.includes(savedPrefs.accentColor)) {
                accentColor = savedPrefs.accentColor;
            } else {
                accentColor = 'orange';
            }
            state.accentColor = accentColor;
            if (accentColor !== 'orange') {
                document.body.setAttribute('data-accent', accentColor);
            }
            // Update swatch UI
            document.querySelectorAll('.accent-swatch').forEach(swatch => {
                swatch.classList.toggle('active', swatch.dataset.color === accentColor);
            });

            // Restore other saved preferences (only on first init, don't override config)
            if (!alreadyInitialized && savedPrefs) {
                if (savedPrefs.fmCompatible !== undefined) {
                    state.fmCompatible = savedPrefs.fmCompatible;
                    const fmCheckbox = document.getElementById('fm-compat');
                    if (fmCheckbox) fmCheckbox.checked = state.fmCompatible;
                }
                if (savedPrefs.fmDynamicFill !== undefined) {
                    state.fmDynamicFill = savedPrefs.fmDynamicFill;
                    const dynCheckbox = document.getElementById('fm-dynamic');
                    if (dynCheckbox) dynCheckbox.checked = state.fmDynamicFill;
                }
                if (savedPrefs.previewBg) {
                    state.previewBg = savedPrefs.previewBg;
                }
                if (savedPrefs.previewBgCustomColor) {
                    state.previewBgCustomColor = savedPrefs.previewBgCustomColor;
                }
            }

            // One-time setup (only on first init)
            if (!alreadyInitialized) {
                // Show the editor
                const container = document.getElementById('editor-container');
                container.classList.add('initialized');

                // Setup drag and drop
                setupDragAndDrop();

                // Setup message listener
                setupMessageListener();

                // Setup scroll wheel zoom
                setupScrollZoom();

                // Setup scroll wheel rotation
                setupScrollRotation();

                // Setup keyboard shortcuts
                setupKeyboardShortcuts();

                // Setup collapsible sections
                setupCollapsibleSections();

                state.initialized = true;
            }

            // Update UI to reflect current state
            updateFormatUI();
            updateSaveButton();

            // Apply restored preview background
            if (state.previewBg !== 'checkerboard') {
                setPreviewBg(state.previewBg);
            }

            // Hide controls panel initially when no SVGs loaded
            updateControlsPanelVisibility();

            // Restore from issue report if initStateJSON is provided
            if (cfg.initStateJSON) {
                let reportData = cfg.initStateJSON;
                if (typeof reportData === 'string') {
                    try { reportData = JSON.parse(reportData); } catch (e) {
                        console.warn('Invalid initStateJSON, ignoring');
                        reportData = null;
                    }
                }
                if (reportData) {
                    setTimeout(() => restoreFromReport(reportData), 100);
                }
            }

            console.log('SVG Editor', alreadyInitialized ? 'reconfigured' : 'initialized', 'with theme:', validTheme, 'accent:', accentColor, 'output mode:', cfg.output_mode || 'browser', 'format:', state.outputFormat, 'size:', state.outputSize);
        }

        /**
         * Restore the editor to the exact state captured in an issue report.
         * Loads the original SVGs and applies all editor settings + UI.
         * @param {Object} reportData - The issue report payload (or its shape)
         */
        function restoreFromReport(reportData) {
            try {
                // 1. Load the original SVGs
                const svgs = reportData.svgs || [];
                if (svgs.length > 0) {
                    state.svgItems = [];
                    resetState();
                    clearHistory();

                    let loaded = 0;
                    svgs.forEach(entry => {
                        const svgString = entry.original;
                        if (svgString && addSVGItem(entry.filename || 'untitled.svg', svgString)) {
                            loaded++;
                        }
                    });

                    if (loaded === 0) {
                        console.warn('[restoreFromReport] No valid SVGs found in report');
                        return;
                    }
                }

                // 2. Apply editor state
                const es = reportData.editorState;
                if (!es) {
                    renderPreview();
                    updateSizeInfo();
                    updateSaveButton();
                    detectStrokeSVGs();
                    setTimeout(autoZoom, 50);
                    return;
                }

                // Rotation
                if (es.rotation !== undefined) {
                    state.rotation = es.rotation;
                    document.getElementById('rotation-value').textContent = es.rotation + '\u00B0';
                }
                if (es.rotationIncrement !== undefined) {
                    state.rotationIncrement = es.rotationIncrement;
                    document.querySelectorAll('.increment-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.textContent === es.rotationIncrement + '\u00B0');
                    });
                }

                // Flip
                if (es.flipH !== undefined) state.flipH = es.flipH;
                if (es.flipV !== undefined) state.flipV = es.flipV;

                // Opacity
                if (es.opacity !== undefined) {
                    state.opacity = es.opacity;
                    document.getElementById('opacity-slider').value = es.opacity;
                    document.getElementById('opacity-value').textContent = es.opacity + '%';
                }

                // Scale
                if (es.scale !== undefined) {
                    state.scale = es.scale;
                    document.getElementById('scale-slider').value = es.scale;
                    document.getElementById('scale-value').textContent = es.scale + '%';
                }

                // Offsets
                if (es.offsetX !== undefined) {
                    state.offsetX = es.offsetX;
                    document.getElementById('offset-x-slider').value = es.offsetX;
                    document.getElementById('offset-x-value').textContent = es.offsetX;
                }
                if (es.offsetY !== undefined) {
                    state.offsetY = es.offsetY;
                    document.getElementById('offset-y-slider').value = es.offsetY;
                    document.getElementById('offset-y-value').textContent = es.offsetY;
                }

                // Fill color
                if (es.fillColor !== undefined) {
                    state.fillColor = es.fillColor;
                    document.getElementById('fill-color').value = es.fillColor;
                    document.getElementById('fill-hex').value = es.fillColor;
                    document.getElementById('fill-color').parentElement.style.background = es.fillColor;
                }

                // Stroke color & width
                if (es.strokeColor !== undefined) {
                    state.strokeColor = es.strokeColor;
                    document.getElementById('stroke-color').value = es.strokeColor;
                    document.getElementById('stroke-hex').value = es.strokeColor;
                    document.getElementById('stroke-color').parentElement.style.background = es.strokeColor;
                }
                if (es.strokeWidth !== undefined) {
                    state.strokeWidth = es.strokeWidth;
                    document.getElementById('stroke-width').value = es.strokeWidth;
                    document.getElementById('stroke-value').textContent = es.strokeWidth;
                }

                // Background
                if (es.bgEnabled !== undefined) {
                    state.bgEnabled = es.bgEnabled;
                    document.getElementById('bg-enabled').checked = es.bgEnabled;
                    document.getElementById('bg-options').classList.toggle('visible', es.bgEnabled);
                }
                if (es.bgColor !== undefined) {
                    state.bgColor = es.bgColor;
                    document.getElementById('bg-color').value = es.bgColor;
                    document.getElementById('bg-hex').value = es.bgColor;
                    document.getElementById('bg-color-preview').style.background = es.bgColor;
                }
                if (es.bgEdges !== undefined) {
                    state.bgEdges = es.bgEdges;
                    document.querySelectorAll('.shape-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.id === 'shape-edges-' + es.bgEdges);
                    });
                    document.getElementById('edges-value').textContent = es.bgEdges;
                    document.getElementById('edges-label').textContent = getEdgesLabel(es.bgEdges);
                    const radiusControl = document.getElementById('corner-radius-control');
                    radiusControl.style.display = (es.bgEdges === 0) ? 'none' : 'block';
                } else if (es.bgShape !== undefined) {
                    // Backward compat: convert old bgShape string
                    state.bgEdges = es.bgShape === 'circle' ? 0 : 4;
                    document.querySelectorAll('.shape-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.id === 'shape-edges-' + state.bgEdges);
                    });
                    document.getElementById('edges-value').textContent = state.bgEdges;
                    document.getElementById('edges-label').textContent = getEdgesLabel(state.bgEdges);
                    const radiusControl = document.getElementById('corner-radius-control');
                    radiusControl.style.display = (state.bgEdges === 0) ? 'none' : 'block';
                }
                if (es.iconPadding !== undefined) {
                    state.iconPadding = es.iconPadding;
                    document.getElementById('icon-padding').value = es.iconPadding;
                    document.getElementById('padding-value').textContent = es.iconPadding + '%';
                }
                if (es.cornerRadius !== undefined) {
                    state.cornerRadius = es.cornerRadius;
                    document.getElementById('corner-radius').value = es.cornerRadius;
                    document.getElementById('radius-value').textContent = es.cornerRadius + '%';
                }

                // Export settings
                if (es.fmCompatible !== undefined) {
                    state.fmCompatible = es.fmCompatible;
                    const cb = document.getElementById('fm-compat');
                    if (cb) cb.checked = es.fmCompatible;
                }
                if (es.fmDynamicFill !== undefined) {
                    state.fmDynamicFill = es.fmDynamicFill;
                    const cb = document.getElementById('fm-dynamic');
                    if (cb) cb.checked = es.fmDynamicFill;
                }
                if (es.fmDynamicTarget !== undefined) {
                    setFMTarget(es.fmDynamicTarget);
                }
                if (es.normalizePaths !== undefined) {
                    state.normalizePaths = es.normalizePaths;
                }
                if (es.outputFormat !== undefined) {
                    state.outputFormat = es.outputFormat;
                }
                if (es.outputSize !== undefined) {
                    state.outputSize = es.outputSize;
                }
                if (es.convertStrokesToFills !== undefined) {
                    state.convertStrokesToFills = es.convertStrokesToFills;
                    const cb = document.getElementById('convert-strokes');
                    if (cb) cb.checked = es.convertStrokesToFills;
                }

                updateFMTargetVisibility();
                updateFormatUI();
                renderPreview();
                updateSizeInfo();
                updateSaveButton();
                detectStrokeSVGs();
                setTimeout(autoZoom, 50);

                console.log('[restoreFromReport] Editor state restored from issue report');
            } catch (e) {
                console.error('[restoreFromReport] Error restoring state:', e);
            }
        }

        /**
         * Setup drag and drop handlers
         */
        function setupDragAndDrop() {
            const dropZone = document.getElementById('drop-zone');

            // Prevent default drag behaviors on the drop zone only
            // (Do NOT add to document.body - that blocks page scrolling when embedded)
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop zone when dragging over
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            // Handle dropped files
            dropZone.addEventListener('drop', handleDrop, false);
        }

        /**
         * Setup postMessage listener for iframe communication
         */
        function setupMessageListener() {
            window.addEventListener('message', function (event) {
                if (event.data && event.data.type === 'loadSVG') {
                    loadSVG(event.data.data);
                }
            });
        }

        /**
         * Setup scroll wheel zoom on the zoom level display and preview container
         */
        function setupScrollZoom() {
            const zoomLevel = document.getElementById('zoom-level');
            const previewContainer = document.querySelector('.preview-container');

            // Wheel handler for zooming
            function handleWheelZoom(e) {
                e.preventDefault();

                // Determine scroll direction: negative deltaY = scroll up = zoom in
                const delta = e.deltaY < 0 ? 0.1 : -0.1;
                adjustZoom(delta);
            }

            // Add zoom to the zoom level text
            if (zoomLevel) {
                zoomLevel.addEventListener('wheel', handleWheelZoom, { passive: false });
                // Add cursor style to indicate scrollability
                zoomLevel.style.cursor = 'ns-resize';
            }

            // Add zoom to the preview container (only when modifier key held)
            if (previewContainer) {
                previewContainer.addEventListener('wheel', function (e) {
                    // Only zoom when a modifier key is held (Cmd, Ctrl, Shift)
                    if (!(e.metaKey || e.ctrlKey || e.shiftKey)) return;
                    // Only handle zoom if SVGs are loaded
                    if (!hasLoadedSVGs()) return;
                    e.preventDefault();
                    const delta = e.deltaY < 0 ? 0.05 : -0.05;
                    adjustZoom(delta);
                }, { passive: false });
            }
        }

        /**
         * Setup scroll wheel rotation on the rotation value display
         */
        function setupScrollRotation() {
            const rotationValue = document.getElementById('rotation-value');

            if (rotationValue) {
                rotationValue.addEventListener('wheel', function (e) {
                    e.preventDefault();

                    // Only rotate if SVGs are loaded
                    if (!hasLoadedSVGs()) return;

                    pushToHistory();

                    // Scroll up = increase rotation, scroll down = decrease
                    const delta = e.deltaY < 0 ? 1 : -1;

                    // Update rotation with wrapping (0-359)
                    state.rotation = (state.rotation + delta + 360) % 360;
                    document.getElementById('rotation-value').textContent = state.rotation + '';
                    renderPreview();
                }, { passive: false });

                // Add cursor style to indicate scrollability
                rotationValue.style.cursor = 'ns-resize';
            }
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e) {
            document.getElementById('drop-zone').classList.add('drag-over');
        }

        function unhighlight(e) {
            document.getElementById('drop-zone').classList.remove('drag-over');
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                handleDroppedFiles(Array.from(files));
            }
        }

        /**
         * Handle files dropped onto the preview area
         * @param {File[]} files - Array of files to handle
         */
        function handleDroppedFiles(files) {
            // Filter to only SVG files
            const svgFiles = files.filter(file =>
                file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')
            );

            if (svgFiles.length === 0) {
                alert('Please drop SVG files.');
                return;
            }

            // If there are existing SVGs with changes, ask for confirmation
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                pendingFiles = svgFiles;
                showConfirmModal({
                    title: 'Load New SVGs?',
                    message: 'You have unsaved changes to the current SVGs. Loading new files will discard these changes.',
                    confirmText: 'Load New',
                    onConfirm: loadPendingFiles
                });
                return;
            }

            // No existing changes, load directly
            loadFilesAsSVG(svgFiles);
        }

        // Pending files to load after confirmation
        let pendingFiles = null;

        /**
         * Trigger the file input dialog
         * Called by Load button or empty state click
         */
        function triggerFileLoad() {
            document.getElementById('svg-file-input').click();
        }

        /**
         * Handle file selection from the file input
         */
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            // Reset the input so the same files can be selected again
            event.target.value = '';

            // Filter to only SVG files
            const svgFiles = files.filter(file =>
                file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')
            );

            if (svgFiles.length === 0) {
                alert('Please select SVG files.');
                return;
            }

            // If there are existing SVGs with changes, ask for confirmation
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                pendingFiles = svgFiles;
                showConfirmModal({
                    title: 'Load New SVGs?',
                    message: 'You have unsaved changes to the current SVGs. Loading new files will discard these changes.',
                    confirmText: 'Load New',
                    onConfirm: loadPendingFiles
                });
                return;
            }

            // No existing changes, load directly
            loadFilesAsSVG(svgFiles);
        }

        /**
         * Load the pending files after confirmation
         */
        function loadPendingFiles() {
            if (pendingFiles) {
                loadFilesAsSVG(pendingFiles);
                pendingFiles = null;
            }
        }

        /**
         * Read multiple files and load as SVGs
         * @param {File[]} files - Array of SVG files to load
         */
        function loadFilesAsSVG(files) {
            // Clear existing SVGs and reset state
            state.svgItems = [];
            resetState();
            clearHistory();

            let loadedCount = 0;
            const totalFiles = files.length;

            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const svgContent = e.target.result;
                    addSVGItem(file.name, svgContent);
                    loadedCount++;

                    // When all files are loaded, render and auto-zoom
                    if (loadedCount === totalFiles) {
                        renderPreview();
                        updateSizeInfo();
                        updateSaveButton();
                        detectStrokeSVGs();
                        setTimeout(autoZoom, 50);
                    }
                };
                reader.readAsText(file);
            });
        }

        /**
         * Add an SVG item to the state
         * @param {string} filename - Name of the file
         * @param {string} svgString - Raw SVG string
         * @returns {boolean} - Whether the SVG was added successfully
         */
        function addSVGItem(filename, svgString) {
            try {
                // Parse the SVG
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');

                // Check for parsing errors
                const parseError = doc.querySelector('parsererror');
                if (parseError || !svg) {
                    console.error('Invalid SVG data for file:', filename);
                    return false;
                }

                // Add to svgItems array
                state.svgItems.push({
                    filename: filename,
                    originalSVG: svgString,
                    currentSVG: svg.cloneNode(true)
                });

                return true;
            } catch (e) {
                console.error('Error adding SVG item:', filename, e);
                return false;
            }
        }

        /**
         * Check if any SVGs are loaded
         * @returns {boolean}
         */
        function hasLoadedSVGs() {
            return state.svgItems.length > 0;
        }

        /**
         * Clear all loaded SVGs
         */
        function clearAllSVGs() {
            state.svgItems = [];
            state.hasStrokeSVGs = false;
            clearHistory();
            renderPreview();
            showEmptyState();
            updateSaveButton();
            updateSizeInfo();
            updateStrokeConversionUI();
        }

        /**
         * Update the save button text and enabled state based on current mode and loaded SVGs
         */
        function updateSaveButton() {
            const btn = document.getElementById('save-btn');
            const btnText = document.getElementById('save-btn-text');
            if (!btn || !btnText) return;

            const hasItems = hasLoadedSVGs();
            const count = state.svgItems.length;
            const format = state.outputFormat.toUpperCase();

            // Enable/disable based on whether SVGs are loaded
            btn.disabled = !hasItems;

            // Enable/disable copy button alongside save
            const copyBtn = document.getElementById('copy-btn');
            if (copyBtn) {
                copyBtn.disabled = !hasItems;
            }

            // Enable/disable code view button
            const codeViewBtn = document.getElementById('code-view-btn');
            if (codeViewBtn) {
                codeViewBtn.disabled = !hasItems;
            }

            // Update text based on mode, format, and count
            if (state.fileMakerMode) {
                btnText.textContent = 'Save to FileMaker';
            } else if (count > 1) {
                btnText.textContent = `Save ${format}s`;
            } else {
                btnText.textContent = `Save ${format}`;
            }

            // Also update header buttons (Clear/Reset visibility)
            updateHeaderButtons();
        }

        /**
         * Update visibility of Clear and Reset buttons based on loaded SVGs
         */
        function updateHeaderButtons() {
            const clearBtn = document.getElementById('clear-btn');
            const resetBtn = document.getElementById('reset-btn');
            const hasItems = hasLoadedSVGs();

            if (clearBtn) {
                clearBtn.style.display = hasItems ? '' : 'none';
            }
            if (resetBtn) {
                resetBtn.style.display = hasItems ? '' : 'none';
            }
        }

        // ============================================
        // Theme Toggle
        // ============================================

        function toggleTheme() {
            const newTheme = state.theme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }

        function setTheme(theme) {
            const validTheme = (theme === 'light') ? 'light' : 'dark';
            state.theme = validTheme;
            document.body.setAttribute('data-theme', validTheme);
            savePreferences();
        }

        function toggleThemeDropdown(event) {
            event.stopPropagation();
            const container = document.getElementById('theme-container');
            container.classList.toggle('open');
        }

        function setAccentColor(color) {
            const validColors = ['red', 'blue', 'green', 'purple', 'pink', 'orange'];
            if (!validColors.includes(color)) color = 'red';

            state.accentColor = color;

            // Update body attribute for CSS
            if (color === 'orange') {
                document.body.removeAttribute('data-accent');
            } else {
                document.body.setAttribute('data-accent', color);
            }

            // Update swatch active state
            document.querySelectorAll('.accent-swatch').forEach(swatch => {
                swatch.classList.toggle('active', swatch.dataset.color === color);
            });

            // Close dropdown
            document.getElementById('theme-container').classList.remove('open');
            savePreferences();
        }

        // Close theme dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const container = document.getElementById('theme-container');
            if (container && !container.contains(event.target)) {
                container.classList.remove('open');
            }
        });

        // ============================================
        // SVG Loading
        // ============================================

        /**
         * Load SVG directly from string content (used by drag/drop for single files)
         * @param {string} svgString - Raw SVG string
         * @param {string} filename - Optional filename (defaults to 'untitled.svg')
         */
        function loadSVGFromString(svgString, filename = 'untitled.svg') {
            try {
                // Clear existing SVGs
                state.svgItems = [];

                // Reset state and clear history (new SVG = fresh start)
                resetState();
                clearHistory();

                // Add the SVG item
                if (!addSVGItem(filename, svgString)) {
                    throw new Error('Invalid SVG data');
                }

                // Render preview
                renderPreview();
                updateSizeInfo();
                updateSaveButton();
                detectStrokeSVGs();

                // Auto-zoom to fit nicely in preview (after a short delay to let DOM update)
                setTimeout(autoZoom, 50);

                return true;
            } catch (e) {
                console.error('Error loading SVG:', e);
                alert('Failed to load SVG: ' + e.message);
                return false;
            }
        }

        /**
         * Load SVG(s) from base64 encoded string or JSON array
         * Call this function from FileMaker to load SVG(s)
         * @param {string} input - Base64 encoded SVG data OR JSON array string '[{filename, base64}, ...]'
         */
        function loadSVG(input) {
            try {
                // Check if input is JSON array (starts with '[' or '{')
                const trimmed = input.trim();
                if (trimmed.startsWith('[') || trimmed.startsWith('{')) {
                    return loadSVGItems(trimmed);
                }

                // Legacy single base64 string support
                const svgString = atob(input);
                return loadSVGFromString(svgString, 'untitled.svg');
            } catch (e) {
                console.error('Error loading SVG:', e);
                alert('Failed to load SVG: ' + e.message);
                return false;
            }
        }

        /**
         * Load multiple SVGs from JSON array
         * @param {string} jsonString - JSON array string '[{filename, base64}, ...]'
         */
        function loadSVGItems(jsonString) {
            try {
                let items = JSON.parse(jsonString);

                // Handle single object wrapped or not
                if (!Array.isArray(items)) {
                    items = [items];
                }

                // Clear existing SVGs
                state.svgItems = [];
                resetState();
                clearHistory();

                // Load each item
                let successCount = 0;
                items.forEach(item => {
                    try {
                        const svgString = atob(item.base64);
                        if (addSVGItem(item.filename || 'untitled.svg', svgString)) {
                            successCount++;
                        }
                    } catch (e) {
                        console.error('Error loading SVG item:', item.filename, e);
                    }
                });

                if (successCount === 0) {
                    throw new Error('No valid SVGs found in input');
                }

                // Render preview
                renderPreview();
                updateSizeInfo();
                updateSaveButton();
                detectStrokeSVGs();
                setTimeout(autoZoom, 50);

                return true;
            } catch (e) {
                console.error('Error loading SVG items:', e);
                alert('Failed to load SVGs: ' + e.message);
                return false;
            }
        }

        /**
         * Save all SVGs - either to FileMaker or download locally based on mode
         * Returns JSON array of {filename, base64} objects
         */
        async function saveSVG() {
            if (!hasLoadedSVGs()) {
                return null;
            }

            const btn = document.getElementById('save-btn');
            const btnText = document.getElementById('save-btn-text');
            const originalText = btnText ? btnText.textContent : '';

            try {
                // Show loading state if we're converting strokes
                const willConvert = state.outputFormat === 'svg' && state.hasStrokeSVGs && state.convertStrokesToFills;
                if (willConvert && btn && btnText) {
                    btn.disabled = true;
                    btnText.textContent = 'Converting...';
                }

                if (state.outputFormat === 'png') {
                    // PNG export
                    return await savePNG();
                } else {
                    // SVG export
                    return await saveSVGFormat();
                }
            } catch (e) {
                console.error('Error saving:', e);
                alert('Failed to save: ' + e.message);
                return null;
            } finally {
                // Restore button state
                if (btn && btnText) {
                    btn.disabled = false;
                    btnText.textContent = originalText;
                }
            }
        }

        /**
         * Save as SVG format
         */
        async function saveSVGFormat() {
            const results = [];
            const conversionErrors = [];
            const processingLog = [];  // Track what happens to each SVG

            for (let itemIndex = 0; itemIndex < state.svgItems.length; itemIndex++) {
                const item = state.svgItems[itemIndex];
                const logEntry = { filename: item.filename, steps: [] };

                // Apply stroke-to-fill conversion BEFORE generating final SVG
                // This must happen first so the background rect doesn't interfere
                // with Potrace tracing (a black bg rect would dominate the trace)
                const serializer = new XMLSerializer();
                let savedCurrentSVG = null;
                if (needsStrokeConversion(item)) {
                    logEntry.steps.push('stroke conversion starting (on raw icon)');
                    const rawSvgString = serializer.serializeToString(item.currentSVG);
                    const conversionResult = await convertStrokeToFill(rawSvgString);
                    if (conversionResult.success) {
                        logEntry.steps.push('stroke conversion succeeded');
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(conversionResult.svg, 'image/svg+xml');
                        const convertedSvg = doc.querySelector('svg');
                        if (convertedSvg) {
                            // Temporarily swap in the converted SVG for generateFinalSVG
                            savedCurrentSVG = item.currentSVG;
                            item.currentSVG = convertedSvg;
                        }
                    } else {
                        conversionErrors.push({
                            filename: item.filename,
                            error: conversionResult.error
                        });
                        logEntry.steps.push('stroke conversion failed: ' + conversionResult.error);
                        console.warn('Stroke conversion failed for', item.filename, ':', conversionResult.error);
                    }
                }

                // Generate the final SVG for this item (adds background, transforms, etc.)
                let finalSVG = generateFinalSVG(item);
                logEntry.steps.push('generateFinalSVG complete');

                // Restore original currentSVG if we swapped it for conversion
                if (savedCurrentSVG) {
                    item.currentSVG = savedCurrentSVG;
                }

                let svgString = serializer.serializeToString(finalSVG);

                // Apply FileMaker compatibility processing if enabled
                // This runs in both FileMaker and browser mode when the checkbox is checked
                if (state.fmCompatible) {
                    logEntry.steps.push('processSVGForFileMaker starting');
                    finalSVG = processSVGForFileMaker(finalSVG);
                    logEntry.steps.push('processSVGForFileMaker complete');
                    // Re-serialize after FM processing
                    svgString = serializer.serializeToString(finalSVG);
                    logEntry.steps.push('re-serialized');

                    // Check if paths were normalized (should have uppercase commands)
                    const hasLowercaseCommands = /\s[a-z]\s*[\d-]/.test(svgString) || /^[a-z][\d-]/.test(svgString.match(/d="([^"]+)"/)?.[1] || '');
                    if (hasLowercaseCommands) {
                        logEntry.steps.push('WARNING: paths still have lowercase commands (not normalized)');
                        console.warn(`[${item.filename}] Path normalization may have failed - lowercase commands detected`);
                    } else {
                        logEntry.steps.push('paths normalized successfully');
                    }
                }

                // Encode to base64
                const base64 = btoa(unescape(encodeURIComponent(svgString)));

                processingLog.push(logEntry);

                results.push({
                    filename: item.filename,
                    base64: base64,
                    svgString: svgString
                });
            }

            // Log processing summary
            console.log('=== SVG Processing Summary ===');
            processingLog.forEach((entry, i) => {
                console.log(`[${i + 1}] ${entry.filename}: ${entry.steps.join(' -> ')}`);
            });

            // Show warning if any conversions failed
            if (conversionErrors.length > 0) {
                const errorMsg = conversionErrors.length === 1
                    ? `Stroke conversion failed for ${conversionErrors[0].filename}: ${conversionErrors[0].error}`
                    : `Stroke conversion failed for ${conversionErrors.length} files. The original stroked SVGs were saved instead.\n\nTip: Use the online converter at outline-stroke.vercel.app and re-import the converted SVGs.`;
                alert(errorMsg);
            }

            if (state.fileMakerMode) {
                // FileMaker mode - send to FileMaker
                const jsonOutput = JSON.stringify(results.map(r => ({
                    filename: r.filename,
                    base64: r.base64
                })));
                callFileMaker('SaveSVG', jsonOutput);
                return jsonOutput;
            } else {
                // Local mode - download files
                downloadFiles(results, 'svg');
                return JSON.stringify(results.map(r => ({
                    filename: r.filename,
                    base64: r.base64
                })));
            }
        }

        /**
         * Save as PNG format
         */
        async function savePNG() {
            const size = state.outputSize;
            const results = [];

            for (const item of state.svgItems) {
                // Generate the final SVG for this item
                const finalSVG = generateFinalSVG(item);

                // Convert to PNG
                const base64 = await svgToPng(finalSVG, size);

                results.push({
                    filename: item.filename,
                    base64: base64
                });
            }

            if (state.fileMakerMode) {
                // FileMaker mode - send to FileMaker
                const jsonOutput = JSON.stringify(results.map(r => ({
                    filename: r.filename.replace(/\.svg$/i, '.png'),
                    base64: r.base64
                })));
                callFileMaker('SavePNG', jsonOutput);
                return jsonOutput;
            } else {
                // Local mode - download files
                downloadFiles(results, 'png');
                return JSON.stringify(results.map(r => ({
                    filename: r.filename.replace(/\.svg$/i, '.png'),
                    base64: r.base64
                })));
            }
        }

        /**
         * Download SVG files to the user's computer
         * @param {Array} items - Array of {filename, svgString} objects
         */
        /**
         * Download files to the user's computer
         * @param {Array} items - Array of {filename, base64, svgString?} objects
         * @param {string} format - 'svg' or 'png'
         */
        function downloadFiles(items, format) {
            items.forEach((item, index) => {
                // Generate modified filename
                const filename = item.filename;
                const dotIndex = filename.lastIndexOf('.');
                const baseName = dotIndex > 0 ? filename.substring(0, dotIndex) : filename;
                const newExtension = format === 'png' ? '.png' : '.svg';
                const modifiedFilename = baseName + '_modified' + newExtension;

                let blob;
                if (format === 'png') {
                    // Convert base64 to blob for PNG
                    const byteCharacters = atob(item.base64);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    blob = new Blob([byteArray], { type: 'image/png' });
                } else {
                    // SVG - use the string directly
                    blob = new Blob([item.svgString], { type: 'image/svg+xml' });
                }

                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = modifiedFilename;

                // Prevent parent page (e.g., Squarespace) from intercepting the click
                link.style.display = 'none';
                link.addEventListener('click', function (e) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }, true);

                // Stagger downloads slightly to avoid browser blocking multiple downloads
                setTimeout(() => {
                    document.body.appendChild(link);
                    // Use a non-bubbling click to avoid SPA router interception
                    const clickEvent = new MouseEvent('click', {
                        bubbles: false,
                        cancelable: true,
                        view: window
                    });
                    link.dispatchEvent(clickEvent);
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, index * 200);
            });
        }

        // Keep old function name for backwards compatibility
        function downloadSVGs(items) {
            downloadFiles(items, 'svg');
        }

        /**
         * Call a FileMaker script with a parameter
         * @param {string} scriptName - Name of the FileMaker script to call
         * @param {string} parameter - Parameter to pass to the script
         */
        function callFileMaker(scriptName, parameter) {
            // FileMaker Web Viewer script call
            if (typeof FileMaker !== 'undefined' && FileMaker.PerformScript) {
                FileMaker.PerformScript(scriptName, parameter);
            } else {
                // For testing outside FileMaker - use postMessage
                console.log('FileMaker.PerformScript("' + scriptName + '", "' + parameter.substring(0, 100) + '...")');
                console.log('Full base64 output:', parameter);

                // Send to parent window via postMessage (for test page)
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'FileMakerScript',
                        scriptName: scriptName,
                        parameter: parameter
                    }, '*');
                }
            }
        }

        // ============================================
        // SVG Transformations
        // ============================================

        function flipHorizontal() {
            pushToHistory();
            state.flipH = !state.flipH;
            renderPreview();
        }

        function flipVertical() {
            pushToHistory();
            state.flipV = !state.flipV;
            renderPreview();
        }

        function rotate(direction) {
            pushToHistory();
            state.rotation = (state.rotation + direction * state.rotationIncrement + 360) % 360;
            document.getElementById('rotation-value').textContent = state.rotation + '';
            renderPreview();
        }

        function setIncrement(value) {
            state.rotationIncrement = value;
            document.querySelectorAll('.increment-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent === value + '');
            });
        }

        function updateFillColor(color, commit = false) {
            if (!isValidColor(color)) return;
            if (commit) { if (sliderStateBeforeDrag) commitSliderState(); else pushToHistory(); }
            else if (!sliderStateBeforeDrag) pushToHistory();
            state.fillColor = color;
            document.getElementById('fill-color').value = color;
            document.getElementById('fill-hex').value = color;
            document.getElementById('fill-color').parentElement.style.background = color;
            colorPickerPopup.syncFromHex(color);
            renderPreview();
        }

        function updateStrokeColor(color, commit = false) {
            if (!isValidColor(color)) return;
            if (commit) { if (sliderStateBeforeDrag) commitSliderState(); else pushToHistory(); }
            else if (!sliderStateBeforeDrag) pushToHistory();
            state.strokeColor = color;
            document.getElementById('stroke-color').value = color;
            document.getElementById('stroke-hex').value = color;
            document.getElementById('stroke-color').parentElement.style.background = color;
            colorPickerPopup.syncFromHex(color);
            renderPreview();
        }

        function updateStrokeWidth(value, commit = false) {
            if (commit) commitSliderState();
            state.strokeWidth = parseFloat(value);
            document.getElementById('stroke-value').textContent = value;
            renderPreview();
        }

        // ============================================
        // Adjustment Functions
        // ============================================

        function updateOpacity(value, commit = false) {
            if (commit) commitSliderState();
            state.opacity = parseInt(value);
            document.getElementById('opacity-value').textContent = value + '%';
            renderPreview();
        }

        function updateScale(value, commit = false) {
            if (commit) commitSliderState();
            state.scale = parseInt(value);
            document.getElementById('scale-value').textContent = value + '%';
            renderPreview();
        }

        function updateOffsetX(value, commit = false) {
            if (commit) commitSliderState();
            state.offsetX = parseInt(value);
            document.getElementById('offset-x-value').textContent = value;
            renderPreview();
        }

        function updateOffsetY(value, commit = false) {
            if (commit) commitSliderState();
            state.offsetY = parseInt(value);
            document.getElementById('offset-y-value').textContent = value;
            renderPreview();
        }

        function invertColors() {
            pushToHistory();

            // Helper to invert a color
            function invertColor(color) {
                const c = color.toLowerCase();
                if (c === '#000000' || c === '#000' || c === 'black') {
                    return '#ffffff';
                } else if (c === '#ffffff' || c === '#fff' || c === 'white') {
                    return '#000000';
                } else {
                    // For other colors, invert the RGB values
                    const hex = color.replace('#', '');
                    const r = 255 - parseInt(hex.substr(0, 2), 16);
                    const g = 255 - parseInt(hex.substr(2, 2), 16);
                    const b = 255 - parseInt(hex.substr(4, 2), 16);
                    return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
                }
            }

            // Invert both fill and stroke colors (for mixed SVGs with both fill and stroke elements)
            state.fillColor = invertColor(state.fillColor);
            state.strokeColor = invertColor(state.strokeColor);

            // Update fill UI
            document.getElementById('fill-color').value = state.fillColor;
            document.getElementById('fill-hex').value = state.fillColor;
            document.getElementById('fill-color').parentElement.style.background = state.fillColor;

            // Update stroke UI
            document.getElementById('stroke-color').value = state.strokeColor;
            document.getElementById('stroke-hex').value = state.strokeColor;
            document.getElementById('stroke-color').parentElement.style.background = state.strokeColor;

            renderPreview();
        }

        function resetAdjustments() {
            pushToHistory();
            state.opacity = 100;
            state.scale = 100;
            state.offsetX = 0;
            state.offsetY = 0;
            // Update UI
            document.getElementById('opacity-slider').value = 100;
            document.getElementById('opacity-value').textContent = '100%';
            document.getElementById('scale-slider').value = 100;
            document.getElementById('scale-value').textContent = '100%';
            document.getElementById('offset-x-slider').value = 0;
            document.getElementById('offset-x-value').textContent = '0';
            document.getElementById('offset-y-slider').value = 0;
            document.getElementById('offset-y-value').textContent = '0';
            renderPreview();
        }

        function toggleBackground(enabled) {
            pushToHistory();
            state.bgEnabled = enabled;
            document.getElementById('bg-options').classList.toggle('visible', enabled);
            updateFMTargetVisibility();
            renderPreview();
        }

        function updateBgColor(color, commit = false) {
            if (!isValidColor(color)) return;
            if (commit) { if (sliderStateBeforeDrag) commitSliderState(); else pushToHistory(); }
            else if (!sliderStateBeforeDrag) pushToHistory();
            state.bgColor = color;
            document.getElementById('bg-color').value = color;
            document.getElementById('bg-hex').value = color;
            document.getElementById('bg-color-preview').style.background = color;
            colorPickerPopup.syncFromHex(color);
            renderPreview();
        }

        function getEdgesLabel(n) {
            const names = { 0: 'Circle', 3: 'Triangle', 4: 'Square', 5: 'Pentagon', 6: 'Hexagon', 7: 'Heptagon', 8: 'Octagon', 9: 'Nonagon', 10: 'Decagon' };
            return names[n] || (n + '-gon');
        }

        function setBgEdges(n) {
            n = parseInt(n);
            if (isNaN(n) || n < 0) n = 0;
            if (n === 1 || n === 2) n = 3;
            pushToHistory();
            state.bgEdges = n;
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === 'shape-edges-' + n);
            });
            document.getElementById('edges-value').textContent = n;
            document.getElementById('edges-label').textContent = getEdgesLabel(n);
            document.getElementById('corner-radius-control').style.display = (n === 0) ? 'none' : 'block';
            renderPreview();
        }

        function adjustBgEdges(delta) {
            let n = state.bgEdges + delta;
            // Smart skip: 0 (circle) <-> 3 (triangle), skip 1 and 2
            if (delta > 0 && state.bgEdges === 0) n = 3;
            if (delta < 0 && state.bgEdges === 3) n = 0;
            if (n < 0) n = 0;
            setBgEdges(n);
        }

        function generatePolygonPath(cx, cy, radius, edges, cornerRadius) {
            // Calculate vertices evenly spaced, starting at top (-PI/2)
            const vertices = [];
            for (let i = 0; i < edges; i++) {
                const angle = (2 * Math.PI * i / edges) - Math.PI / 2;
                vertices.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }

            if (cornerRadius <= 0) {
                // Straight polygon
                let d = `M ${vertices[0].x.toFixed(2)} ${vertices[0].y.toFixed(2)}`;
                for (let i = 1; i < edges; i++) {
                    d += ` L ${vertices[i].x.toFixed(2)} ${vertices[i].y.toFixed(2)}`;
                }
                d += ' Z';
                return d;
            }

            // Rounded polygon: offset inward along edges and connect with quadratic bezier
            const maxOffset = 0.5; // max fraction of edge length for rounding
            let d = '';
            for (let i = 0; i < edges; i++) {
                const prev = vertices[(i - 1 + edges) % edges];
                const curr = vertices[i];
                const next = vertices[(i + 1) % edges];

                // Edge vectors from current vertex
                const toPrev = { x: prev.x - curr.x, y: prev.y - curr.y };
                const toNext = { x: next.x - curr.x, y: next.y - curr.y };

                // Edge lengths
                const lenPrev = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);
                const lenNext = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);

                // Offset distance (fraction of shorter adjacent edge)
                const offset = Math.min(lenPrev, lenNext) * maxOffset * cornerRadius;

                // Points offset from vertex along each edge
                const p1 = {
                    x: curr.x + (toPrev.x / lenPrev) * offset,
                    y: curr.y + (toPrev.y / lenPrev) * offset
                };
                const p2 = {
                    x: curr.x + (toNext.x / lenNext) * offset,
                    y: curr.y + (toNext.y / lenNext) * offset
                };

                if (i === 0) {
                    d = `M ${p1.x.toFixed(2)} ${p1.y.toFixed(2)}`;
                } else {
                    d += ` L ${p1.x.toFixed(2)} ${p1.y.toFixed(2)}`;
                }
                d += ` Q ${curr.x.toFixed(2)} ${curr.y.toFixed(2)} ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
            }
            // Close: line back to first offset point
            const first = vertices[0];
            const last = vertices[edges - 1];
            const secondV = vertices[1];
            const toLastFromFirst = { x: last.x - first.x, y: last.y - first.y };
            const toSecondFromFirst = { x: secondV.x - first.x, y: secondV.y - first.y };
            const lenLast = Math.sqrt(toLastFromFirst.x * toLastFromFirst.x + toLastFromFirst.y * toLastFromFirst.y);
            const lenSecond = Math.sqrt(toSecondFromFirst.x * toSecondFromFirst.x + toSecondFromFirst.y * toSecondFromFirst.y);
            const offsetFirst = Math.min(lenLast, lenSecond) * maxOffset * cornerRadius;
            const closePoint = {
                x: first.x + (toLastFromFirst.x / lenLast) * offsetFirst,
                y: first.y + (toLastFromFirst.y / lenLast) * offsetFirst
            };
            d += ` L ${closePoint.x.toFixed(2)} ${closePoint.y.toFixed(2)} Z`;
            return d;
        }

        function updatePadding(value, commit = false) {
            if (commit) commitSliderState();
            state.iconPadding = parseInt(value);
            document.getElementById('padding-value').textContent = value + '%';
            renderPreview();
        }

        function updateCornerRadius(value, commit = false) {
            if (commit) commitSliderState();
            state.cornerRadius = parseInt(value);
            document.getElementById('radius-value').textContent = value + '%';
            renderPreview();
        }

        function toggleFMCompat(enabled) {
            state.fmCompatible = enabled;
            updateFMTargetVisibility();
            savePreferences();
        }

        function toggleFMDynamic(enabled) {
            state.fmDynamicFill = enabled;
            updateFMTargetVisibility();
            savePreferences();
        }

        function setFMTarget(target) {
            state.fmDynamicTarget = target;
            document.getElementById('target-icon').classList.toggle('active', target === 'icon');
            document.getElementById('target-background').classList.toggle('active', target === 'background');

            const hint = document.getElementById('fm-target-hint');
            if (target === 'icon') {
                hint.textContent = 'FileMaker will dynamically change the icon color. Background keeps its set color.';
            } else {
                hint.textContent = 'FileMaker will dynamically change the background color. Icon keeps its set color.';
            }
        }

        function updateFMTargetVisibility() {
            const section = document.getElementById('fm-target-section');
            // Show target selector only when: FM compatible ON, dynamic fill ON, and background enabled
            const shouldShow = state.fmCompatible && state.fmDynamicFill && state.bgEnabled;
            section.style.display = shouldShow ? 'block' : 'none';

            // Ensure the current target is visually highlighted when section becomes visible
            if (shouldShow) {
                document.getElementById('target-icon').classList.toggle('active', state.fmDynamicTarget === 'icon');
                document.getElementById('target-background').classList.toggle('active', state.fmDynamicTarget === 'background');
            }
        }

        // ============================================
        // Stroke to Fill Conversion
        // ============================================

        /**
         * Detect if any loaded SVGs are stroke-based (have strokes with no fill)
         * Updates state.hasStrokeSVGs and shows/hides the conversion option
         */
        function detectStrokeSVGs() {
            state.hasStrokeSVGs = false;

            for (const item of state.svgItems) {
                if (isStrokeBasedSVG(item.currentSVG)) {
                    state.hasStrokeSVGs = true;
                    break;
                }
            }

            updateStrokeConversionUI();
        }

        /**
         * Check if an SVG element is stroke-based (has strokes with fill="none")
         * @param {SVGElement} svg - The SVG element to check
         * @returns {boolean} - True if the SVG is stroke-based
         */
        function isStrokeBasedSVG(svg) {
            // Check all shape elements
            const shapeElements = svg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');

            for (const el of shapeElements) {
                const stroke = el.getAttribute('stroke') || getStyleProperty(el, 'stroke');
                const fill = el.getAttribute('fill') || getStyleProperty(el, 'fill');
                const strokeWidth = el.getAttribute('stroke-width') || getStyleProperty(el, 'stroke-width');

                // Element has a stroke and either no fill or fill="none"
                if (stroke && stroke !== 'none') {
                    if (!fill || fill === 'none') {
                        // Has stroke without fill - this is a stroke-based element
                        return true;
                    }
                }

                // Also check for stroke-width without explicit stroke color (inherits currentColor)
                if (strokeWidth && parseFloat(strokeWidth) > 0) {
                    if (!fill || fill === 'none') {
                        return true;
                    }
                }
            }

            return false;
        }

        /**
         * Get a CSS property value from an element's style attribute
         * @param {Element} el - The element
         * @param {string} property - The CSS property name
         * @returns {string|null} - The property value or null
         */
        function getStyleProperty(el, property) {
            const style = el.getAttribute('style');
            if (!style) return null;

            const regex = new RegExp(property + '\\s*:\\s*([^;]+)', 'i');
            const match = style.match(regex);
            return match ? match[1].trim() : null;
        }

        /**
         * Toggle stroke to fill conversion
         * @param {boolean} enabled - Whether conversion is enabled
         */
        function toggleStrokeConversion(enabled) {
            state.convertStrokesToFills = enabled;
        }

        /**
         * Update the stroke conversion UI visibility
         */
        function updateStrokeConversionUI() {
            const section = document.getElementById('stroke-convert-section');
            if (section) {
                // Show only when: SVG format selected AND stroke SVGs detected
                const shouldShow = state.outputFormat === 'svg' && state.hasStrokeSVGs;
                section.style.display = shouldShow ? 'block' : 'none';

                // Update checkbox state
                const checkbox = document.getElementById('convert-strokes');
                if (checkbox) {
                    checkbox.checked = state.convertStrokesToFills;
                }
            }
        }

        /**
         * Convert a stroke-based SVG to filled paths using Potrace (bitmap tracing)
         * This approach renders the SVG to a high-res bitmap, then traces the outline
         * to create filled vector paths. Similar to outline-stroke.vercel.app
         * @param {string} svgString - The SVG string to convert
         * @returns {Promise<{svg: string, success: boolean, error: string|null}>} - The conversion result
         */
        async function convertStrokeToFill(svgString) {
            try {
                // Check if Potrace is available
                if (typeof Potrace === 'undefined') {
                    return { svg: svgString, success: false, error: 'Potrace not loaded' };
                }

                // Parse the SVG to get dimensions
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');

                if (!svg) {
                    return { svg: svgString, success: false, error: 'Invalid SVG' };
                }

                // Get dimensions from viewBox or width/height
                let width = 512, height = 512;
                let viewBoxMinX = 0, viewBoxMinY = 0;
                const viewBox = svg.getAttribute('viewBox');
                if (viewBox) {
                    const parts = viewBox.split(/[\s,]+/);
                    if (parts.length >= 4) {
                        viewBoxMinX = parseFloat(parts[0]) || 0;
                        viewBoxMinY = parseFloat(parts[1]) || 0;
                        width = parseFloat(parts[2]) || 512;
                        height = parseFloat(parts[3]) || 512;
                    }
                }

                // Use high resolution for better tracing quality
                // Potrace works better with larger images
                const scale = Math.max(2, 1024 / Math.max(width, height));
                const canvasWidth = Math.round(width * scale);
                const canvasHeight = Math.round(height * scale);

                // Render SVG to canvas
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');

                // Fill with white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Create image from SVG
                const img = new Image();

                const svgLoaded = new Promise((resolve, reject) => {
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Failed to load SVG as image'));

                    // Process SVG: replace ALL colors with black for maximum contrast during tracing
                    // This ensures Potrace can detect the icon regardless of what fill color the user selected
                    let processedSvg = svgString
                        .replace(/currentColor/gi, '#000000')
                        .replace(/fill\s*=\s*"(?!none)[^"]*"/gi, 'fill="#000000"')
                        .replace(/stroke\s*=\s*"(?!none)[^"]*"/gi, 'stroke="#000000"')
                        .replace(/fill\s*:\s*(?!none)[^;}"']+/gi, 'fill:#000000')
                        .replace(/stroke\s*:\s*(?!none)[^;}"']+/gi, 'stroke:#000000');

                    // Ensure SVG has proper dimensions
                    const tempDoc = parser.parseFromString(processedSvg, 'image/svg+xml');
                    const tempSvg = tempDoc.querySelector('svg');
                    if (tempSvg) {
                        tempSvg.setAttribute('width', canvasWidth);
                        tempSvg.setAttribute('height', canvasHeight);
                        processedSvg = new XMLSerializer().serializeToString(tempSvg);
                    }

                    const svgBlob = new Blob([processedSvg], { type: 'image/svg+xml;charset=utf-8' });
                    img.src = URL.createObjectURL(svgBlob);
                });

                await svgLoaded;

                // Draw SVG to canvas
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                URL.revokeObjectURL(img.src);

                // Use Potrace to trace the bitmap
                const tracedSvg = await new Promise((resolve, reject) => {
                    // Load the canvas data into Potrace
                    // Potrace works with a loaded image, so we convert canvas to data URL
                    const dataUrl = canvas.toDataURL('image/png');

                    Potrace.loadImageFromUrl(dataUrl);

                    // Set Potrace parameters for clean icon tracing
                    Potrace.setParameter({
                        turdsize: 2,        // Suppress small speckles
                        optcurve: true,     // Optimize curves
                        alphamax: 1,        // Corner threshold
                        opttolerance: 0.2   // Curve optimization tolerance
                    });

                    // Process the image
                    Potrace.process(function () {
                        try {
                            // Get SVG output at scale 1 (we'll adjust viewBox)
                            const result = Potrace.getSVG(1);
                            resolve(result);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });

                // Parse the traced SVG to extract paths
                const tracedDoc = parser.parseFromString(tracedSvg, 'image/svg+xml');
                const tracedSvgEl = tracedDoc.querySelector('svg');

                if (!tracedSvgEl) {
                    return { svg: svgString, success: false, error: 'Potrace produced invalid output' };
                }

                // Extract paths from traced SVG
                const paths = tracedSvgEl.querySelectorAll('path');
                if (paths.length === 0) {
                    return { svg: svgString, success: false, error: 'No paths traced' };
                }

                // Build output SVG with original dimensions
                // Scale the path coordinates back to original size
                let outputSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="${viewBoxMinX} ${viewBoxMinY} ${width} ${height}" version="1.1">\n`;

                for (const path of paths) {
                    let d = path.getAttribute('d');
                    if (d) {
                        // Scale path coordinates back to original dimensions
                        d = scalePathData(d, 1 / scale);
                        outputSvg += `    <path d="${d}" fill="inherit" stroke="none"/>\n`;
                    }
                }

                outputSvg += `</svg>`;

                return {
                    svg: outputSvg,
                    success: true,
                    error: null
                };
            } catch (error) {
                console.error('Stroke to fill conversion failed:', error);
                return {
                    svg: svgString,
                    success: false,
                    error: error.message
                };
            }
        }

        /**
         * Scale SVG path data by a factor
         * @param {string} pathData - The path d attribute
         * @param {number} scale - Scale factor
         * @returns {string} - Scaled path data
         */
        function scalePathData(pathData, scale) {
            // Match numbers (including decimals and negatives) in path data
            return pathData.replace(/-?\d+\.?\d*/g, (match) => {
                const num = parseFloat(match);
                return (num * scale).toFixed(2);
            });
        }

        /**
         * Check if a specific SVG item needs stroke conversion
         * @param {Object} item - The SVG item {filename, originalSVG, currentSVG}
         * @returns {boolean} - True if the item needs conversion
         */
        function needsStrokeConversion(item) {
            return state.convertStrokesToFills && isStrokeBasedSVG(item.currentSVG);
        }

        // ============================================
        // Export Format Functions
        // ============================================

        /**
         * Set the output format (SVG or PNG)
         */
        function setOutputFormat(format) {
            state.outputFormat = format;
            updateFormatUI();
            updateSaveButton();
        }

        /**
         * Set the output size for PNG export
         */
        function setOutputSize(size) {
            state.outputSize = size;
            updateFormatUI();
        }

        /**
         * Update the format UI to reflect current state
         */
        function updateFormatUI() {
            // Update format buttons
            document.getElementById('format-svg').classList.toggle('active', state.outputFormat === 'svg');
            document.getElementById('format-png').classList.toggle('active', state.outputFormat === 'png');

            // Show/hide PNG size options
            document.getElementById('png-size-section').style.display = state.outputFormat === 'png' ? 'block' : 'none';

            // Show/hide SVG-specific options
            document.getElementById('svg-options-section').style.display = state.outputFormat === 'svg' ? 'block' : 'none';

            // Update size buttons
            const sizes = [32, 64, 128, 256, 512, 1024];
            sizes.forEach(size => {
                const btn = document.getElementById('size-' + size);
                if (btn) {
                    btn.classList.toggle('active', state.outputSize === size);
                }
            });

            // Update stroke conversion UI visibility (depends on format)
            updateStrokeConversionUI();
        }

        /**
         * Convert an SVG element to a PNG data URL
         * @param {SVGElement} svgElement - The SVG to convert
         * @param {number} size - Output size (width and height)
         * @returns {Promise<string>} - Promise resolving to base64 PNG data
         */
        function svgToPng(svgElement, size) {
            return new Promise((resolve, reject) => {
                // Clone and prepare the SVG
                const svg = svgElement.cloneNode(true);
                svg.setAttribute('width', size);
                svg.setAttribute('height', size);

                // Serialize SVG to string
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svg);

                // Create a blob URL for the SVG
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                // Create an image and load the SVG
                const img = new Image();
                img.onload = function () {
                    // Create canvas and draw the image
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Draw with white background for transparency handling (optional)
                    // ctx.fillStyle = '#ffffff';
                    // ctx.fillRect(0, 0, size, size);

                    ctx.drawImage(img, 0, 0, size, size);

                    // Clean up the blob URL
                    URL.revokeObjectURL(url);

                    // Get PNG data URL and extract base64
                    const dataUrl = canvas.toDataURL('image/png');
                    const base64 = dataUrl.replace(/^data:image\/png;base64,/, '');
                    resolve(base64);
                };

                img.onerror = function () {
                    URL.revokeObjectURL(url);
                    reject(new Error('Failed to load SVG for PNG conversion'));
                };

                img.src = url;
            });
        }

        // ============================================
        // FileMaker Compatibility Processing
        // ============================================

        /**
         * Normalize SVG path commands to absolute coordinates
         * This ensures compatibility with FileMaker's SVG renderer
         */
        function normalizePath(pathData) {
            if (!pathData) return pathData;

            // Pre-process arc commands to fix flag notation
            // Arc flags (large-arc and sweep) are 0 or 1 and can be written without separators
            // e.g., "a15.92 15.92 0 01-11.31-4.69" should parse flags as 0 and 1
            function preprocessArcs(d) {
                // Match arc commands and their arguments
                return d.replace(/([Aa])\s*((?:[^MmLlHhVvCcSsQqTtAaZz])+)/g, (match, cmd, args) => {
                    // Process each set of 7 arc arguments
                    // We need to fix cases where flags run together: "01" -> "0 1", "00" -> "0 0", etc.
                    // Also cases like "01-5" -> "0 1 -5" or "10.5" after flags
                    let result = cmd;
                    let remaining = args.trim();

                    // Parse arc arguments - we expect sets of 7: rx ry rotation large-arc sweep x y
                    const numRe = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
                    let nums = [];
                    let m;

                    // First, extract all number-like tokens
                    while ((m = numRe.exec(remaining)) !== null) {
                        nums.push(m[0]);
                    }

                    // Now process in groups, fixing flag notation
                    let processed = [];
                    let i = 0;
                    while (i < nums.length) {
                        // rx
                        if (i < nums.length) processed.push(nums[i++]);
                        // ry
                        if (i < nums.length) processed.push(nums[i++]);
                        // rotation
                        if (i < nums.length) processed.push(nums[i++]);

                        // large-arc-flag and sweep-flag - these must be 0 or 1
                        // They might be combined like "01" or "10" or followed directly by coordinates
                        if (i < nums.length) {
                            let flagStr = nums[i++];
                            // Check if this contains both flags
                            if (flagStr.length >= 2 && /^[01][01]/.test(flagStr)) {
                                // Two flags combined, possibly with more digits
                                processed.push(flagStr[0]); // large-arc
                                // Rest is sweep flag possibly combined with x coordinate
                                let rest = flagStr.substring(1);
                                if (rest.length === 1) {
                                    processed.push(rest); // just sweep flag
                                } else if (/^[01]/.test(rest)) {
                                    processed.push(rest[0]); // sweep flag
                                    if (rest.length > 1) {
                                        // Remaining is start of x coordinate
                                        processed.push(rest.substring(1));
                                        // Skip x, get y
                                        if (i < nums.length) processed.push(nums[i++]);
                                        continue;
                                    }
                                } else {
                                    processed.push(rest);
                                }
                            } else {
                                processed.push(flagStr); // large-arc flag
                                // sweep-flag
                                if (i < nums.length) {
                                    let sweepStr = nums[i++];
                                    if (sweepStr.length > 1 && /^[01]/.test(sweepStr)) {
                                        processed.push(sweepStr[0]);
                                        processed.push(sweepStr.substring(1)); // x coordinate
                                        if (i < nums.length) processed.push(nums[i++]); // y
                                        continue;
                                    }
                                    processed.push(sweepStr);
                                }
                            }
                        }

                        // x
                        if (i < nums.length) processed.push(nums[i++]);
                        // y
                        if (i < nums.length) processed.push(nums[i++]);
                    }

                    return cmd + ' ' + processed.join(' ');
                });
            }

            // Tokenize path data properly - handles cases like "0-562.5" where minus starts new number
            function tokenize(d) {
                const tokens = [];
                const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
                let m;
                while ((m = re.exec(d)) !== null) {
                    tokens.push(m[0]);
                }
                return tokens;
            }

            // Pre-process arcs before tokenizing
            pathData = preprocessArcs(pathData);

            const tokens = tokenize(pathData);
            const commands = [];
            let i = 0;

            while (i < tokens.length) {
                const token = tokens[i];
                if (/[MmLlHhVvCcSsQqTtAaZz]/.test(token)) {
                    const cmd = token;
                    const args = [];
                    i++;
                    while (i < tokens.length && !/[MmLlHhVvCcSsQqTtAaZz]/.test(tokens[i])) {
                        args.push(parseFloat(tokens[i]));
                        i++;
                    }
                    commands.push({ cmd, args });
                } else {
                    i++;
                }
            }

            let x = 0, y = 0;      // Current position
            let startX = 0, startY = 0;  // Start of current subpath
            let lastCx = 0, lastCy = 0;  // Last control point (for S/T)
            let lastCmd = '';

            const result = [];

            for (const { cmd, args } of commands) {
                const isRelative = cmd === cmd.toLowerCase();
                const absCmd = cmd.toUpperCase();

                switch (absCmd) {
                    case 'M': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 2) {
                            const px = isRelative ? x + args[i] : args[i];
                            const py = isRelative ? y + args[i + 1] : args[i + 1];
                            if (i === 0) {
                                pts.push(`M${px} ${py}`);
                                startX = px;
                                startY = py;
                            } else {
                                pts.push(`L${px} ${py}`);
                            }
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'L': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 2) {
                            const px = isRelative ? x + args[i] : args[i];
                            const py = isRelative ? y + args[i + 1] : args[i + 1];
                            pts.push(`L${px} ${py}`);
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'H': {
                        const pts = [];
                        for (const arg of args) {
                            const px = isRelative ? x + arg : arg;
                            pts.push(`L${px} ${y}`);
                            x = px;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'V': {
                        const pts = [];
                        for (const arg of args) {
                            const py = isRelative ? y + arg : arg;
                            pts.push(`L${x} ${py}`);
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'C': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 6) {
                            const x1 = isRelative ? x + args[i] : args[i];
                            const y1 = isRelative ? y + args[i + 1] : args[i + 1];
                            const x2 = isRelative ? x + args[i + 2] : args[i + 2];
                            const y2 = isRelative ? y + args[i + 3] : args[i + 3];
                            const px = isRelative ? x + args[i + 4] : args[i + 4];
                            const py = isRelative ? y + args[i + 5] : args[i + 5];
                            pts.push(`C${x1} ${y1} ${x2} ${y2} ${px} ${py}`);
                            lastCx = x2;
                            lastCy = y2;
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'S': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 4) {
                            // Reflect last control point
                            let x1, y1;
                            if (lastCmd === 'C' || lastCmd === 'S') {
                                x1 = 2 * x - lastCx;
                                y1 = 2 * y - lastCy;
                            } else {
                                x1 = x;
                                y1 = y;
                            }
                            const x2 = isRelative ? x + args[i] : args[i];
                            const y2 = isRelative ? y + args[i + 1] : args[i + 1];
                            const px = isRelative ? x + args[i + 2] : args[i + 2];
                            const py = isRelative ? y + args[i + 3] : args[i + 3];
                            pts.push(`C${x1} ${y1} ${x2} ${y2} ${px} ${py}`);
                            lastCx = x2;
                            lastCy = y2;
                            x = px;
                            y = py;
                            lastCmd = 'S';
                        }
                        result.push(pts.join(' '));
                        continue;
                    }
                    case 'Q': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 4) {
                            const cx = isRelative ? x + args[i] : args[i];
                            const cy = isRelative ? y + args[i + 1] : args[i + 1];
                            const px = isRelative ? x + args[i + 2] : args[i + 2];
                            const py = isRelative ? y + args[i + 3] : args[i + 3];
                            pts.push(`Q${cx} ${cy} ${px} ${py}`);
                            lastCx = cx;
                            lastCy = cy;
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'T': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 2) {
                            let cx, cy;
                            if (lastCmd === 'Q' || lastCmd === 'T') {
                                cx = 2 * x - lastCx;
                                cy = 2 * y - lastCy;
                            } else {
                                cx = x;
                                cy = y;
                            }
                            const px = isRelative ? x + args[i] : args[i];
                            const py = isRelative ? y + args[i + 1] : args[i + 1];
                            pts.push(`Q${cx} ${cy} ${px} ${py}`);
                            lastCx = cx;
                            lastCy = cy;
                            x = px;
                            y = py;
                            lastCmd = 'T';
                        }
                        result.push(pts.join(' '));
                        continue;
                    }
                    case 'A': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 7) {
                            const rx = args[i];
                            const ry = args[i + 1];
                            const angle = args[i + 2];
                            const largeArc = args[i + 3];
                            const sweep = args[i + 4];
                            const px = isRelative ? x + args[i + 5] : args[i + 5];
                            const py = isRelative ? y + args[i + 6] : args[i + 6];
                            pts.push(`A${rx} ${ry} ${angle} ${largeArc} ${sweep} ${px} ${py}`);
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'Z': {
                        result.push('Z');
                        x = startX;
                        y = startY;
                        break;
                    }
                }
                lastCmd = absCmd;
            }

            return result.join(' ');
        }

        /**
         * Process SVG for FileMaker compatibility
         * - Adds fm_fill class
         * - Removes hardcoded fills (except fill="none")
         * - Normalizes path commands
         * - Ensures viewBox is present
         * - Strips units from width/height
         */
        function processSVGForFileMaker(svg) {
            // Add fm_fill class and set fill on SVG root for inheritance
            const existingClass = svg.getAttribute('class') || '';
            if (!existingClass.includes('fm_fill')) {
                svg.setAttribute('class', (existingClass + ' fm_fill').trim());
            }
            // Set fill on SVG element - FM will override this, children inherit it
            svg.setAttribute('fill', 'currentColor');

            // Ensure viewBox
            let vbW = 24, vbH = 24;
            if (!svg.getAttribute('viewBox')) {
                vbW = parseFloat(svg.getAttribute('width')) || 24;
                vbH = parseFloat(svg.getAttribute('height')) || 24;
                svg.setAttribute('viewBox', `0 0 ${vbW} ${vbH}`);
            } else {
                // Parse viewBox to get dimensions
                const vb = svg.getAttribute('viewBox').split(/\s+/);
                if (vb.length >= 4) {
                    vbW = parseFloat(vb[2]) || 24;
                    vbH = parseFloat(vb[3]) || 24;
                }
            }

            // Ensure width and height are set (required by FileMaker)
            if (!svg.getAttribute('width')) {
                svg.setAttribute('width', vbW);
            } else {
                svg.setAttribute('width', parseFloat(svg.getAttribute('width')) || vbW);
            }
            if (!svg.getAttribute('height')) {
                svg.setAttribute('height', vbH);
            } else {
                svg.setAttribute('height', parseFloat(svg.getAttribute('height')) || vbH);
            }

            // Remove invisible elements that FileMaker would render as visible
            // (FM doesn't support opacity attribute, so opacity="0" elements appear solid)
            // Common in SF Symbols and other icon sets as invisible bounding boxes
            const allElements = svg.querySelectorAll('*');
            allElements.forEach(el => {
                const opacity = el.getAttribute('opacity');
                if (opacity !== null && parseFloat(opacity) === 0) {
                    el.remove();
                }
            });

            // Remove fill-opacity and stroke-opacity attributes (unsupported by FileMaker)
            // These can cause rendering issues; FM controls color via fm_fill class
            svg.querySelectorAll('[fill-opacity]').forEach(el => {
                el.removeAttribute('fill-opacity');
            });
            svg.querySelectorAll('[stroke-opacity]').forEach(el => {
                el.removeAttribute('stroke-opacity');
            });

            // Migrate fill/stroke CSS properties from inline style to XML attributes
            // FileMaker doesn't handle CSS style attributes - it needs XML attributes
            // Without this, inline style="fill:none" overrides fill="#000000" attribute (CSS specificity)
            // which makes stroke-based SVGs (e.g. Inkscape exports) invisible in FM
            const styledShapes = svg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');
            styledShapes.forEach(el => {
                const styleAttr = el.getAttribute('style');
                if (!styleAttr) return;

                const propsToMigrate = ['fill', 'stroke', 'stroke-width', 'stroke-linecap',
                    'stroke-linejoin', 'stroke-miterlimit', 'stroke-dasharray',
                    'stroke-opacity', 'fill-opacity'];
                const remaining = [];

                styleAttr.split(';').forEach(decl => {
                    const colonIdx = decl.indexOf(':');
                    if (colonIdx === -1) return;
                    const name = decl.substring(0, colonIdx).trim();
                    const value = decl.substring(colonIdx + 1).trim();

                    if (propsToMigrate.includes(name) && value) {
                        el.setAttribute(name, value);
                    } else if (decl.trim()) {
                        remaining.push(decl.trim());
                    }
                });

                if (remaining.length > 0) {
                    el.setAttribute('style', remaining.join(';'));
                } else {
                    el.removeAttribute('style');
                }
            });

            // Remove hardcoded fills (except fill="none") - only if dynamic fill is enabled
            if (state.fmDynamicFill) {
                const bgElement = svg.querySelector('.fm-background');
                const iconGroup = svg.querySelector('.fm-icon');

                if (bgElement && iconGroup) {
                    // We have both background and icon - apply based on target
                    if (state.fmDynamicTarget === 'icon') {
                        // Set icon fills to inherit for FM dynamic styling, keep background fill
                        // Preserve 'none', 'currentColor', and 'inherit'
                        const iconElements = iconGroup.querySelectorAll('*');
                        iconElements.forEach(el => {
                            const fill = el.getAttribute('fill');
                            if (fill && fill !== 'none' && fill !== 'currentColor' && fill !== 'inherit') {
                                el.setAttribute('fill', 'inherit');
                            }
                            if (el.style && el.style.fill && el.style.fill !== 'none') {
                                el.style.fill = 'inherit';
                            }
                        });
                        // Also check the icon group itself
                        if (iconGroup.getAttribute('fill') && iconGroup.getAttribute('fill') !== 'none') {
                            iconGroup.setAttribute('fill', 'inherit');
                        }
                    } else {
                        // Set background fill to inherit, keep icon fills
                        bgElement.setAttribute('fill', 'inherit');
                    }
                } else {
                    // No background/icon distinction - set fills to inherit for FM dynamic styling
                    // Preserve 'none', 'currentColor', and 'inherit'
                    const elements = svg.querySelectorAll('*');
                    elements.forEach(el => {
                        const fill = el.getAttribute('fill');
                        if (fill && fill !== 'none' && fill !== 'currentColor' && fill !== 'inherit') {
                            el.setAttribute('fill', 'inherit');
                        }
                        if (el.style && el.style.fill && el.style.fill !== 'none') {
                            el.style.fill = 'inherit';
                        }
                    });
                }
            }

            // Handle stroke attributes for FileMaker
            // For stroke-only elements (fill="none" with stroke), convert them to fill-based for FM
            // For other elements, add stroke="none" (required by FileMaker)
            const shapeElements = svg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');
            shapeElements.forEach(el => {
                const fill = el.getAttribute('fill');
                const stroke = el.getAttribute('stroke');

                if (fill === 'none' && stroke && stroke !== 'none') {
                    // This is a stroke-only element - for FM dynamic coloring to work,
                    // we need to set stroke to inherit so FM can control it
                    if (state.fmDynamicFill) {
                        el.setAttribute('stroke', 'inherit');
                    }
                } else if (!stroke || stroke === '') {
                    // No stroke defined - add stroke="none" (required by FileMaker)
                    el.setAttribute('stroke', 'none');
                }
            });

            // Always normalize paths for FileMaker - it requires absolute commands with proper spacing
            // The normalizePath function now handles arc flag notation correctly
            const paths = svg.querySelectorAll('path');
            console.log(`[processSVGForFileMaker] Found ${paths.length} path(s) to normalize`);
            let normalizedCount = 0;
            let failedCount = 0;
            paths.forEach((path, index) => {
                const d = path.getAttribute('d');
                if (d) {
                    const originalFirst50 = d.substring(0, 50);
                    try {
                        const normalized = normalizePath(d);
                        if (normalized && normalized.length > 0) {
                            path.setAttribute('d', normalized);
                            normalizedCount++;
                            // Check if it actually changed
                            if (normalized === d) {
                                console.warn(`Path ${index}: normalization returned identical string`);
                            }
                        } else {
                            console.warn(`Path ${index}: normalization returned empty, keeping original. First 50 chars: "${originalFirst50}"`);
                            failedCount++;
                        }
                    } catch (e) {
                        console.error(`Path ${index}: normalization failed:`, e, `First 50 chars: "${originalFirst50}"`);
                        failedCount++;
                        // Keep original path if normalization fails
                    }
                }
            });
            console.log(`[processSVGForFileMaker] Normalized: ${normalizedCount}, Failed: ${failedCount}`);

            // Ensure xmlns
            if (!svg.getAttribute('xmlns')) {
                svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            }

            // Remove version attribute
            svg.removeAttribute('version');

            return svg;
        }

        // ============================================
        // Zoom Controls
        // ============================================

        function adjustZoom(delta) {
            state.zoom = Math.max(0.25, Math.min(4, state.zoom + delta));
            updateZoomDisplay();
        }

        function resetZoom() {
            state.zoom = 1;
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
            const wrapper = document.getElementById('preview-wrapper');
            const container = document.getElementById('preview-svg');
            const grid = container.querySelector('.preview-grid');

            if (grid) {
                // Grid mode - adjust tile size instead of scaling wrapper
                wrapper.style.transform = 'scale(1)';
                const baseTileSize = 100;  // Base tile size in pixels
                const scaledSize = Math.round(baseTileSize * state.zoom);
                grid.style.setProperty('--tile-size', scaledSize + 'px');
            } else {
                // Single SVG mode - scale the wrapper
                wrapper.style.transform = `scale(${state.zoom})`;
            }
        }

        function autoZoom() {
            if (!hasLoadedSVGs()) return;

            // For multi-SVG mode with grid, reset to 1x zoom
            if (state.svgItems.length > 1) {
                state.zoom = 1;
                updateZoomDisplay();
                return;
            }

            // Single SVG mode - calculate optimal zoom
            const firstItem = state.svgItems[0];
            const viewBox = firstItem.currentSVG.getAttribute('viewBox');
            let svgWidth, svgHeight;

            if (viewBox) {
                const parts = viewBox.split(/\s+/).map(parseFloat);
                svgWidth = parts[2];
                svgHeight = parts[3];
            } else {
                svgWidth = parseFloat(firstItem.currentSVG.getAttribute('width')) || 200;
                svgHeight = parseFloat(firstItem.currentSVG.getAttribute('height')) || 200;
            }

            // Get preview container dimensions
            const container = document.querySelector('.preview-container');
            if (!container) return;

            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width - 48;  // Account for padding
            const containerHeight = containerRect.height - 48;

            // The SVG in preview is rendered at 200x200 base size
            const baseSize = 200;

            // Calculate zoom to fill ~50% of container
            const targetFill = 0.5;
            const scaleToFitWidth = (containerWidth * targetFill) / baseSize;
            const scaleToFitHeight = (containerHeight * targetFill) / baseSize;

            // Use the smaller scale to ensure it fits, and clamp between 0.5 and 4
            state.zoom = Math.min(Math.max(Math.min(scaleToFitWidth, scaleToFitHeight), 0.5), 4);
            updateZoomDisplay();
        }

        // ============================================
        // Reset Functions
        // ============================================

        /**
         * Reset transformation state (preserves svgItems array)
         */
        function resetState() {
            state.rotation = 0;
            state.flipH = false;
            state.flipV = false;
            state.fillColor = '#000000';
            state.strokeColor = '#000000';
            state.strokeWidth = 0;
            state.bgEnabled = false;
            state.bgColor = '#ffffff';
            state.bgEdges = 4;
            state.iconPadding = 10;
            state.cornerRadius = 10;
            state.zoom = 1;
            state.opacity = 100;
            state.scale = 100;
            state.offsetX = 0;
            state.offsetY = 0;

            // Update UI
            document.getElementById('rotation-value').textContent = '0';
            document.getElementById('fill-color').value = '#000000';
            document.getElementById('fill-hex').value = '#000000';
            document.getElementById('fill-color').parentElement.style.background = '#000000';
            document.getElementById('stroke-color').value = '#000000';
            document.getElementById('stroke-hex').value = '#000000';
            document.getElementById('stroke-color').parentElement.style.background = '#000000';
            document.getElementById('stroke-width').value = 0;
            document.getElementById('stroke-value').textContent = '0';
            document.getElementById('bg-enabled').checked = false;
            document.getElementById('bg-options').classList.remove('visible');
            document.getElementById('bg-color').value = '#ffffff';
            document.getElementById('bg-hex').value = '#ffffff';
            document.getElementById('bg-color-preview').style.background = '#ffffff';
            document.getElementById('icon-padding').value = 10;
            document.getElementById('padding-value').textContent = '10%';
            document.getElementById('corner-radius').value = 10;
            document.getElementById('radius-value').textContent = '10%';
            document.getElementById('opacity-slider').value = 100;
            document.getElementById('opacity-value').textContent = '100%';
            document.getElementById('scale-slider').value = 100;
            document.getElementById('scale-value').textContent = '100%';
            document.getElementById('offset-x-slider').value = 0;
            document.getElementById('offset-x-value').textContent = '0';
            document.getElementById('offset-y-slider').value = 0;
            document.getElementById('offset-y-value').textContent = '0';
            setBgEdges(4);
            updateZoomDisplay();
            // Reset FM target to icon and update visibility
            setFMTarget('icon');
            updateFMTargetVisibility();
        }

        function resetAll() {
            if (hasLoadedSVGs()) {
                // If there are undoable changes, prompt for confirmation
                if (hasUndoableChanges()) {
                    showConfirmModal({
                        title: 'Reset to Original?',
                        message: 'You have unsaved changes. Are you sure you want to reset all SVGs to their original state? This action cannot be undone.',
                        confirmText: 'Reset',
                        onConfirm: performReset
                    });
                    return;
                }

                performReset();
            }
        }

        /**
         * Actually perform the reset (called directly or after confirmation)
         */
        function performReset() {
            if (hasLoadedSVGs()) {
                // Re-parse all original SVGs
                const parser = new DOMParser();
                state.svgItems.forEach(item => {
                    const doc = parser.parseFromString(item.originalSVG, 'image/svg+xml');
                    item.currentSVG = doc.querySelector('svg').cloneNode(true);
                });
                resetState();
                clearHistory();
                renderPreview();
            }
        }

        // ============================================
        // Rendering
        // ============================================

        function renderPreview() {
            if (!hasLoadedSVGs()) return;

            const container = document.getElementById('preview-svg');
            const emptyState = document.getElementById('empty-state');
            const wrapper = document.getElementById('preview-wrapper');

            container.innerHTML = '';

            // Clean up single-mode hover buttons (may be stale from previous render)
            const dropZoneEl = document.getElementById('drop-zone');
            if (dropZoneEl) {
                const staleBtn = dropZoneEl.querySelector('.single-remove-btn');
                if (staleBtn) staleBtn.remove();
                const staleActions = dropZoneEl.querySelector('.single-actions');
                if (staleActions) staleActions.remove();
            }

            // If only one SVG, use single preview mode
            if (state.svgItems.length === 1) {
                container.classList.remove('grid-mode');

                const finalSVG = generateFinalSVG(state.svgItems[0]);

                // Set a reasonable preview size
                finalSVG.setAttribute('width', '200');
                finalSVG.setAttribute('height', '200');
                finalSVG.style.maxWidth = '100%';
                finalSVG.style.maxHeight = '100%';

                container.appendChild(finalSVG);

                // Add single-mode remove button
                const previewContainer = document.getElementById('drop-zone');
                // Remove any existing single remove btn
                const existingBtn = previewContainer.querySelector('.single-remove-btn');
                if (existingBtn) existingBtn.remove();

                const removeBtn = document.createElement('button');
                removeBtn.className = 'single-remove-btn';
                removeBtn.innerHTML = '&times;';
                removeBtn.title = 'Remove SVG';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeSVGItem(0);
                });
                previewContainer.appendChild(removeBtn);

                // Add single-mode action buttons (copy, view code) - top-left
                const actions = document.createElement('div');
                actions.className = 'single-actions';

                const copyBtn = document.createElement('button');
                copyBtn.className = 'single-action-btn';
                copyBtn.title = 'Copy SVG';
                copyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
                copyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    performCopySVG(0);
                });

                const codeBtn = document.createElement('button');
                codeBtn.className = 'single-action-btn';
                codeBtn.title = 'View Code';
                codeBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>';
                codeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    performCodeView(0);
                });

                actions.appendChild(copyBtn);
                actions.appendChild(codeBtn);
                previewContainer.appendChild(actions);

                // Apply zoom via wrapper scale for single SVG
                wrapper.style.transform = `scale(${state.zoom})`;
            } else {
                // Multiple SVGs - render as tile grid
                container.classList.add('grid-mode');

                const grid = document.createElement('div');
                grid.className = 'preview-grid';

                // Set initial tile size based on current zoom
                const baseTileSize = 100;
                const scaledSize = Math.round(baseTileSize * state.zoom);
                grid.style.setProperty('--tile-size', scaledSize + 'px');

                state.svgItems.forEach((item, index) => {
                    const tile = createPreviewTile(item, index);
                    grid.appendChild(tile);
                });

                container.appendChild(grid);

                // Reset wrapper scale for grid mode (tiles handle their own sizing)
                wrapper.style.transform = 'scale(1)';
            }

            // Hide empty state when SVGs are loaded
            if (emptyState) {
                emptyState.classList.add('hidden');
            }

            updateControlsPanelVisibility();
            updatePreviewFilename();
        }

        /**
         * Create a preview tile for a single SVG item
         * @param {Object} item - SVG item {filename, originalSVG, currentSVG}
         * @param {number} index - Index in the svgItems array
         * @returns {HTMLElement} - Tile element
         */
        function createPreviewTile(item, index) {
            const tile = document.createElement('div');
            tile.className = 'preview-tile';
            tile.dataset.index = index;

            // Drag reorder attributes
            tile.draggable = true;
            tile.addEventListener('dragstart', handleTileDragStart);
            tile.addEventListener('dragend', handleTileDragEnd);
            tile.addEventListener('dragover', handleTileDragOver);
            tile.addEventListener('dragleave', handleTileDragLeave);
            tile.addEventListener('drop', handleTileDrop);

            // Remove button (top-right)
            const removeBtn = document.createElement('button');
            removeBtn.className = 'tile-remove-btn';
            removeBtn.innerHTML = '&times;';
            removeBtn.title = 'Remove';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeSVGItem(index);
            });

            // Action buttons (top-left): copy, view code
            const actions = document.createElement('div');
            actions.className = 'tile-actions';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'tile-action-btn';
            copyBtn.title = 'Copy SVG';
            copyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                performCopySVG(index);
            });

            const codeBtn = document.createElement('button');
            codeBtn.className = 'tile-action-btn';
            codeBtn.title = 'View Code';
            codeBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>';
            codeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                performCodeView(index);
            });

            actions.appendChild(copyBtn);
            actions.appendChild(codeBtn);

            // SVG container
            const svgContainer = document.createElement('div');
            svgContainer.className = 'tile-svg';

            const finalSVG = generateFinalSVG(item);
            if (finalSVG) {
                // Use 100% to fill the container (size controlled by CSS --tile-size)
                finalSVG.setAttribute('width', '100%');
                finalSVG.setAttribute('height', '100%');
                svgContainer.appendChild(finalSVG);
            }

            // Filename label
            const filenameLabel = document.createElement('div');
            filenameLabel.className = 'tile-filename';
            filenameLabel.textContent = item.filename;
            filenameLabel.title = item.filename; // Full name on hover

            tile.appendChild(removeBtn);
            tile.appendChild(actions);
            tile.appendChild(svgContainer);
            tile.appendChild(filenameLabel);

            return tile;
        }

        /**
         * Show the empty state (when no SVG is loaded)
         */
        function showEmptyState() {
            const container = document.getElementById('preview-svg');
            const emptyState = document.getElementById('empty-state');

            container.innerHTML = '';
            container.classList.remove('grid-mode');

            // Remove single-mode hover buttons if present
            const previewContainer = document.getElementById('drop-zone');
            if (previewContainer) {
                const existingBtn = previewContainer.querySelector('.single-remove-btn');
                if (existingBtn) existingBtn.remove();
                const existingActions = previewContainer.querySelector('.single-actions');
                if (existingActions) existingActions.remove();
            }

            if (emptyState) {
                emptyState.classList.remove('hidden');
            }

            updateControlsPanelVisibility();
            updateSaveButton();
            updatePreviewFilename();
        }

        /**
         * Generate the final SVG with all transformations applied
         * @param {Object} svgItem - Optional SVG item. If not provided, uses first item for preview.
         */
        function generateFinalSVG(svgItem) {
            // Use provided item or first item in array
            const item = svgItem || state.svgItems[0];
            if (!item) return null;

            // Clone the current SVG
            const svg = item.currentSVG.cloneNode(true);

            // Get viewBox or create one
            let viewBox = svg.getAttribute('viewBox');
            if (!viewBox) {
                const w = parseFloat(svg.getAttribute('width')) || 24;
                const h = parseFloat(svg.getAttribute('height')) || 24;
                viewBox = `0 0 ${w} ${h}`;
                svg.setAttribute('viewBox', viewBox);
            }

            const [vbX, vbY, vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
            const centerX = vbX + vbW / 2;
            const centerY = vbY + vbH / 2;

            // Apply fill color to all elements
            applyFillColor(svg, state.fillColor);

            // Apply stroke if enabled
            if (state.strokeWidth > 0) {
                applyStroke(svg, state.strokeColor, state.strokeWidth);
            }

            // Build transformation string
            const transforms = [];

            // Apply offset (translate)
            if (state.offsetX !== 0 || state.offsetY !== 0) {
                const offsetXPx = (state.offsetX / 100) * vbW;
                const offsetYPx = (state.offsetY / 100) * vbH;
                transforms.push(`translate(${offsetXPx} ${offsetYPx})`);
            }

            // Apply scale
            if (state.scale !== 100) {
                const scaleFactor = state.scale / 100;
                transforms.push(`translate(${centerX} ${centerY}) scale(${scaleFactor}) translate(${-centerX} ${-centerY})`);
            }

            // Apply rotation
            if (state.rotation !== 0) {
                transforms.push(`rotate(${state.rotation} ${centerX} ${centerY})`);
            }

            // Apply flips
            if (state.flipH || state.flipV) {
                const scaleX = state.flipH ? -1 : 1;
                const scaleY = state.flipV ? -1 : 1;
                transforms.push(`translate(${centerX} ${centerY}) scale(${scaleX} ${scaleY}) translate(${-centerX} ${-centerY})`);
            }

            // Check if we need a wrapper group (for transforms or opacity)
            const needsGroup = transforms.length > 0 || state.opacity !== 100;

            // Wrap content in a group with transforms and/or opacity
            if (needsGroup) {
                const content = Array.from(svg.childNodes);
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                if (transforms.length > 0) {
                    group.setAttribute('transform', transforms.join(' '));
                }
                if (state.opacity !== 100) {
                    group.setAttribute('opacity', state.opacity / 100);
                }
                content.forEach(node => group.appendChild(node.cloneNode(true)));
                svg.innerHTML = '';
                svg.appendChild(group);
            }

            // Add background if enabled
            if (state.bgEnabled) {
                return wrapWithBackground(svg, vbW, vbH);
            }

            return svg;
        }

        function applyFillColor(svg, color) {
            // Apply fill to elements that should be filled
            // For stroke-only elements (fill="none"), apply the color to their stroke instead
            const elements = svg.querySelectorAll('path, circle, rect, polygon, polyline, ellipse, line');
            elements.forEach(el => {
                const currentFill = el.getAttribute('fill');
                const currentStroke = el.getAttribute('stroke');

                if (currentFill === 'none') {
                    // This is a stroke-only element - apply color to stroke
                    if (currentStroke && currentStroke !== 'none') {
                        el.setAttribute('stroke', color);
                    }
                } else {
                    // Normal filled element - apply color to fill
                    el.setAttribute('fill', color);
                }

                // Also check style attribute
                if (el.style.fill && el.style.fill !== 'none') {
                    el.style.fill = color;
                }
                if (el.style.stroke && el.style.stroke !== 'none' && currentFill === 'none') {
                    el.style.stroke = color;
                }
            });

            // Handle groups that might have fill
            const groups = svg.querySelectorAll('g[fill]');
            groups.forEach(g => {
                if (g.getAttribute('fill') !== 'none') {
                    g.setAttribute('fill', color);
                }
            });
        }

        function applyStroke(svg, color, width) {
            const elements = svg.querySelectorAll('path, circle, rect, polygon, polyline, ellipse, line');
            elements.forEach(el => {
                el.setAttribute('stroke', color);
                el.setAttribute('stroke-width', width);
            });
        }

        function wrapWithBackground(iconSvg, origWidth, origHeight) {
            // Create new SVG with background
            const newSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            newSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

            // Calculate padding
            const padding = (state.iconPadding / 100) * Math.max(origWidth, origHeight);
            const totalSize = Math.max(origWidth, origHeight) + padding * 2;

            newSvg.setAttribute('viewBox', `0 0 ${totalSize} ${totalSize}`);
            newSvg.setAttribute('width', totalSize);
            newSvg.setAttribute('height', totalSize);

            // Create background shape
            let bgShape;
            if (state.bgEdges === 0) {
                // Circle
                bgShape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                bgShape.setAttribute('cx', totalSize / 2);
                bgShape.setAttribute('cy', totalSize / 2);
                bgShape.setAttribute('r', totalSize / 2);
            } else if (state.bgEdges === 4) {
                // Square: use rect for cleaner output
                bgShape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bgShape.setAttribute('x', 0);
                bgShape.setAttribute('y', 0);
                bgShape.setAttribute('width', totalSize);
                bgShape.setAttribute('height', totalSize);
                const radius = (state.cornerRadius / 100) * totalSize;
                if (radius > 0) {
                    bgShape.setAttribute('rx', radius);
                    bgShape.setAttribute('ry', radius);
                }
            } else {
                // Polygon (3, 5, 6, 7, ...)
                bgShape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const cornerRadiusFraction = state.cornerRadius / 100;
                const d = generatePolygonPath(totalSize / 2, totalSize / 2, totalSize / 2, state.bgEdges, cornerRadiusFraction);
                bgShape.setAttribute('d', d);
            }
            bgShape.setAttribute('fill', state.bgColor);
            bgShape.setAttribute('class', 'fm-background');
            newSvg.appendChild(bgShape);

            // Create group for the icon
            const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            iconGroup.setAttribute('class', 'fm-icon');

            // Calculate scale and position to center the icon
            const iconScale = (totalSize - padding * 2) / Math.max(origWidth, origHeight);
            const offsetX = (totalSize - origWidth * iconScale) / 2;
            const offsetY = (totalSize - origHeight * iconScale) / 2;

            iconGroup.setAttribute('transform', `translate(${offsetX} ${offsetY}) scale(${iconScale})`);

            // Copy all children from icon SVG
            Array.from(iconSvg.childNodes).forEach(node => {
                iconGroup.appendChild(node.cloneNode(true));
            });

            newSvg.appendChild(iconGroup);

            return newSvg;
        }

        // ============================================
        // Utility Functions
        // ============================================

        function normalizeHex(value) {
            const v = value.trim();
            if (/^[0-9a-fA-F]{3,8}$/.test(v)) return '#' + v;
            return v;
        }

        function isValidColor(color) {
            const s = new Option().style;
            s.color = color;
            return s.color !== '';
        }

        function hexToHSV(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min;
            let h = 0, s = max === 0 ? 0 : d / max, v = max;
            if (d !== 0) {
                if (max === r) h = ((g - b) / d + 6) % 6;
                else if (max === g) h = (b - r) / d + 2;
                else h = (r - g) / d + 4;
                h *= 60;
            }
            return { h, s, v };
        }

        function hsvToHex(h, s, v) {
            let c = v * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = v - c;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            const toHex = n => Math.round((n + m) * 255).toString(16).padStart(2, '0');
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }

        function updateSizeInfo() {
            const dimEl = document.getElementById('svg-dimensions');
            const sizeEl = document.getElementById('svg-size');
            if (!hasLoadedSVGs()) {
                dimEl.style.display = 'none';
                sizeEl.style.display = 'none';
                return;
            }
            dimEl.style.display = '';
            sizeEl.style.display = '';

            const count = state.svgItems.length;

            if (count === 1) {
                // Single SVG - show dimensions and size
                const item = state.svgItems[0];
                const viewBox = item.currentSVG.getAttribute('viewBox');
                let w, h;

                if (viewBox) {
                    const parts = viewBox.split(/\s+/);
                    w = parts[2];
                    h = parts[3];
                } else {
                    w = item.currentSVG.getAttribute('width') || '?';
                    h = item.currentSVG.getAttribute('height') || '?';
                }

                document.getElementById('svg-dimensions').textContent = `Dimensions: ${w}  ${h}`;

                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(item.currentSVG);
                const bytes = new Blob([svgString]).size;
                document.getElementById('svg-size').textContent = `Size: ${formatBytes(bytes)}`;
            } else {
                // Multiple SVGs - show count and total size
                document.getElementById('svg-dimensions').textContent = `Files: ${count} SVGs`;

                const serializer = new XMLSerializer();
                let totalBytes = 0;
                state.svgItems.forEach(item => {
                    const svgString = serializer.serializeToString(item.currentSVG);
                    totalBytes += new Blob([svgString]).size;
                });
                document.getElementById('svg-size').textContent = `Total size: ${formatBytes(totalBytes)}`;
            }
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ============================================
        // Keyboard Shortcuts
        // ============================================

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function (e) {
                // Skip if focus is in an input, textarea, or select
                const tag = document.activeElement.tagName.toLowerCase();
                if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const modKey = isMac ? e.metaKey : e.ctrlKey;

                // Escape - close code view modal
                if (e.key === 'Escape') {
                    const codeViewModal = document.getElementById('code-view-modal');
                    if (codeViewModal && codeViewModal.classList.contains('visible')) {
                        hideCodeView();
                        return;
                    }
                    const selectionModal = document.getElementById('svg-selection-modal');
                    if (selectionModal && selectionModal.classList.contains('visible')) {
                        hideSVGSelectionModal();
                        return;
                    }
                }

                // Ctrl/Cmd+Z = Undo
                if (modKey && !e.shiftKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                    return;
                }

                // Ctrl/Cmd+Shift+Z or Ctrl/Cmd+Y = Redo
                if ((modKey && e.shiftKey && e.key === 'z') || (modKey && e.key === 'y')) {
                    e.preventDefault();
                    redo();
                    return;
                }

            });

            // Listen for paste event (handles both text and file pastes)
            document.addEventListener('paste', function (e) {
                // Skip if focus is in an input/textarea/select
                const tag = (e.target.tagName || '').toLowerCase();
                if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

                // Check for SVG files on the clipboard first
                const files = e.clipboardData && e.clipboardData.files;
                if (files && files.length > 0) {
                    const svgFiles = Array.from(files).filter(f =>
                        f.type === 'image/svg+xml' || (f.name && f.name.toLowerCase().endsWith('.svg'))
                    );
                    if (svgFiles.length > 0) {
                        e.preventDefault();
                        handlePastedFiles(svgFiles);
                        return;
                    }
                }

                // Check for SVG text on the clipboard
                const text = e.clipboardData && e.clipboardData.getData('text/plain');
                if (text && text.includes('<svg')) {
                    e.preventDefault();
                    processPastedSVGText(text);
                }
            });
        }

        // ============================================
        // Paste SVG from Clipboard
        // ============================================

        /**
         * Handle paste button click (for FileMaker where Cmd+V is intercepted)
         * Uses Clipboard API to read both files and text
         */
        /**
         * Handle paste button click.
         * Uses execCommand('paste') via hidden textarea to avoid Safari/WebKit
         * clipboard permission popup. Falls back to Clipboard API if needed.
         * Note: File paste from OS clipboard only works via Cmd+V in browsers,
         * not via button click (browser security restriction).
         */
        function handlePasteButton() {
            // Primary: use hidden textarea + execCommand to avoid permission popup
            const textarea = document.createElement('textarea');
            textarea.style.cssText = 'position:fixed;left:-9999px;top:0;opacity:0;';
            document.body.appendChild(textarea);
            textarea.focus();

            const pasted = document.execCommand('paste');

            // Short delay to ensure paste completes
            setTimeout(() => {
                const text = textarea.value;
                document.body.removeChild(textarea);

                if (text && text.trim()) {
                    processPastedSVGText(text);
                } else if (!pasted && navigator.clipboard && navigator.clipboard.readText) {
                    // execCommand failed entirely, try Clipboard API as fallback
                    navigator.clipboard.readText().then(t => {
                        if (t && t.trim()) {
                            processPastedSVGText(t);
                        } else {
                            showPreviewToast('No SVG found on clipboard');
                        }
                    }).catch(() => {
                        showPreviewToast('Could not read clipboard');
                    });
                } else {
                    showPreviewToast('No SVG found on clipboard');
                }
            }, 50);
        }

        /**
         * Handle SVG files pasted via paste event
         * @param {File[]} files - Array of SVG files from clipboardData.files
         */
        function handlePastedFiles(files) {
            // If there are existing SVGs with unsaved changes, confirm
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                showConfirmModal({
                    title: 'Load Pasted SVGs?',
                    message: 'You have unsaved changes. Loading pasted SVGs will discard these changes.',
                    confirmText: 'Load',
                    onConfirm: () => loadFilesAsSVG(files)
                });
                return;
            }

            loadFilesAsSVG(files);
            showPreviewToast(files.length === 1 ? 'SVG pasted' : files.length + ' SVGs pasted');
        }

        /**
         * Process pasted text that may contain SVG markup
         * @param {string} text - Text from clipboard
         */
        function processPastedSVGText(text) {
            if (!text || !text.trim()) {
                showPreviewToast('No SVG found on clipboard');
                return;
            }

            const trimmed = text.trim();

            // Extract all SVG elements from the text
            const svgRegex = /<svg[\s\S]*?<\/svg>/gi;
            const matches = trimmed.match(svgRegex);

            if (!matches || matches.length === 0) {
                showPreviewToast('No SVG found on clipboard');
                return;
            }

            // Validate each match
            const parser = new DOMParser();
            const validSVGs = [];
            for (const svgString of matches) {
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                if (!doc.querySelector('parsererror') && doc.querySelector('svg')) {
                    validSVGs.push(svgString);
                }
            }

            if (validSVGs.length === 0) {
                showPreviewToast('Invalid SVG on clipboard');
                return;
            }

            loadPastedSVGs(validSVGs);
        }

        /**
         * Load one or more validated SVG strings as pasted items
         * @param {string[]} svgStrings - Array of valid SVG markup strings
         */
        function loadPastedSVGs(svgStrings) {
            // If there are existing SVGs with unsaved changes, confirm
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                showConfirmModal({
                    title: svgStrings.length === 1 ? 'Load Pasted SVG?' : 'Load ' + svgStrings.length + ' Pasted SVGs?',
                    message: 'You have unsaved changes. Loading pasted SVGs will discard these changes.',
                    confirmText: 'Load',
                    onConfirm: () => performLoadPastedSVGs(svgStrings)
                });
                return;
            }

            performLoadPastedSVGs(svgStrings);
        }

        /**
         * Actually load pasted SVG strings into the editor
         */
        function performLoadPastedSVGs(svgStrings) {
            state.svgItems = [];
            resetState();
            clearHistory();

            svgStrings.forEach((svgString, i) => {
                const name = svgStrings.length === 1 ? 'pasted.svg' : 'pasted-' + (i + 1) + '.svg';
                addSVGItem(name, svgString);
            });

            renderPreview();
            updateSizeInfo();
            updateSaveButton();
            detectStrokeSVGs();
            setTimeout(autoZoom, 50);

            const count = state.svgItems.length;
            showPreviewToast(count === 1 ? 'SVG pasted' : count + ' SVGs pasted');
        }

        /**
         * Extract SVG markup from a string, returns null if invalid
         */
        function extractSVG(text) {
            if (!text) return null;
            const match = text.trim().match(/<svg[\s\S]*<\/svg>/i);
            if (!match) return null;
            const parser = new DOMParser();
            const doc = parser.parseFromString(match[0], 'image/svg+xml');
            if (doc.querySelector('parsererror') || !doc.querySelector('svg')) return null;
            return match[0];
        }

        // ============================================
        // Collapsible Control Sections
        // ============================================

        function setupCollapsibleSections() {
            const sections = document.querySelectorAll('.controls-panel .control-section');
            sections.forEach(section => {
                const h3 = section.querySelector('h3');
                if (!h3) return;

                // Add chevron indicator
                const chevron = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                chevron.setAttribute('viewBox', '0 0 24 24');
                chevron.setAttribute('fill', 'none');
                chevron.setAttribute('stroke', 'currentColor');
                chevron.setAttribute('stroke-width', '2');
                chevron.classList.add('chevron');
                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', '6 9 12 15 18 9');
                chevron.appendChild(polyline);
                h3.appendChild(chevron);

                // Wrap content below h3 in a container div
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'control-section-content';
                const children = Array.from(section.children).filter(child => child !== h3);
                children.forEach(child => contentWrapper.appendChild(child));
                section.appendChild(contentWrapper);

                // Toggle on click
                h3.addEventListener('click', () => {
                    section.classList.toggle('collapsed');
                });
            });
        }

        // ============================================
        // Preview Background Toggle
        // ============================================

        function togglePreviewBgDropdown(event) {
            event.stopPropagation();
            const container = document.getElementById('preview-bg-container');
            container.classList.toggle('open');
        }

        function updateControlsPanelVisibility() {
            const panel = document.querySelector('.controls-panel');
            if (panel) {
                panel.classList.toggle('hidden', !hasLoadedSVGs());
            }
        }

        function getContrastColor(hexColor) {
            const hex = hexColor.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            return luminance > 128 ? '#000000' : '#ffffff';
        }

        function updatePreviewTextColor(mode) {
            const previewContainer = document.getElementById('preview-svg');
            if (!previewContainer) return;

            if (mode === 'checkerboard') {
                previewContainer.classList.remove('colored-bg-active');
                previewContainer.style.removeProperty('--preview-text-color');
            } else {
                previewContainer.classList.add('colored-bg-active');
                let textColor;
                if (mode === 'white') {
                    textColor = '#000000';
                } else if (mode === 'black') {
                    textColor = '#ffffff';
                } else if (mode === 'custom') {
                    textColor = getContrastColor(state.previewBgCustomColor || '#ffffff');
                }
                previewContainer.style.setProperty('--preview-text-color', textColor);
            }
        }

        function setPreviewBg(mode) {
            state.previewBg = mode;
            const bgEl = document.querySelector('.preview-bg');
            bgEl.classList.remove('bg-white', 'bg-black', 'bg-custom');
            // Always clear inline backgroundColor so it doesn't bleed into other modes
            bgEl.style.backgroundColor = '';

            if (mode === 'white') {
                bgEl.classList.add('bg-white');
            } else if (mode === 'black') {
                bgEl.classList.add('bg-black');
            } else if (mode === 'custom') {
                bgEl.classList.add('bg-custom');
                bgEl.style.backgroundColor = state.previewBgCustomColor;
            }
            // 'checkerboard' = default (no extra class, no inline bg color)

            // Update active state
            document.querySelectorAll('.preview-bg-option').forEach(opt => {
                opt.classList.toggle('active', opt.dataset.bg === mode);
            });

            // Show/hide custom color picker
            const customPicker = document.getElementById('preview-bg-custom-picker');
            if (customPicker) {
                customPicker.style.display = mode === 'custom' ? 'flex' : 'none';
            }

            // Close dropdown (but keep open for custom so user can pick color)
            if (mode !== 'custom') {
                document.getElementById('preview-bg-container').classList.remove('open');
            }
            updatePreviewTextColor(mode);
            savePreferences();
        }

        function updatePreviewBgCustomColor(color) {
            state.previewBgCustomColor = color;
            const bgEl = document.querySelector('.preview-bg');
            if (state.previewBg === 'custom') {
                bgEl.style.backgroundColor = color;
                updatePreviewTextColor('custom');
            }
            // Update swatch
            const swatch = document.getElementById('preview-bg-custom-swatch');
            if (swatch) swatch.style.background = color;
            savePreferences();
        }

        // Close preview bg dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const container = document.getElementById('preview-bg-container');
            if (container && !container.contains(event.target)) {
                container.classList.remove('open');
            }
        });

        // ============================================
        // Remove Individual SVGs
        // ============================================

        function removeSVGItem(index) {
            if (index < 0 || index >= state.svgItems.length) return;

            // If this is the last SVG, clear everything
            if (state.svgItems.length === 1) {
                pushToHistory();
                clearAllSVGs();
                return;
            }

            pushToHistory();
            state.svgItems.splice(index, 1);
            renderPreview();
            updateSaveButton();
            updateSizeInfo();
            detectStrokeSVGs();
        }

        // ============================================
        // Copy SVG to Clipboard
        // ============================================

        function copySVGToClipboard() {
            if (!hasLoadedSVGs()) return;

            if (state.svgItems.length === 1) {
                performCopySVG(0);
            } else {
                showSVGSelectionModal('copy');
            }
        }

        function performCopySVG(index) {
            const item = state.svgItems[index];
            if (!item) return;

            // Generate final SVG through the same pipeline as save
            let finalSVG = generateFinalSVG(item);
            const serializer = new XMLSerializer();
            let svgString = serializer.serializeToString(finalSVG);

            // Apply FM processing if enabled
            if (state.fmCompatible) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');
                if (svg) {
                    processSVGForFileMaker(svg);
                    svgString = serializer.serializeToString(svg);
                }
            }

            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(svgString).then(() => {
                    showCopyFeedback();
                }).catch(() => {
                    fallbackCopy(svgString);
                });
            } else {
                fallbackCopy(svgString);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showCopyFeedback();
            } catch (e) {
                console.error('Copy failed:', e);
            }
            document.body.removeChild(textarea);
        }

        function showCopyFeedback() {
            // Show toast in the preview area
            showPreviewToast('Copied!');

            // Also update the Copy button if visible
            const btn = document.getElementById('copy-btn');
            const btnText = document.getElementById('copy-btn-text');
            if (btn && btnText) {
                const originalText = btnText.textContent;
                btnText.textContent = 'Copied!';
                btn.style.background = 'var(--success)';
                btn.style.borderColor = 'var(--success)';
                setTimeout(() => {
                    btnText.textContent = originalText;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                }, 1500);
            }
        }

        let previewToastTimer = null;

        function showPreviewToast(message) {
            const previewContainer = document.getElementById('drop-zone');
            if (!previewContainer) return;

            // Reuse existing toast or create new one
            let toast = previewContainer.querySelector('.preview-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.className = 'preview-toast';
                previewContainer.appendChild(toast);
            }

            toast.textContent = message;

            // Clear any pending hide
            if (previewToastTimer) clearTimeout(previewToastTimer);

            // Show
            requestAnimationFrame(() => {
                toast.classList.add('visible');
            });

            // Auto-hide after delay
            previewToastTimer = setTimeout(() => {
                toast.classList.remove('visible');
            }, 1200);
        }

        // ============================================
        // SVG Code View
        // ============================================

        function showCodeView() {
            if (!hasLoadedSVGs()) return;

            if (state.svgItems.length === 1) {
                performCodeView(0);
            } else {
                showSVGSelectionModal('codeview');
            }
        }

        function performCodeView(index) {
            const item = state.svgItems[index];
            if (!item) return;

            // Generate final SVG through same pipeline
            let finalSVG = generateFinalSVG(item);
            const serializer = new XMLSerializer();
            let svgString = serializer.serializeToString(finalSVG);

            // Apply FM processing if enabled
            if (state.fmCompatible) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');
                if (svg) {
                    processSVGForFileMaker(svg);
                    svgString = serializer.serializeToString(svg);
                }
            }

            // Pretty-print the XML
            const formatted = formatXML(svgString);

            // Show in modal
            const modal = document.getElementById('code-view-modal');
            const content = document.getElementById('code-view-content');
            const title = document.getElementById('code-view-title');

            title.textContent = item.filename + ' - SVG Code';
            content.textContent = formatted;

            modal.classList.add('visible');

            // Close on overlay click
            modal.addEventListener('click', handleCodeViewOverlayClick);
        }

        function hideCodeView() {
            const modal = document.getElementById('code-view-modal');
            modal.classList.remove('visible');
            modal.removeEventListener('click', handleCodeViewOverlayClick);
        }

        function handleCodeViewOverlayClick(e) {
            if (e.target.id === 'code-view-modal') {
                hideCodeView();
            }
        }

        function copyCodeViewContent() {
            const content = document.getElementById('code-view-content');
            if (!content) return;

            const text = content.textContent;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showCodeViewCopyFeedback();
                }).catch(() => {
                    fallbackCopy(text);
                    showCodeViewCopyFeedback();
                });
            } else {
                fallbackCopy(text);
                showCodeViewCopyFeedback();
            }
        }

        function showCodeViewCopyFeedback() {
            const btn = document.getElementById('code-view-copy-btn');
            if (!btn) return;
            const original = btn.innerHTML;
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><polyline points="20 6 9 17 4 12" /></svg> Copied!';
            btn.style.background = 'var(--success)';
            btn.style.borderColor = 'var(--success)';
            btn.style.color = 'white';
            setTimeout(() => {
                btn.innerHTML = original;
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.style.color = '';
            }, 1500);
        }

        /**
         * Simple XML pretty-printer
         */
        function formatXML(xml) {
            let formatted = '';
            let indent = '';
            const tab = '  ';

            // Normalize the XML first
            xml = xml.replace(/>\s*</g, '><');

            xml.split(/(<[^>]+>)/g).forEach(node => {
                if (!node.trim()) return;

                if (node.match(/^<\/\w/)) {
                    // Closing tag - decrease indent
                    indent = indent.substring(tab.length);
                    formatted += indent + node + '\n';
                } else if (node.match(/^<\w[^>]*[^\/]>$/)) {
                    // Opening tag - add then increase indent
                    formatted += indent + node + '\n';
                    indent += tab;
                } else {
                    // Self-closing tag or text
                    formatted += indent + node + '\n';
                }
            });

            return formatted.trim();
        }

        // ============================================
        // SVG Selection Modal (shared for Copy & Code View)
        // ============================================

        let svgSelectionAction = null;

        function showSVGSelectionModal(action) {
            svgSelectionAction = action;
            const modal = document.getElementById('svg-selection-modal');
            const title = document.getElementById('svg-selection-title');
            const message = document.getElementById('svg-selection-message');
            const list = document.getElementById('svg-selection-list');

            title.textContent = action === 'copy' ? 'Copy SVG' : 'View SVG Code';
            message.textContent = action === 'copy' ? 'Select an SVG to copy:' : 'Select an SVG to view:';

            // Build list
            list.innerHTML = '';
            state.svgItems.forEach((item, index) => {
                const li = document.createElement('li');
                const btn = document.createElement('button');
                btn.className = 'svg-selection-item';
                btn.innerHTML = `<span class="item-index">${index + 1}</span> ${escapeHTML(item.filename)}`;
                btn.addEventListener('click', () => {
                    hideSVGSelectionModal();
                    handleSVGSelection(index, action);
                });
                li.appendChild(btn);
                list.appendChild(li);
            });

            modal.classList.add('visible');

            // Close on overlay click
            modal.addEventListener('click', handleSelectionOverlayClick);
            document.addEventListener('keydown', handleSelectionEscape);
        }

        function hideSVGSelectionModal() {
            const modal = document.getElementById('svg-selection-modal');
            modal.classList.remove('visible');
            svgSelectionAction = null;
            modal.removeEventListener('click', handleSelectionOverlayClick);
            document.removeEventListener('keydown', handleSelectionEscape);
        }

        function handleSVGSelection(index, action) {
            if (action === 'copy') {
                performCopySVG(index);
            } else if (action === 'codeview') {
                performCodeView(index);
            }
        }

        function handleSelectionOverlayClick(e) {
            if (e.target.id === 'svg-selection-modal') {
                hideSVGSelectionModal();
            }
        }

        function handleSelectionEscape(e) {
            if (e.key === 'Escape') {
                hideSVGSelectionModal();
            }
        }

        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // ============================================
        // Drag to Reorder SVGs
        // ============================================

        let dragSourceIndex = null;

        function handleTileDragStart(e) {
            const tile = e.currentTarget;
            dragSourceIndex = parseInt(tile.dataset.index);
            tile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', dragSourceIndex.toString());
        }

        function handleTileDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            // Clean up all drag-over states
            document.querySelectorAll('.preview-tile.drag-over-tile').forEach(t => {
                t.classList.remove('drag-over-tile');
            });
            dragSourceIndex = null;
        }

        function handleTileDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const tile = e.currentTarget;
            const targetIndex = parseInt(tile.dataset.index);
            if (targetIndex !== dragSourceIndex) {
                tile.classList.add('drag-over-tile');
            }
        }

        function handleTileDragLeave(e) {
            e.currentTarget.classList.remove('drag-over-tile');
        }

        function handleTileDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            const tile = e.currentTarget;
            tile.classList.remove('drag-over-tile');

            const targetIndex = parseInt(tile.dataset.index);
            if (dragSourceIndex === null || dragSourceIndex === targetIndex) return;

            // Save state for undo
            pushToHistory();

            // Reorder the array
            const [moved] = state.svgItems.splice(dragSourceIndex, 1);
            state.svgItems.splice(targetIndex, 0, moved);

            // Re-render
            renderPreview();
        }

        // ============================================
        // Persistent Preferences (localStorage)
        // ============================================

        const PREFS_KEY = 'elemental-svg-editor-prefs';

        function savePreferences() {
            try {
                const prefs = {
                    theme: state.theme,
                    accentColor: state.accentColor,
                    fmCompatible: state.fmCompatible,
                    fmDynamicFill: state.fmDynamicFill,
                    previewBg: state.previewBg,
                    previewBgCustomColor: state.previewBgCustomColor
                };
                localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
            } catch (e) {
                // localStorage may be unavailable (e.g., in some iframe contexts)
            }
        }

        function loadPreferences() {
            try {
                const stored = localStorage.getItem(PREFS_KEY);
                if (!stored) return null;
                return JSON.parse(stored);
            } catch (e) {
                return null;
            }
        }

        // ============================================
        // Preview Filename Display
        // ============================================

        function updatePreviewFilename() {
            const el = document.getElementById('preview-filename');
            if (!el) return;

            if (state.svgItems.length === 1) {
                el.textContent = ' \u2014 ' + state.svgItems[0].filename;
                el.title = state.svgItems[0].filename;
            } else {
                el.textContent = '';
                el.title = '';
            }
        }

        // ============================================
        // Global API
        // ============================================

        // Expose functions globally for external access
        window.initEditor = initEditor;
        window.loadSVG = loadSVG;
        window.loadSVGFromString = loadSVGFromString;
        window.loadSVGItems = loadSVGItems;
        window.saveSVG = saveSVG;
        window.setTheme = setTheme;
        window.toggleTheme = toggleTheme;
        window.getState = () => state;
        window.undo = undo;
        window.redo = redo;
        window.triggerFileLoad = triggerFileLoad;
        window.handleFileSelect = handleFileSelect;
        window.hasLoadedSVGs = hasLoadedSVGs;
        window.clearAllSVGs = clearAllSVGs;
        window.downloadSVGs = downloadSVGs;
        window.downloadFiles = downloadFiles;
        window.updateSaveButton = updateSaveButton;
        window.setOutputFormat = setOutputFormat;
        window.setOutputSize = setOutputSize;
        window.svgToPng = svgToPng;
        window.copySVGToClipboard = copySVGToClipboard;
        window.showCodeView = showCodeView;
        window.hideCodeView = hideCodeView;
        window.removeSVGItem = removeSVGItem;
        window.setPreviewBg = setPreviewBg;
        window.togglePreviewBgDropdown = togglePreviewBgDropdown;
        window.updatePreviewBgCustomColor = updatePreviewBgCustomColor;
        window.copyCodeViewContent = copyCodeViewContent;
        window.hideSVGSelectionModal = hideSVGSelectionModal;
        window.handlePasteButton = handlePasteButton;
        window.restoreFromReport = restoreFromReport;
        window.showIssueReport = showIssueReport;
        window.hideIssueReport = hideIssueReport;
        window.submitIssueReport = submitIssueReport;

        // Auto-initialize with defaults when DOM is ready
        var _usageTracked = false;
        function sendUsageTracking() {
            if (_usageTracked) return;
            _usageTracked = true;

            try {
                var last = localStorage.getItem('elemental_tracked');
                if (last && (Date.now() - parseInt(last, 10)) < 1800000) return; // once per 30min
            } catch (e) { /* storage blocked in iframe context  continue, variable guard still prevents double-fire within page load */ }

            const ua = navigator.userAgent;
            let browserName = 'Unknown', browserVersion = '';
            if (ua.match(/edg\//i)) { browserName = 'Edge'; browserVersion = (ua.match(/edg\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/opr\//i) || ua.match(/opera/i)) { browserName = 'Opera'; browserVersion = (ua.match(/(?:opr|opera)\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/chrome/i) && !ua.match(/edg/i)) { browserName = 'Chrome'; browserVersion = (ua.match(/chrome\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/safari/i) && !ua.match(/chrome/i)) { browserName = 'Safari'; browserVersion = (ua.match(/version\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/firefox/i)) { browserName = 'Firefox'; browserVersion = (ua.match(/firefox\/([\d.]+)/i) || [])[1]; }

            const payload = {
                timestamp: new Date().toISOString(),
                userAgent: ua,
                browser: browserName + (browserVersion ? ' ' + browserVersion : ''),
                platform: navigator.platform || '',
                language: navigator.language || '',
                screenWidth: screen.width,
                screenHeight: screen.height,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || '',
                referrer: document.referrer || '',
                colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light',
                touchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
                connectionType: (navigator.connection && navigator.connection.effectiveType) || ''
            };

            fetch(_proxyBase + '/usage', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(() => {
                try { localStorage.setItem('elemental_tracked', '' + Date.now()); } catch (e) { }
            }).catch(() => { });
        }

        function adjustEditorHeight() {
            const container = document.getElementById('editor-container');
            const rect = container.getBoundingClientRect();
            const topOffset = rect.top + window.scrollY;
            if (topOffset > 0) {
                container.style.height = 'calc(100dvh - ' + topOffset + 'px)';
            }
        }

        // ============================================
        // Custom Color Picker Popup
        // ============================================
        var colorPickerPopup = (function () {
            var popup, satCanvas, satCtx, hueCanvas, hueCtx;
            var hsv = { h: 0, s: 0, v: 0 };
            var currentBinding = null;
            var dragging = null; // 'sat' | 'hue' | null

            function init() {
                popup = document.createElement('div');
                popup.className = 'cp-popup';
                var presetColors = [
                    // Row 1: grayscale
                    '#000000','#515151','#7b7b7b','#a5a5a5','#d2d2d2','#ffffff',
                    // Row 2: saturated
                    '#ff2600','#ff9300','#fffb00','#00f900','#00fdff','#0432ff','#9b00ff','#ff40ff',
                    // Row 3: warm tones
                    '#ff7e79','#ffd479','#fffc79','#d4fb79','#73fcd6','#73fdff','#76d6ff','#7a81ff',
                    // Row 4: cool/pastel tones
                    '#ff48b0','#d783ff','#c0c0c0','#808080','#404040','#1a1a1a','#592800','#7b4000'
                ];
                var swatchHtml = '<div class="cp-swatches">';
                for (var i = 0; i < presetColors.length; i++) {
                    swatchHtml += '<button class="cp-swatch" data-color="' + presetColors[i] + '" style="background:' + presetColors[i] + '"></button>';
                }
                swatchHtml += '</div>';

                popup.innerHTML =
                    '<canvas class="cp-sat-canvas" width="200" height="150"></canvas>' +
                    '<canvas class="cp-hue-canvas" width="200" height="14"></canvas>' +
                    swatchHtml;
                document.body.appendChild(popup);

                popup.querySelector('.cp-swatches').addEventListener('click', function (e) {
                    var btn = e.target.closest('.cp-swatch');
                    if (!btn) return;
                    var hex = btn.dataset.color;
                    hsv = hexToHSV(hex);
                    applyColor(true);
                    currentBinding = null;
                    popup.classList.remove('open');
                });

                satCanvas = popup.querySelector('.cp-sat-canvas');
                hueCanvas = popup.querySelector('.cp-hue-canvas');
                satCtx = satCanvas.getContext('2d');
                hueCtx = hueCanvas.getContext('2d');

                satCanvas.addEventListener('pointerdown', function (e) {
                    dragging = 'sat';
                    satCanvas.setPointerCapture(e.pointerId);
                    pickSat(e);
                });
                satCanvas.addEventListener('pointermove', function (e) {
                    if (dragging === 'sat') pickSat(e);
                });
                satCanvas.addEventListener('pointerup', function () {
                    if (dragging === 'sat') { dragging = null; applyColor(true); }
                });

                hueCanvas.addEventListener('pointerdown', function (e) {
                    dragging = 'hue';
                    hueCanvas.setPointerCapture(e.pointerId);
                    pickHue(e);
                });
                hueCanvas.addEventListener('pointermove', function (e) {
                    if (dragging === 'hue') pickHue(e);
                });
                hueCanvas.addEventListener('pointerup', function () {
                    if (dragging === 'hue') { dragging = null; applyColor(true); }
                });

                document.addEventListener('keydown', function (e) {
                    if (e.key === 'Escape' && popup.classList.contains('open')) {
                        e.stopPropagation();
                        close();
                    }
                });

                document.addEventListener('pointerdown', function (e) {
                    if (!popup.classList.contains('open')) return;
                    if (popup.contains(e.target)) return;
                    // Allow click on the swatch that opened us to act as toggle
                    if (currentBinding) {
                        var swatch = document.getElementById(currentBinding.colorId).parentElement;
                        if (swatch.contains(e.target)) return;
                    }
                    close();
                });
            }

            function open(binding, anchorEl) {
                if (currentBinding === binding && popup.classList.contains('open')) {
                    close();
                    return;
                }
                currentBinding = binding;
                saveSliderState();

                var hex = document.getElementById(binding.hexId).value;
                if (!isValidColor(hex)) hex = '#000000';
                hex = normalizeHex(hex);
                // Ensure full 7-char hex
                if (hex.length === 4) {
                    hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                hsv = hexToHSV(hex);

                // Show off-screen to measure, then position
                popup.style.left = '-9999px';
                popup.style.top = '-9999px';
                popup.classList.add('open');

                var popupH = popup.offsetHeight;
                var rect = anchorEl.getBoundingClientRect();
                var left = Math.max(0, Math.min(rect.left, window.innerWidth - 230));
                var spaceBelow = window.innerHeight - rect.bottom - 6;
                var spaceAbove = rect.top - 6;

                var top;
                if (spaceBelow >= popupH) {
                    top = rect.bottom + 6;
                } else if (spaceAbove >= popupH) {
                    top = rect.top - popupH - 6;
                } else {
                    // Neither fits fully  pick whichever side has more room
                    top = spaceBelow >= spaceAbove ? rect.bottom + 6 : rect.top - popupH - 6;
                }

                popup.style.left = left + 'px';
                popup.style.top = top + 'px';
                drawSatPanel();
                drawHueBar();
            }

            function close() {
                if (!popup.classList.contains('open')) return;
                popup.classList.remove('open');
                if (dragging) {
                    dragging = null;
                    applyColor(true);
                } else {
                    commitColor();
                }
                currentBinding = null;
            }

            function pickSat(e) {
                var r = satCanvas.getBoundingClientRect();
                var x = Math.max(0, Math.min(e.clientX - r.left, r.width));
                var y = Math.max(0, Math.min(e.clientY - r.top, r.height));
                hsv.s = x / r.width;
                hsv.v = 1 - y / r.height;
                drawSatPanel();
                applyColor(false);
            }

            function pickHue(e) {
                var r = hueCanvas.getBoundingClientRect();
                var x = Math.max(0, Math.min(e.clientX - r.left, r.width));
                hsv.h = (x / r.width) * 360;
                drawSatPanel();
                drawHueBar();
                applyColor(false);
            }

            function applyColor(commit) {
                var hex = hsvToHex(hsv.h, hsv.s, hsv.v);
                if (currentBinding) {
                    currentBinding.updateFn(hex, commit);
                }
            }

            function commitColor() {
                if (currentBinding) {
                    var hex = hsvToHex(hsv.h, hsv.s, hsv.v);
                    currentBinding.updateFn(hex, true);
                }
            }

            function drawSatPanel() {
                var w = satCanvas.width, h = satCanvas.height;
                // Base hue color
                var hueColor = hsvToHex(hsv.h, 1, 1);

                // White-to-hue gradient (left to right)
                var gradH = satCtx.createLinearGradient(0, 0, w, 0);
                gradH.addColorStop(0, '#ffffff');
                gradH.addColorStop(1, hueColor);
                satCtx.fillStyle = gradH;
                satCtx.fillRect(0, 0, w, h);

                // Black gradient (top to bottom)
                var gradV = satCtx.createLinearGradient(0, 0, 0, h);
                gradV.addColorStop(0, 'rgba(0,0,0,0)');
                gradV.addColorStop(1, 'rgba(0,0,0,1)');
                satCtx.fillStyle = gradV;
                satCtx.fillRect(0, 0, w, h);

                // Thumb
                var tx = hsv.s * w, ty = (1 - hsv.v) * h;
                satCtx.beginPath();
                satCtx.arc(tx, ty, 6, 0, Math.PI * 2);
                satCtx.strokeStyle = '#ffffff';
                satCtx.lineWidth = 2;
                satCtx.stroke();
                satCtx.beginPath();
                satCtx.arc(tx, ty, 5, 0, Math.PI * 2);
                satCtx.strokeStyle = '#000000';
                satCtx.lineWidth = 1;
                satCtx.stroke();
            }

            function drawHueBar() {
                var w = hueCanvas.width, h = hueCanvas.height;
                var grad = hueCtx.createLinearGradient(0, 0, w, 0);
                for (var i = 0; i <= 6; i++) {
                    grad.addColorStop(i / 6, hsvToHex(i * 60, 1, 1));
                }
                hueCtx.fillStyle = grad;
                hueCtx.fillRect(0, 0, w, h);

                // Thumb
                var tx = (hsv.h / 360) * w;
                hueCtx.beginPath();
                hueCtx.rect(tx - 3, 0, 6, h);
                hueCtx.strokeStyle = '#ffffff';
                hueCtx.lineWidth = 2;
                hueCtx.stroke();
                hueCtx.beginPath();
                hueCtx.rect(tx - 2, 1, 4, h - 2);
                hueCtx.strokeStyle = '#000000';
                hueCtx.lineWidth = 1;
                hueCtx.stroke();
            }

            function syncFromHex(hex) {
                if (!popup.classList.contains('open')) return;
                if (!isValidColor(hex)) return;
                hex = normalizeHex(hex);
                if (hex.length === 4) {
                    hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                hsv = hexToHSV(hex);
                drawSatPanel();
                drawHueBar();
            }

            function isOpenFor(binding) {
                return popup.classList.contains('open') && currentBinding === binding;
            }

            return { init: init, open: open, close: close, syncFromHex: syncFromHex, isOpenFor: isOpenFor };
        })();

        document.addEventListener('DOMContentLoaded', function () {
            initEditor();
            sendUsageTracking();
            // Adjust height after a short delay to let parent page (e.g. Squarespace) finish layout
            setTimeout(adjustEditorHeight, 100);
            window.addEventListener('resize', adjustEditorHeight);

            // Custom color picker popup (replaces native input[type="color"])
            colorPickerPopup.init();

            var cpBindings = [
                { colorId: 'fill-color', hexId: 'fill-hex', updateFn: updateFillColor },
                { colorId: 'stroke-color', hexId: 'stroke-hex', updateFn: updateStrokeColor },
                { colorId: 'bg-color', hexId: 'bg-hex', updateFn: updateBgColor }
            ];
            cpBindings.forEach(function (b) {
                var swatch = document.getElementById(b.colorId).parentElement;
                swatch.addEventListener('click', function () {
                    colorPickerPopup.open(b, swatch);
                });
                document.getElementById(b.hexId).addEventListener('change', function () {
                    if (colorPickerPopup.isOpenFor(b)) {
                        colorPickerPopup.syncFromHex(this.value);
                    }
                });
            });
        });
    </script>
</body>

</html>