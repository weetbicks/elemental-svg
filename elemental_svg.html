<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elemental SVG Editor for FileMaker</title>
    <meta name="description"
        content="Free browser-based SVG editor designed for FileMaker. Import, preview, convert and optimise SVG icons for use in FileMaker Pro button icons and layouts.">
    <link rel="canonical" href="https://www.elemental-svg.com/">
    <!-- Open Graph -->
    <meta property="og:title" content="Elemental SVG Editor for FileMaker">
    <meta property="og:description"
        content="Free browser-based SVG editor designed for FileMaker. Import, preview, convert and optimise SVG icons for use in FileMaker Pro button icons and layouts.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.elemental-svg.com/">
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Elemental SVG Editor for FileMaker">
    <meta name="twitter:description"
        content="Free browser-based SVG editor designed for FileMaker. Import, preview, convert and optimise SVG icons for use in FileMaker Pro button icons and layouts.">
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "Elemental SVG Editor",
        "description": "Free browser-based SVG editor designed for FileMaker. Import, preview, convert and optimise SVG icons for use in FileMaker Pro button icons and layouts.",
        "url": "https://www.elemental-svg.com/",
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Any",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>
    <style>
        :root {
            /* Dark theme (default) */
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --accent: #f97316;
            --accent-hover: #fb923c;
            --accent-rgb: 249, 115, 22;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --border-color: #2a2a4a;
            --success: #4ade80;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            --checker-color: #252540;
        }

        [data-theme="light"] {
            --bg-primary: #f5f5f7;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8e8ed;
            --accent: #ea580c;
            --accent-hover: #c2410c;
            --accent-rgb: 234, 88, 12;
            --text-primary: #1a1a2e;
            --text-secondary: #5a5a6e;
            --border-color: #d1d1d6;
            --success: #22c55e;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --checker-color: #e0e0e5;
        }

        /* Accent color variants - Dark mode */
        [data-theme="dark"][data-accent="red"] {
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --accent-rgb: 233, 69, 96;
        }

        [data-theme="dark"][data-accent="blue"] {
            --accent: #3b82f6;
            --accent-hover: #60a5fa;
            --accent-rgb: 59, 130, 246;
        }

        [data-theme="dark"][data-accent="green"] {
            --accent: #22c55e;
            --accent-hover: #4ade80;
            --accent-rgb: 34, 197, 94;
        }

        [data-theme="dark"][data-accent="purple"] {
            --accent: #8b5cf6;
            --accent-hover: #a78bfa;
            --accent-rgb: 139, 92, 246;
        }

        [data-theme="dark"][data-accent="pink"] {
            --accent: #ec4899;
            --accent-hover: #f472b6;
            --accent-rgb: 236, 72, 153;
        }

        /* Accent color variants - Light mode */
        [data-theme="light"][data-accent="red"] {
            --accent: #e94560;
            --accent-hover: #d63850;
            --accent-rgb: 233, 69, 96;
        }

        [data-theme="light"][data-accent="blue"] {
            --accent: #2563eb;
            --accent-hover: #1d4ed8;
            --accent-rgb: 37, 99, 235;
        }

        [data-theme="light"][data-accent="green"] {
            --accent: #16a34a;
            --accent-hover: #15803d;
            --accent-rgb: 22, 163, 74;
        }

        [data-theme="light"][data-accent="purple"] {
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --accent-rgb: 124, 58, 237;
        }

        [data-theme="light"][data-accent="pink"] {
            --accent: #db2777;
            --accent-hover: #be185d;
            --accent-rgb: 219, 39, 119;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100%;
        }

        /* Hidden state before initialization */
        .editor-container {
            display: none;
        }

        .editor-container.initialized {
            /* Reset inherited styles from parent pages (e.g., Squarespace) */
            /* Using explicit resets instead of 'all: initial' to preserve CSS variable inheritance */
            margin: 0;
            padding: 16px;
            border: none;
            text-decoration: none;
            text-align: left;
            text-indent: 0;
            text-transform: none;
            letter-spacing: normal;
            word-spacing: normal;
            line-height: normal;
            font-style: normal;
            font-variant: normal;
            font-size: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            /* Explicit background to prevent parent page bleed-through */
            background-color: var(--bg-primary);
            color: var(--text-primary);
            /* Layout */
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            /* Dynamic viewport height for iOS */
            gap: 16px;
            box-sizing: border-box;
            /* Rounded corners for embedded appearance */
            border-radius: 12px;
            overflow: hidden;
            /* Prevent scroll chaining to parent page */
            overscroll-behavior: contain;
        }

        /* iOS safe area support */
        @supports (padding: env(safe-area-inset-bottom)) {
            .editor-container.initialized {
                padding-bottom: calc(16px + env(safe-area-inset-bottom));
            }
        }

        /* Scoped reset for child elements to prevent parent page styles (e.g., Squarespace) leaking in */
        .editor-container.initialized *,
        .editor-container.initialized *::before,
        .editor-container.initialized *::after {
            box-sizing: border-box;
        }

        /* Title Bar */
        .title-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .title-bar-icon {
            height: 22px;
            width: 22px;
            flex-shrink: 0;
        }

        .title-bar-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Header */
        .header {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-primary);
        }

        .header-branding {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .header-icon {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
            white-space: nowrap;
        }

        .header-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .header-row-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-row-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .ib-mode-toggle .increment-btn {
            min-width: 90px;
            text-align: center;
            padding: 10px 16px;
            font-size: 12px;
            font-weight: 600;
        }

        .header-row-right {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .btn-coffee {
            background: #28a745;
            color: white;
            border: none;
            text-decoration: none;
            font-size: 12px;
            font-weight: 600;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            flex-shrink: 0;
            width: 260px;
            box-sizing: border-box;
        }

        .btn-coffee:hover {
            background: #218838;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .btn-coffee .coffee-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .btn-coffee .coffee-steam {
            transform-origin: center bottom;
            animation: steam 2s ease-in-out infinite;
        }

        .btn-coffee .coffee-steam:nth-child(2) {
            animation-delay: 0.4s;
        }

        .btn-coffee .coffee-steam:nth-child(3) {
            animation-delay: 0.8s;
        }

        @keyframes steam {

            0%,
            100% {
                opacity: 0.3;
                transform: translateY(0);
            }

            50% {
                opacity: 1;
                transform: translateY(-2px);
            }
        }

        .auto-convert-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .auto-convert-toggle:hover {
            background: var(--bg-primary);
        }

        .auto-convert-toggle .toggle-switch {
            transform: scale(0.75);
            margin: -4px 0;
        }

        .auto-convert-toggle .toggle-slider {
            border: 1px solid var(--border-color);
        }

        /* Theme Toggle Container */
        .theme-container {
            position: relative;
            display: flex;
            align-items: stretch;
        }

        .btn.theme-toggle {
            white-space: nowrap;
            border-radius: 6px 0 0 6px;
            border-right: none;
        }

        .theme-toggle .icon-sun,
        .theme-toggle .icon-moon,
        .theme-toggle .label-light,
        .theme-toggle .label-dark {
            display: none;
        }

        [data-theme="dark"] .theme-toggle .icon-sun,
        [data-theme="dark"] .theme-toggle .label-light {
            display: block;
        }

        [data-theme="light"] .theme-toggle .icon-moon,
        [data-theme="light"] .theme-toggle .label-dark {
            display: block;
        }

        .theme-dropdown-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-left: none;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-top-right-radius: 6px;
            border-bottom-right-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            transition: background 0.2s;
        }

        .theme-dropdown-toggle:hover {
            background: var(--bg-primary);
        }

        .theme-dropdown-toggle svg {
            width: 12px;
            height: 12px;
            transition: transform 0.2s;
        }

        .theme-container.open .theme-dropdown-toggle svg {
            transform: rotate(180deg);
        }

        /* Theme Dropdown Menu */
        .theme-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            min-width: 140px;
        }

        .theme-container.open .theme-dropdown {
            display: block;
        }

        .theme-dropdown-label {
            font-size: 10px;
            text-transform: uppercase;
            color: var(--text-secondary);
            padding: 4px 8px;
            letter-spacing: 0.5px;
        }

        .accent-colors {
            display: flex;
            gap: 6px;
            padding: 6px 8px;
        }

        .accent-swatch {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
            position: relative;
        }

        .accent-swatch:hover {
            transform: scale(1.15);
        }

        .accent-swatch.active {
            border-color: var(--text-primary);
        }

        .accent-swatch.active::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        .accent-swatch[data-color="red"] {
            background: #e94560;
        }

        .accent-swatch[data-color="blue"] {
            background: #3b82f6;
        }

        .accent-swatch[data-color="green"] {
            background: #22c55e;
        }

        .accent-swatch[data-color="purple"] {
            background: #8b5cf6;
        }

        .accent-swatch[data-color="pink"] {
            background: #ec4899;
        }

        .accent-swatch[data-color="orange"] {
            background: #f97316;
        }

        /* Main Content Area */
        .main-content {
            display: flex;
            flex: 1;
            gap: 16px;
            min-height: 0;
            background-color: var(--bg-primary);
        }

        /* Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .preview-header .btn {
            padding: 6px 12px;
            font-size: 11px;
        }

        .preview-header .btn-secondary {
            background: var(--bg-secondary);
        }

        .preview-header .auto-convert-toggle {
            padding: 6px 10px;
            font-size: 11px;
            background: none;
            border: none;
        }

        .preview-header .auto-convert-toggle .toggle-slider {
            background: var(--bg-secondary);
        }


        .preview-filename {
            font-size: 14px;
            font-weight: 400;
            color: var(--text-secondary);
            opacity: 0.7;
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .zoom-btn:hover:not(:disabled) {
            background: var(--accent);
            color: white;
        }

        .zoom-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .ib-select-toggle-btn {
            width: 80px;
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            text-align: center;
        }

        .history-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-right: 12px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.2s ease;
        }

        .modal-overlay.visible .modal-card {
            transform: scale(1) translateY(0);
        }

        .modal-icon {
            width: 48px;
            height: 48px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
        }

        .modal-icon svg {
            width: 24px;
            height: 24px;
            color: var(--accent);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .modal-message {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 24px;
            white-space: pre-line;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .modal-btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .modal-btn-cancel:hover {
            background: var(--bg-primary);
        }

        .modal-btn-confirm {
            background: var(--accent);
            color: white;
        }

        .modal-btn-confirm:hover {
            background: var(--accent-hover);
        }

        /* About Button & Modal */
        .elemental-about-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 600;
            padding: 5px 10px;
            border-radius: 6px;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .elemental-about-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent);
        }

        [data-theme="light"] .elemental-about-btn {
            background: #ffffff;
        }

        .elemental-about-btn svg {
            width: 16px;
            height: 16px;
        }

        .about-description {
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-secondary);
            text-align: left;
        }

        .about-description p {
            margin: 0 0 10px;
        }

        .about-description p:last-child {
            margin-bottom: 0;
        }

        .about-description strong {
            color: var(--text-primary);
        }

        .about-scrollable {
            max-height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 12px;
        }

        .about-product-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 10px 12px;
            border-radius: 10px;
            background: var(--bg-tertiary);
            text-decoration: none;
            color: inherit;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .about-product-item:hover {
            border-color: var(--accent);
            background: var(--bg-primary);
        }

        .about-product-icon {
            width: 64px;
            height: 64px;
            border-radius: 10px;
            object-fit: contain;
            flex-shrink: 0;
        }

        .about-product-info {
            flex: 1;
            min-width: 0;
        }

        .about-product-name {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .about-product-desc {
            font-size: 12px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .zoom-level {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: center;
        }

        .preview-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            position: relative;
            overflow: hidden;
            transition: background 0.2s ease;
        }

        /* Drag-over visual cue */
        .preview-container.drag-over {
            background: rgba(var(--accent-rgb), 0.1);
        }

        .preview-container.drag-over::after {
            content: '';
            position: absolute;
            inset: 12px;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            pointer-events: none;
            animation: pulse-border 1.5s ease-in-out infinite;
        }

        @keyframes pulse-border {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }
        }

        .preview-bg {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(45deg, var(--checker-color) 25%, transparent 25%),
                linear-gradient(-45deg, var(--checker-color) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, var(--checker-color) 75%),
                linear-gradient(-45deg, transparent 75%, var(--checker-color) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            opacity: 0.5;
        }

        .preview-wrapper {
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        #preview-svg {
            max-width: 100%;
            max-height: 100%;
            transition: transform 0.3s ease;
        }

        /* When showing grid, preview-svg needs to fill the space */
        #preview-svg.grid-mode {
            position: absolute;
            inset: 0;
            max-width: none;
            max-height: none;
            width: 100%;
            height: 100%;
        }

        /* Multi-SVG Preview Grid */
        .preview-grid {
            --tile-size: 100px;
            /* Base tile size, modified by zoom */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(calc(var(--tile-size) + 16px), 1fr));
            gap: 12px;
            padding: 16px;
            overflow-y: auto;
            width: 100%;
            height: 100%;
            align-content: start;
            position: absolute;
            inset: 0;
        }

        .preview-tile {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: fit-content;
        }

        .colored-bg-active .preview-tile {
            background: transparent;
        }

        .colored-bg-active .tile-filename {
            color: var(--preview-text-color, var(--text-secondary));
        }

        .colored-bg-active .preview-filename {
            color: var(--preview-text-color, var(--text-secondary));
        }

        .tile-svg {
            width: var(--tile-size);
            height: var(--tile-size);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tile-svg svg {
            max-width: 100%;
            max-height: 100%;
        }

        .tile-filename {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 6px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            max-width: 100%;
            text-align: center;
        }

        /* Controls Panel */
        .controls-panel {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            background-color: var(--bg-primary);
            padding-right: 2px;
        }

        .controls-panel.hidden {
            display: none;
        }

        .control-section {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 12px;
            box-shadow: var(--shadow);
        }

        .control-section h3 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        /* Transform Controls (compact inline style) */
        .transform-grid {
            display: flex;
            gap: 6px;
            margin-top: 10px;
        }

        .transform-btn {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
        }

        .transform-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .transform-btn:active {
            transform: translateY(0);
        }

        .transform-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Rotation Controls */
        .rotation-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rotation-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }

        .rotation-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .rotation-btn svg {
            width: 16px;
            height: 16px;
        }

        .rotation-value {
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            padding: 6px;
            background: var(--bg-primary);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
        }

        .rotation-increment {
            margin-top: 10px;
        }

        .rotation-increment label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .increment-options {
            display: flex;
            gap: 4px;
        }

        .increment-btn {
            flex: 1;
            padding: 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .increment-btn:hover {
            background: var(--bg-tertiary);
        }

        .increment-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* Color Controls */
        .color-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .color-row:last-child {
            margin-bottom: 0;
        }

        .color-row label {
            flex: 1;
            font-size: 11px;
            color: var(--text-primary);
        }

        .color-picker-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .color-preview input[type="color"] {
            display: none;
        }

        .cp-popup {
            position: fixed;
            z-index: 1001;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            box-shadow: var(--shadow);
            display: none;
            flex-direction: column;
            gap: 8px;
            width: 220px;
        }

        .cp-popup.open {
            display: flex;
        }

        .cp-sat-canvas {
            width: 200px;
            height: 150px;
            border-radius: 4px;
            cursor: crosshair;
        }

        .cp-hue-canvas {
            width: 200px;
            height: 14px;
            border-radius: 4px;
            cursor: crosshair;
        }

        .cp-swatches {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .cp-swatch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(128, 128, 128, 0.3);
            cursor: pointer;
            padding: 0;
        }

        .cp-swatch:hover {
            transform: scale(1.2);
        }

        .color-hex {
            width: 75px;
            padding: 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 11px;
            font-family: monospace;
        }

        .color-hex:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Background Controls */
        .bg-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .bg-toggle span {
            font-size: 11px;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: var(--bg-primary);
            border-radius: 24px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: var(--text-secondary);
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked+.toggle-slider {
            background: var(--accent);
        }

        .toggle-switch input:checked+.toggle-slider:before {
            transform: translateX(20px);
            background: white;
        }

        .bg-options {
            display: none;
        }

        .bg-options.visible {
            display: block;
        }

        .shape-options {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .shape-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            padding: 8px 6px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .shape-btn:hover,
        .shape-btn.active {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .shape-btn svg {
            width: 18px;
            height: 18px;
        }

        .shape-btn span {
            font-size: 9px;
        }

        .edges-stepper {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
        }

        .edges-stepper button {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }

        .edges-stepper button:hover {
            border-color: var(--accent);
        }

        .edges-stepper .edges-value {
            width: 32px;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .edges-stepper .edges-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 2px;
        }

        /* Stroke Controls */
        .stroke-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .stroke-row label {
            width: 70px;
            font-size: 11px;
            color: var(--text-primary);
        }

        .adjustment-row {
            margin-bottom: 10px;
        }

        .adjustment-row label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stroke-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: var(--bg-primary);
            border-radius: 3px;
            outline: none;
        }

        .stroke-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .stroke-value {
            min-width: 35px;
            text-align: right;
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 6px;
        }

        .action-buttons .btn {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        .action-buttons .btn-secondary {
            flex: 0 0 auto;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
        }

        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        /* Update indicator (in header) */
        .update-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            animation: fadeIn 0.3s ease-out;
        }

        .update-indicator-label {
            font-weight: 700;
            color: var(--accent);
        }

        .update-indicator-link {
            color: var(--text-secondary);
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .update-indicator-link:hover {
            color: var(--text-primary);
        }

        .release-notes-link {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 11px;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .release-notes-link:hover {
            color: var(--text-primary);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Update result popup banner */
        .update-banner {
            position: fixed;
            bottom: 20px;
            left: 20px;
            max-width: 360px;
            background: var(--bg-secondary);
            border: 1px solid var(--accent);
            border-radius: 10px;
            padding: 16px 40px 16px 16px;
            z-index: 10000;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
            animation: slideUp 0.3s ease-out;
            font-family: inherit;
            color: var(--text-primary);
        }

        .update-banner-title {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .update-banner-body {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .update-banner-dismiss {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 4px;
        }

        .update-banner-dismiss:hover {
            color: var(--text-primary);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Release Notes Modal */
        .release-notes-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 540px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.2s ease;
        }

        .modal-overlay.visible .release-notes-card {
            transform: scale(1) translateY(0);
        }

        .release-notes-list {
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            margin-bottom: 16px;
        }

        .release-notes-list::-webkit-scrollbar {
            width: 6px;
        }

        .release-notes-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .release-notes-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .release-note-entry {
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .release-note-entry:last-child {
            border-bottom: none;
        }

        .release-note-version {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .release-note-date {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .release-note-body {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            word-wrap: break-word;
        }

        .release-notes-loading,
        .release-notes-error {
            text-align: center;
            padding: 32px 0;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .release-notes-error {
            color: #ef4444;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-primary);
        }

        .btn-secondary:disabled {
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(var(--accent-rgb), 0.4);
        }

        .btn-primary:disabled {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn svg {
            width: 14px;
            height: 14px;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            color: var(--text-secondary);
            text-align: center;
            padding: 40px;
            cursor: pointer;
            border-radius: 12px;
            transition: background 0.2s ease;
            z-index: 2;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .empty-state.hidden {
            display: none;
        }

        .empty-state:hover {
            background: rgba(var(--accent-rgb), 0.1);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            transform: translateZ(0);
        }

        .empty-state:hover svg {
            opacity: 0.8;
        }

        .empty-state p {
            font-size: 14px;
            line-height: 1.5;
        }

        .empty-state .click-hint {
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.7;
        }

        /* Responsive - tablets */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
                overflow: hidden;
            }

            .preview-panel {
                flex: 1;
                min-height: 150px;
            }

            .controls-panel {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                flex: none;
                max-height: 45%;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }

            .control-section {
                flex: 1;
                min-width: 200px;
            }
        }

        /* Extra small screens (phones) */
        @media (max-width: 480px) {
            .editor-container.initialized {
                padding: 8px;
                gap: 8px;
            }

            .header {
                flex-wrap: wrap;
                gap: 8px;
                flex-shrink: 0;
            }

            .controls-panel {
                flex-direction: column;
                max-height: 50%;
                padding-bottom: env(safe-area-inset-bottom, 20px);
            }

            .control-section {
                min-width: 100%;
            }
        }

        /* Size Display */
        .size-info {
            display: flex;
            gap: 16px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .size-info span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .report-issue-btn {
            margin-left: auto;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 600;
            padding: 5px 10px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .report-issue-btn:hover {
            color: var(--text-primary);
            background: var(--bg-primary);
            border-color: #f59e0b;
        }

        [data-theme="light"] .report-issue-btn {
            background: #ffffff;
        }

        .report-issue-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Issue Report Modal */
        .issue-report-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 460px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.2s ease;
        }

        .modal-overlay.visible .issue-report-card {
            transform: scale(1) translateY(0);
        }

        .issue-report-card .modal-icon svg {
            color: var(--accent);
        }

        .issue-report-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .issue-report-field {
            margin-bottom: 12px;
        }

        .issue-report-field label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .issue-report-field input,
        .issue-report-field textarea {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        .issue-report-field input:focus,
        .issue-report-field textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .issue-report-field textarea {
            resize: vertical;
            min-height: 80px;
        }

        .issue-report-field .field-hint {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .issue-report-info {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.4;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 16px;
        }

        /* Padding Control */
        .padding-control {
            margin-top: 8px;
        }

        .padding-control label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .corner-radius-control {
            margin-top: 8px;
        }

        .corner-radius-control label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        /* Collapsible Control Sections */
        .control-section h3 {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }

        .control-section h3 .chevron {
            width: 12px;
            height: 12px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            color: var(--text-secondary);
        }

        .control-section.collapsed h3 .chevron {
            transform: rotate(-90deg);
        }

        .control-section.collapsed h3 {
            margin-bottom: 0;
        }

        .control-section-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease;
            opacity: 1;
        }

        .control-section.collapsed .control-section-content {
            max-height: 0;
            opacity: 0;
        }

        /* Preview Background Toggle */
        .preview-bg-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .preview-bg-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .preview-bg-btn:hover {
            background: var(--accent);
            color: white;
        }

        .preview-bg-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            min-width: 160px;
        }

        .preview-bg-container.open .preview-bg-dropdown {
            display: block;
        }

        .preview-bg-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-primary);
            transition: background 0.15s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .preview-bg-option:hover {
            background: var(--bg-tertiary);
        }

        .preview-bg-option.active {
            color: var(--accent);
        }

        .preview-bg-option .swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .preview-bg-option .swatch.checkerboard {
            background-image:
                linear-gradient(45deg, #808080 25%, transparent 25%),
                linear-gradient(-45deg, #808080 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #808080 75%),
                linear-gradient(-45deg, transparent 75%, #808080 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
        }

        .preview-bg-custom-color {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
        }

        .preview-bg-custom-color input[type="color"] {
            width: 24px;
            height: 24px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
            background: none;
        }

        /* Preview background modes */
        .preview-bg.bg-white {
            background-image: none;
            background-color: #ffffff;
            opacity: 1;
        }

        .preview-bg.bg-black {
            background-image: none;
            background-color: #000000;
            opacity: 1;
        }

        .preview-bg.bg-custom {
            background-image: none;
            opacity: 1;
        }

        /* Remove X Button */
        .preview-tile {
            position: relative;
        }

        .tile-remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 2;
            padding: 0;
        }

        .preview-tile:hover .tile-remove-btn {
            opacity: 1;
        }

        .tile-remove-btn:hover {
            background: var(--accent);
        }

        .single-remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 3;
            padding: 0;
        }

        .preview-container:hover .single-remove-btn {
            opacity: 1;
        }

        .single-remove-btn:hover {
            background: var(--accent);
        }

        /* Tile hover action buttons (copy, view code) */
        .tile-actions {
            position: absolute;
            top: 4px;
            left: 4px;
            display: flex;
            gap: 3px;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 2;
        }

        .preview-tile:hover .tile-actions {
            opacity: 1;
        }

        .tile-action-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .tile-action-btn:hover {
            background: var(--accent);
        }

        .tile-action-btn svg {
            width: 11px;
            height: 11px;
        }

        /* Single-mode hover actions */
        .single-actions {
            position: absolute;
            top: 8px;
            left: 8px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 3;
        }

        .preview-container:hover .single-actions {
            opacity: 1;
        }

        .single-action-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .single-action-btn:hover {
            background: var(--accent);
        }

        .single-action-btn svg {
            width: 13px;
            height: 13px;
        }

        /* Preview toast notification */
        .preview-toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .preview-toast.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Drag Reorder */
        .preview-tile[draggable="true"] {
            cursor: grab;
        }

        .preview-tile[draggable="true"]:active {
            cursor: grabbing;
        }

        .preview-tile.dragging {
            opacity: 0.4;
        }

        .preview-tile.drag-over-tile {
            border: 2px solid var(--accent);
            border-radius: 8px;
        }

        /* Code View Modal */
        .code-view-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .code-view-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .code-view-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.2s ease;
        }

        .code-view-overlay.visible .code-view-card {
            transform: scale(1) translateY(0);
        }

        .code-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .code-view-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .code-view-actions {
            display: flex;
            gap: 8px;
        }

        .code-view-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: background 0.2s;
        }

        .code-view-close:hover {
            background: var(--accent);
            color: white;
        }

        .code-view-pre {
            flex: 1;
            overflow: auto;
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 16px;
            margin: 0;
            font-size: 12px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            color: var(--text-primary);
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-all;
            border: 1px solid var(--border-color);
        }

        /* SVG Selection Modal (shared for Copy & Code View) */
        .svg-selection-list {
            list-style: none;
            padding: 0;
            margin: 0 0 16px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .svg-selection-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
            font-size: 13px;
            color: var(--text-primary);
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .svg-selection-item:hover {
            background: var(--bg-tertiary);
        }

        .svg-selection-item .item-index {
            min-width: 24px;
            height: 24px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        /* Preview header toolbar buttons */
        .preview-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-toolbar-separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
        }

        /* ============================================
           Icon Browser
           ============================================ */
        /* Icon Browser  Mode toggle */
        .ib-mode-toggle {
            display: inline-flex;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: visible;
        }

        .ib-mode-toggle .increment-btn {
            border: none;
            border-radius: 0;
            width: 80px;
            white-space: nowrap;
            position: relative;
        }

        .ib-mode-toggle .increment-btn:first-child {
            border-radius: 5px 0 0 5px;
        }

        .ib-mode-toggle .increment-btn:last-child {
            border-radius: 0 5px 5px 0;
        }

        .ib-mode-toggle .increment-btn .ib-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 4px;
            border-radius: 9px;
            font-size: 10px;
            font-weight: 600;
            line-height: 1;
            background: color-mix(in srgb, var(--accent) 40%, white);
            color: #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        /* Visibility classes for mode switching */
        body:not([data-mode="library"]) .ib-library-only {
            display: none !important;
        }

        body[data-mode="library"] .ib-editor-only {
            display: none !important;
        }

        body[data-mode="library"] .tile-actions,
        body[data-mode="library"] .single-actions,
        body[data-mode="library"] .single-remove-btn {
            display: none !important;
        }

        body[data-mode="library"] .controls-panel {
            overflow-y: hidden;
        }

        #ib-library-sidebar {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
            min-height: 0;
            flex: 1;
        }

        #ib-filter-section {
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        #ib-filter-section>.control-section-content {
            max-height: none;
            overflow: visible;
        }

        /* Icon Browser  Search in preview header */
        .ib-search-wrap {
            position: relative;
            flex: 1;
            min-width: 0;
            max-width: 320px;
        }

        .ib-search-wrap svg {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            color: var(--text-secondary);
            pointer-events: none;
        }

        .ib-search {
            width: 100%;
            padding: 7px 10px 7px 32px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 12px;
            font-family: inherit;
            outline: none;
            transition: border-color 0.15s;
        }

        .ib-search:focus {
            border-color: var(--accent);
        }

        .ib-search::placeholder {
            color: var(--text-secondary);
        }

        .ib-icon-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            transition: all 0.15s;
            padding: 0;
        }

        .ib-icon-btn:hover {
            background: var(--bg-primary);
        }

        .ib-icon-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Icon Browser  Sidebar filter items */
        .ib-sidebar-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 12px;
            color: var(--text-primary);
            cursor: pointer;
            user-select: none;
        }

        .ib-sidebar-item input[type="checkbox"] {
            accent-color: var(--accent);
            margin: 0;
            cursor: pointer;
        }

        .ib-sidebar-count {
            margin-left: auto;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .ib-info-text {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        /* Icon Browser  Grid container (inside drop-zone) */
        #ib-grid-container {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-primary);
        }

        .ib-scroll-container {
            flex: 1;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
        }

        .ib-scroll-spacer {
            width: 100%;
            pointer-events: none;
        }

        .ib-tile-window {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: grid;
            gap: 4px;
            padding: 8px 16px;
            grid-template-columns: repeat(var(--ib-grid-cols, 10), minmax(0, 1fr));
        }

        /* Tiles */
        .ib-tile {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 4px 6px;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: background 0.1s, border-color 0.1s;
            user-select: none;
            -webkit-user-select: none;
        }

        .ib-tile:hover {
            background: var(--bg-tertiary);
        }

        .ib-tile.ib-selected {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
        }

        .ib-tile-icon {
            width: var(--ib-icon-size, 32px);
            height: var(--ib-icon-size, 32px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            flex-shrink: 0;
        }

        .ib-tile-icon svg {
            width: 100%;
            height: 100%;
        }

        .ib-tile-name {
            margin-top: 4px;
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            width: 100%;
        }

        .ib-tile-placeholder {
            width: var(--ib-icon-size, 32px);
            height: var(--ib-icon-size, 32px);
            background: var(--bg-tertiary);
            border-radius: 4px;
        }


        /* Rubber-band selection box */
        .ib-rubber-band {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
            pointer-events: none;
            z-index: 1200;
            display: none;
        }

        /* Loading spinner */
        .ib-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            gap: 12px;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .ib-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: ib-spin 0.8s linear infinite;
        }

        @keyframes ib-spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Empty state */
        .ib-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 13px;
            padding: 40px;
        }

        .ib-empty svg {
            width: 32px;
            height: 32px;
            opacity: 0.5;
        }
    </style>
</head>

<body data-theme="dark" data-mode="editor">
    <div class="editor-container" id="editor-container">
        <header class="header">
            <div class="header-row">
                <div class="header-row-left">
                    <a href="https://www.elemental-fm.com/elemental-svg" target="_blank"
                        title="Elemental SVG Editor for FileMaker"
                        style="display:inline-flex;align-items:center;cursor:pointer;">
                        <svg width="36" height="36" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="m19.26875 13h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-6.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1v6.8c0 1.5-.6375 2.1-2.23125 2.1z"
                                fill="#6282c1" />
                            <path
                                d="m11 13.1v6.8c0 1.5-.6375 2.1-2.23125 2.1h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-6.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1z"
                                fill="#c0cdea" />
                            <path
                                d="m19.26875 22h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-2.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1v2.8c0 1.5-.6375 2.1-2.23125 2.1z"
                                fill="#f7b115" />
                            <path
                                d="m8.76875 9h-4.0375c-1.59375 0-2.23125-.6-2.23125-2.1v-2.8c0-1.5.6375-2.1 2.23125-2.1h4.0375c1.59375 0 2.23125.6 2.23125 2.1v2.8c0 1.5-.6375 2.1-2.23125 2.1z"
                                fill="#ef7a1b" />
                        </svg>
                    </a>
                    <span class="header-title">Elemental SVG</span>
                    <span id="version-area"
                        style="margin-left:8px; display:inline-flex; align-items:center; gap:8px;"></span>
                </div>
                <div class="header-row-center">
                    <div class="ib-mode-toggle" id="ib-mode-toggle">
                        <button class="increment-btn active" id="ib-mode-editor"
                            onclick="ibSetMode('editor')">Editor<span class="ib-badge" id="ib-editor-badge"
                                style="display:none"></span></button>
                        <button class="increment-btn" id="ib-mode-library" onclick="ibSetMode('library')">Icons</button>
                    </div>
                </div>
                <div class="header-row-right">
                    <div class="theme-container" id="theme-container">
                        <button class="btn btn-secondary theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                            <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <circle cx="12" cy="12" r="5" />
                                <line x1="12" y1="1" x2="12" y2="3" />
                                <line x1="12" y1="21" x2="12" y2="23" />
                                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
                                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
                                <line x1="1" y1="12" x2="3" y2="12" />
                                <line x1="21" y1="12" x2="23" y2="12" />
                                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
                                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
                            </svg>
                            <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
                            </svg>
                            <span class="label-light">Light</span>
                            <span class="label-dark">Dark</span>
                        </button>
                        <button class="theme-dropdown-toggle" onclick="toggleThemeDropdown(event)"
                            title="Color options">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9" />
                            </svg>
                        </button>
                        <div class="theme-dropdown">
                            <div class="theme-dropdown-label">Accent Color</div>
                            <div class="accent-colors">
                                <button class="accent-swatch" data-color="red" onclick="setAccentColor('red')"
                                    title="Red"></button>
                                <button class="accent-swatch" data-color="blue" onclick="setAccentColor('blue')"
                                    title="Blue"></button>
                                <button class="accent-swatch" data-color="green" onclick="setAccentColor('green')"
                                    title="Green"></button>
                                <button class="accent-swatch" data-color="purple" onclick="setAccentColor('purple')"
                                    title="Purple"></button>
                                <button class="accent-swatch" data-color="pink" onclick="setAccentColor('pink')"
                                    title="Pink"></button>
                                <button class="accent-swatch active" data-color="orange"
                                    onclick="setAccentColor('orange')" title="Orange"></button>
                            </div>
                        </div>
                    </div>
                </div>
                <a class="btn-coffee" href="https://buy.stripe.com/fZu5kD3oX06mgHJgtC2Fa08" target="_blank" rel="noopener noreferrer">
                    <svg class="coffee-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path class="coffee-steam" d="M6 4c0-1 .5-2 1.5-2s1.5 1 1.5 2" opacity="0.6" />
                        <path class="coffee-steam" d="M10 4c0-1 .5-2 1.5-2s1.5 1 1.5 2" opacity="0.6" />
                        <path class="coffee-steam" d="M14 4c0-1 .5-2 1.5-2s1.5 1 1.5 2" opacity="0.6" />
                        <path d="M4 7h16v6a6 6 0 0 1-6 6H10a6 6 0 0 1-6-6V7z" />
                        <path d="M20 10h1a2 2 0 0 1 0 4h-1" />
                    </svg>
                    Like this? Buy me a Coffee&hellip;
                </a>
            </div>
        </header>

        <div class="main-content">
            <div class="preview-panel">
                <div class="preview-header">
                    <div class="ib-editor-only" style="display:flex;align-items:center;gap:8px;min-width:0">
                        <button class="btn btn-primary" onclick="triggerFileLoad()" title="Load SVG files">
                            <svg viewBox="0 0 1200 1200" fill="currentColor">
                                <path
                                    d="m912.98 167.86v109.88c0 22.219 18.047 40.266 40.266 40.266h109.88zm-426.61 281.72c-26.812-26.812 13.922-67.547 40.734-40.734l175.26 176.58c6.7969 11.531 4.5938 25.734-4.5 34.922l-170.76 170.81c-26.812 26.812-67.547-13.922-40.734-40.734l121.6-121.64h-540.94c-37.922 0-37.922-57.609 0-57.609h540.94zm666.1-123.66 8.9062 20.859v675c0 59.812-49.031 108.75-108.75 108.75l-668.72-0.046875c-59.859 0-108.7-48.891-108.7-108.75v-145.78c0-37.922 57.609-37.922 57.609 0v145.78c0 28.078 23.062 51.141 51.141 51.141h668.76c28.312 0 51.141-23.203 51.141-51.141l-0.046874-646.18h-150.56c-53.766 0-97.875-44.109-97.875-97.875v-150.56h-471.47c-28.266 0-51.141 23.156-51.141 51.141v145.78c0 37.922-57.609 37.922-57.609 0v-145.78c0-59.812 48.984-108.75 108.7-108.75h500.29l20.344 8.4375z"
                                    fill-rule="evenodd" />
                            </svg>
                            Load SVGs
                        </button>
                        <label class="auto-convert-toggle"
                            title="Automatically save converted files when SVGs are loaded">
                            <span class="toggle-switch">
                                <input type="checkbox" id="auto-convert" onchange="toggleAutoConvert(this.checked)">
                                <span class="toggle-slider"></span>
                            </span>
                            Auto Convert
                        </label>
                        <span class="preview-filename" id="preview-filename"></span>
                        <button class="btn btn-secondary" id="clear-btn" onclick="clearAllSVGs()"
                            title="Clear all loaded SVGs" style="display:none;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18" />
                                <line x1="6" y1="6" x2="18" y2="18" />
                            </svg>
                            Clear
                        </button>
                    </div>
                    <div class="ib-library-only" style="display:flex;align-items:center;gap:8px;min-width:0;flex:1">
                        <div class="ib-search-wrap">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8" />
                                <path d="M21 21l-4.35-4.35" />
                            </svg>
                            <input type="text" class="ib-search" id="ib-search" placeholder="Search icons..."
                                autocomplete="off" spellcheck="false">
                        </div>
                        <span id="ib-search-count"
                            style="display:none;font-size:11px;color:var(--text-secondary);white-space:nowrap;flex-shrink:0;font-variant-numeric:tabular-nums;"></span>
                    </div>
                    <div class="zoom-controls">
                        <button class="btn btn-primary ib-library-only ib-preview-btn" id="ib-edit-btn"
                            onclick="ibEditInEditor()" style="display:none;flex-shrink:0">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                style="width:14px;height:14px;">
                                <path d="M12 20h9" />
                                <path d="M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z" />
                            </svg>
                            <span id="ib-edit-btn-label">Open in Editor&hellip;</span>
                        </button>
                        <div class="preview-toolbar-separator ib-library-only" id="ib-edit-separator"
                            style="display:none"></div>
                        <button class="zoom-btn ib-editor-only" id="reset-btn" onclick="resetAll()"
                            title="Reset all changes" style="display:none;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                height="16">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                                <path d="M3 3v5h5" />
                            </svg>
                        </button>
                        <div class="preview-toolbar-separator ib-editor-only" id="reset-separator"
                            style="display:none;"></div>
                        <div class="history-controls ib-editor-only">
                            <button class="zoom-btn" id="undo-btn" onclick="undo()" title="Undo (Ctrl+Z)" disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <path d="M3 7v6h6" />
                                    <path d="M3 13a9 9 0 1 0 2.5-6.3L3 9" />
                                </svg>
                            </button>
                            <button class="zoom-btn" id="redo-btn" onclick="redo()" title="Redo (Ctrl+Shift+Z)"
                                disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <path d="M21 7v6h-6" />
                                    <path d="M21 13a9 9 0 1 1-2.5-6.3L21 9" />
                                </svg>
                            </button>
                        </div>
                        <div class="preview-toolbar ib-editor-only">
                            <button class="zoom-btn" id="paste-btn" onclick="handlePasteButton()"
                                title="Paste SVG from clipboard">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <path
                                        d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
                                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
                                </svg>
                            </button>
                            <button class="zoom-btn" id="code-view-btn" onclick="showCodeView()" title="View SVG Code"
                                disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                    height="16">
                                    <polyline points="16 18 22 12 16 6" />
                                    <polyline points="8 6 2 12 8 18" />
                                </svg>
                            </button>
                            <div class="preview-bg-container" id="preview-bg-container">
                                <button class="zoom-btn preview-bg-btn" onclick="togglePreviewBgDropdown(event)"
                                    title="Preview background">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                        width="16" height="16">
                                        <rect x="3" y="3" width="18" height="18" rx="2" />
                                        <path d="M3 3l18 18" />
                                    </svg>
                                </button>
                                <div class="preview-bg-dropdown">
                                    <button class="preview-bg-option active" data-bg="checkerboard"
                                        onclick="setPreviewBg('checkerboard')">
                                        <span class="swatch checkerboard"></span> Checkerboard
                                    </button>
                                    <button class="preview-bg-option" data-bg="white" onclick="setPreviewBg('white')">
                                        <span class="swatch" style="background: #fff;"></span> White
                                    </button>
                                    <button class="preview-bg-option" data-bg="black" onclick="setPreviewBg('black')">
                                        <span class="swatch" style="background: #000;"></span> Black
                                    </button>
                                    <button class="preview-bg-option" data-bg="custom" onclick="setPreviewBg('custom')">
                                        <span class="swatch" id="preview-bg-custom-swatch"
                                            style="background: #808080;"></span> Custom
                                    </button>
                                    <div class="preview-bg-custom-color" id="preview-bg-custom-picker"
                                        style="display: none;">
                                        <input type="color" id="preview-bg-custom-color" value="#808080"
                                            oninput="updatePreviewBgCustomColor(this.value)"
                                            onchange="updatePreviewBgCustomColor(this.value)">
                                        <span style="font-size: 11px; color: var(--text-secondary);">Pick color</span>
                                    </div>
                                </div>
                            </div>
                            <div class="preview-toolbar-separator"></div>
                        </div>
                        <button class="zoom-btn ib-library-only" id="ib-sort-btn" onclick="ibToggleSort()"
                            title="Sort order">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                height="16">
                                <path d="M11 5h10" />
                                <path d="M11 9h7" />
                                <path d="M11 13h4" />
                                <path d="M3 17l3 3 3-3" />
                                <path d="M6 18V4" />
                            </svg>
                        </button>
                        <div class="preview-toolbar-separator ib-library-only"></div>
                        <button class="zoom-btn" onclick="ibHandleZoomBtn(-1)"></button>
                        <span class="zoom-level" id="zoom-level">100%</span>
                        <button class="zoom-btn" onclick="ibHandleZoomBtn(1)">+</button>
                        <button class="zoom-btn ib-editor-only" onclick="resetZoom()" title="Fit to view">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                height="16">
                                <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7" />
                            </svg>
                        </button>
                        <button class="zoom-btn ib-library-only" onclick="ibResetZoom()" title="Reset zoom">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16"
                                height="16">
                                <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7" />
                            </svg>
                        </button>
                        <div class="preview-toolbar-separator ib-library-only"></div>
                        <button class="zoom-btn ib-library-only ib-select-toggle-btn" id="ib-select-toggle"
                            onclick="ibToggleSelectAll()" title="Select all">Select All</button>
                    </div>
                </div>
                <div class="preview-container" id="drop-zone">
                    <div class="preview-bg ib-editor-only"></div>
                    <div class="preview-wrapper ib-editor-only" id="preview-wrapper">
                        <div id="preview-svg"></div>
                        <div id="empty-state" class="empty-state" onclick="triggerFileLoad()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <rect x="3" y="3" width="18" height="18" rx="2" />
                                <path d="M12 8v8M8 12h8" />
                            </svg>
                            <p>Drag & drop one or more SVG files here</p>
                            <p class="click-hint">or click to browse</p>
                        </div>
                    </div>
                    <div class="ib-library-only" id="ib-grid-container">
                        <div class="ib-loading" id="ib-loading">
                            <div class="ib-spinner"></div>
                            Loading icon library...
                        </div>
                        <div class="ib-scroll-container" id="ib-scroll-container" style="display:none;">
                            <div class="ib-scroll-spacer" id="ib-scroll-spacer"></div>
                            <div class="ib-tile-window" id="ib-tile-window"></div>
                        </div>
                        <div class="ib-empty" id="ib-empty" style="display:none;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8" />
                                <path d="M21 21l-4.35-4.35" />
                            </svg>
                            <span>No icons match your search</span>
                        </div>
                    </div>
                </div>
                <!-- Hidden file input for SVG loading (multiple selection enabled) -->
                <input type="file" id="svg-file-input" accept=".svg,image/svg+xml" style="display: none;" multiple
                    onchange="handleFileSelect(event)">
                <div class="size-info">
                    <span id="svg-dimensions" style="display:none">Dimensions: --</span>
                    <span id="svg-size" style="display:none">Size: --</span>
                    <button class="report-issue-btn" onclick="showIssueReport()"
                        title="Report an issue with SVG output">
                        <svg viewBox="0 0 1200 1200" fill="#f59e0b" stroke="none">
                            <path
                                d="m1128.9 905.81-424.31-734.63c-21.75-37.875-60.938-60.375-104.62-60.375s-82.875 22.5-104.62 60.375l-424.31 734.63c-21.75 37.875-21.75 83.062 0 120.94 21.938 37.875 61.125 60.562 104.81 60.562h848.26c43.688 0 82.875-22.688 104.81-60.562 21.75-37.875 21.75-83.062 0-120.94zm-597.19-6.375c0-37.688 30.562-68.25 68.25-68.25s68.25 30.562 68.25 68.25-30.562 68.438-68.25 68.438-68.25-30.75-68.25-68.438zm127.69-155.63c-1.5 31.875-27.562 56.812-59.438 56.812s-57.938-24.938-59.438-56.812l-14.625-322.13c-0.9375-20.438 6.1875-39.938 20.438-54.75 14.062-14.625 33.188-22.875 53.625-22.875s39.562 8.25 53.625 22.875c14.25 14.812 21.375 34.312 20.438 54.75z" />
                        </svg>
                        Report an Issue
                    </button>
                    <button class="elemental-about-btn" onclick="showAboutModal()" title="About Elemental FM">
                        <svg viewBox="0 0 512 512" width="14" height="14">
                            <polygon style="fill:#BAFFA0;"
                                points="158.897,273.655 88.276,264.828 61.793,326.621 194.207,494.345 247.172,512" />
                            <polygon style="fill:#E2FFCB;"
                                points="88.276,264.828 123.586,308.966 150.069,291.31 158.897,273.655" />
                            <polygon style="fill:#99DCA3;"
                                points="123.586,308.966 220.69,503.172 194.207,494.345 61.793,326.621" />
                            <polygon style="fill:#99DCA3;"
                                points="370.759,476.69 450.207,335.448 432.552,273.655 353.103,317.793 344.276,476.69" />
                            <polygon style="fill:#BAFFA0;"
                                points="397.241,317.793 406.069,361.931 432.552,273.655 397.241,291.31 397.241,308.966" />
                            <polygon style="fill:#E2FFCB;" points="432.552,273.655 450.207,335.448 406.069,361.931" />
                            <polygon style="fill:#BAFFA0;"
                                points="406.069,361.931 353.103,476.69 370.759,476.69 450.207,335.448" />
                            <polygon style="fill:#3DB9C9;"
                                points="211.862,52.966 247.172,476.69 282.483,414.897 273.655,97.103" />
                            <polygon style="fill:#00C39F;"
                                points="344.276,494.345 432.552,211.862 388.414,123.586 317.793,141.241 247.172,512" />
                            <polygon style="fill:#67EBBC;"
                                points="314.489,158.585 370.759,229.517 388.414,123.586 317.793,141.241" />
                            <polygon style="fill:#64CDF6;"
                                points="247.172,512 282.483,238.345 344.276,185.379 370.759,256 308.966,512" />
                            <polygon style="fill:#2CA6DE;"
                                points="282.483,238.345 317.793,317.793 273.655,512 247.172,512" />
                            <polygon style="fill:#67EBBC;" points="370.759,229.517 344.276,494.345 432.552,211.862" />
                            <polygon style="fill:#B8F9D0;" points="432.552,211.862 388.414,123.586 370.759,229.517" />
                            <polygon style="fill:#A0EBFA;" points="317.793,317.793 344.276,185.379 370.759,256" />
                            <polygon style="fill:#53DCDC;" points="211.862,52.966 273.655,97.103 256,0" />
                            <polygon style="fill:#53DCDC;"
                                points="326.621,61.793 273.655,97.103 264.828,441.379 317.793,220.69" />
                            <polygon style="fill:#B0F9F9;" points="256,0 273.655,97.103 326.621,61.793" />
                            <polygon style="fill:#64CDF6;"
                                points="273.655,512 211.862,158.897 141.241,105.931 114.759,220.69 220.69,512" />
                            <polygon style="fill:#A0EBFA;" points="141.241,105.931 158.897,220.69 211.862,158.897" />
                            <polygon style="fill:#2CA6DE;"
                                points="220.69,512 247.172,512 158.897,220.69 114.759,220.69" />
                        </svg>
                        About Elemental FM
                    </button>
                    <button class="elemental-about-btn"
                        onclick="window.open('https://github.com/weetbicks/elemental-svg','_blank')"
                        title="View on GitHub">
                        <svg viewBox="0 0 16 16" width="14" height="14" fill="currentColor">
                            <path
                                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
                        </svg>
                        View on GitHub
                    </button>
                </div>
            </div>

            <div class="controls-panel">
                <!-- Icon Library Sidebar (library mode only) -->
                <div class="ib-library-only" id="ib-library-sidebar">
                    <div class="control-section" id="ib-export-section">
                        <h3>Export Options</h3>
                        <div style="margin-bottom: 10px;">
                            <div class="increment-options">
                                <button class="increment-btn active" id="ib-format-svg"
                                    onclick="ibSetExportFormat('svg')">SVG</button>
                                <button class="increment-btn" id="ib-format-png"
                                    onclick="ibSetExportFormat('png')">PNG</button>
                            </div>
                        </div>
                        <div id="ib-png-size-section" style="display: none; margin-bottom: 10px;">
                            <label
                                style="display: block; font-size: 10px; color: var(--text-secondary); margin-bottom: 6px;">PNG
                                Size</label>
                            <div class="increment-options" style="flex-wrap: wrap; gap: 4px;">
                                <button class="increment-btn" id="ib-size-32" onclick="ibSetExportSize(32)">32</button>
                                <button class="increment-btn" id="ib-size-64" onclick="ibSetExportSize(64)">64</button>
                                <button class="increment-btn" id="ib-size-128"
                                    onclick="ibSetExportSize(128)">128</button>
                                <button class="increment-btn" id="ib-size-256"
                                    onclick="ibSetExportSize(256)">256</button>
                                <button class="increment-btn active" id="ib-size-512"
                                    onclick="ibSetExportSize(512)">512</button>
                                <button class="increment-btn" id="ib-size-1024"
                                    onclick="ibSetExportSize(1024)">1024</button>
                            </div>
                        </div>
                        <div class="bg-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="ib-export-fm" checked onchange="ibSavePrefs()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span title="Adds fm_fill class for FileMaker styling">FileMaker Compatible</span>
                        </div>
                        <div class="bg-toggle" style="margin-top: 10px;">
                            <label class="toggle-switch">
                                <input type="checkbox" id="ib-export-dynamic" checked onchange="ibSavePrefs()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span>Dynamic Fill</span>
                        </div>
                        <p style="font-size: 10px; color: var(--text-secondary); margin-top: 6px; line-height: 1.3;">
                            Remove fills so FileMaker can apply colors at runtime. Turn off to keep original colors.</p>
                        <div id="ib-stroke-convert-section"
                            style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                            <div class="bg-toggle">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="ib-convert-strokes" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                                <span>Convert Strokes to Fills</span>
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 10px;">
                            <button class="btn btn-secondary" onclick="ibExportButtonBar(event)" style="width:100%; display:none;"
                                id="ib-buttonbar-btn">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                                </svg>
                                <span id="ib-buttonbar-text">Copy as Button Bar</span>
                            </button>
                            <button class="btn btn-primary" onclick="ibDoExport()" style="width:100%"
                                id="ib-download-btn">
                                <svg id="ib-download-icon" viewBox="0 0 24 24" fill="currentColor"
                                    style="display:none;">
                                    <path d="M11.56 0a3.34 3.34 0 00-.57.043L22.947 12 10.99 23.957c.132.022.307.043.57.043 6.626 0 12-5.375 12-12s-5.374-12-12-12zm-1.535 2.414C4.738 2.414.44 6.713.44 12s4.3 9.588 9.586 9.588c.264 0 .44-.023.57-.045L1.054 12l9.543-9.543a3.337 3.337 0 00-.57-.043zm.746 2.457c-.263 0-.438.021-.57.043L17.287 12l-7.086 7.086c.132.022.307.045.57.045 3.927 0 7.13-3.204 7.13-7.131s-3.203-7.129-7.13-7.129zm-.416 2.434A4.701 4.701 0 005.66 12a4.701 4.701 0 004.695 4.695c.264 0 .44-.023.57-.045L6.274 12l4.653-4.65a3.296 3.296 0 00-.57-.045Z"/>
                                </svg>
                                <span id="ib-download-text">Download</span>
                            </button>
                        </div>
                    </div>
                    <div class="control-section" id="ib-filter-section">
                        <h3>Filters</h3>
                        <div id="ib-filter-content"></div>
                    </div>
                </div>

                <!-- Export Options Section -->
                <div class="control-section ib-editor-only">
                    <h3>Export Options</h3>
                    <div style="margin-bottom: 10px;">
                        <div class="increment-options">
                            <button class="increment-btn active" id="format-svg"
                                onclick="setOutputFormat('svg')">SVG</button>
                            <button class="increment-btn" id="format-png" onclick="setOutputFormat('png')">PNG</button>
                        </div>
                    </div>
                    <div id="png-size-section" style="display: none; margin-bottom: 10px;">
                        <label
                            style="display: block; font-size: 10px; color: var(--text-secondary); margin-bottom: 6px;">PNG
                            Size</label>
                        <div class="increment-options" style="flex-wrap: wrap; gap: 4px;">
                            <button class="increment-btn" id="size-32" onclick="setOutputSize(32)">32</button>
                            <button class="increment-btn" id="size-64" onclick="setOutputSize(64)">64</button>
                            <button class="increment-btn" id="size-128" onclick="setOutputSize(128)">128</button>
                            <button class="increment-btn" id="size-256" onclick="setOutputSize(256)">256</button>
                            <button class="increment-btn active" id="size-512" onclick="setOutputSize(512)">512</button>
                            <button class="increment-btn" id="size-1024" onclick="setOutputSize(1024)">1024</button>
                        </div>
                    </div>
                    <div id="svg-options-section">
                        <div class="bg-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="fm-compat" checked onchange="toggleFMCompat(this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                            <span title="Adds fm_fill class for FileMaker styling">FileMaker Compatible</span>
                        </div>
                        <div class="bg-toggle" style="margin-top: 10px;">
                            <label class="toggle-switch">
                                <input type="checkbox" id="fm-dynamic" checked onchange="toggleFMDynamic(this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                            <span>Dynamic Fill</span>
                        </div>
                        <p style="font-size: 10px; color: var(--text-secondary); margin-top: 6px; line-height: 1.3;">
                            Remove fills so FileMaker can apply colors at runtime. Turn off to keep your chosen color.
                        </p>
                        <div id="fm-target-section" style="display: none; margin-top: 10px;">
                            <label
                                style="display: block; font-size: 10px; color: var(--text-secondary); margin-bottom: 6px;">FileMaker
                                controls:</label>
                            <div class="increment-options">
                                <button class="increment-btn active" id="target-icon"
                                    onclick="setFMTarget('icon')">Icon</button>
                                <button class="increment-btn" id="target-background"
                                    onclick="setFMTarget('background')">Background</button>
                            </div>
                            <p style="font-size: 10px; color: var(--text-secondary); margin-top: 6px; line-height: 1.3;"
                                id="fm-target-hint">
                                FileMaker will dynamically change the icon color. Background keeps its set color.
                            </p>
                        </div>
                        <div id="stroke-convert-section"
                            style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                            <div class="bg-toggle">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="convert-strokes" checked
                                        onchange="toggleStrokeConversion(this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span>Convert Strokes to Fills</span>
                            </div>
                            <p
                                style="font-size: 10px; color: var(--text-secondary); margin-top: 6px; line-height: 1.3;">
                                Stroke-based SVGs detected. Strokes will be converted to filled paths for better
                                FileMaker compatibility.
                            </p>
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 6px; margin-top: 10px;">
                        <button class="btn btn-secondary" id="editor-buttonbar-btn"
                            onclick="editorExportButtonBar(event)" style="width:100%; display:none;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                            </svg>
                            <span id="editor-buttonbar-text">Copy as Button Bar</span>
                        </button>
                        <button class="btn btn-primary" id="save-btn" onclick="saveSVG()" disabled
                            style="width:100%">
                            <svg id="save-btn-icon" viewBox="0 0 24 24" fill="currentColor"
                                style="display:none;">
                                <path d="M11.56 0a3.34 3.34 0 00-.57.043L22.947 12 10.99 23.957c.132.022.307.043.57.043 6.626 0 12-5.375 12-12s-5.374-12-12-12zm-1.535 2.414C4.738 2.414.44 6.713.44 12s4.3 9.588 9.586 9.588c.264 0 .44-.023.57-.045L1.054 12l9.543-9.543a3.337 3.337 0 00-.57-.043zm.746 2.457c-.263 0-.438.021-.57.043L17.287 12l-7.086 7.086c.132.022.307.045.57.045 3.927 0 7.13-3.204 7.13-7.131s-3.203-7.129-7.13-7.129zm-.416 2.434A4.701 4.701 0 005.66 12a4.701 4.701 0 004.695 4.695c.264 0 .44-.023.57-.045L6.274 12l4.653-4.65a3.296 3.296 0 00-.57-.045Z"/>
                            </svg>
                            <span id="save-btn-text">Save SVG</span>
                        </button>
                    </div>
                </div>

                <!-- Colors Section -->
                <div class="control-section ib-editor-only">
                    <h3>Colors</h3>
                    <div class="color-row">
                        <label>Icon Fill</label>
                        <div class="color-picker-wrapper">
                            <div class="color-preview" style="background: #000000">
                                <input type="color" id="fill-color" value="#000000">
                            </div>
                            <input type="text" class="color-hex" id="fill-hex" value="#000000"
                                onchange="this.value=normalizeHex(this.value); updateFillColor(this.value)">
                        </div>
                    </div>
                    <div class="color-row" style="margin-top: 8px;">
                        <label>Stroke</label>
                        <div class="color-picker-wrapper">
                            <div class="color-preview" style="background: #000000">
                                <input type="color" id="stroke-color" value="#000000">
                            </div>
                            <input type="text" class="color-hex" id="stroke-hex" value="#000000"
                                onchange="this.value=normalizeHex(this.value); updateStrokeColor(this.value)">
                        </div>
                    </div>
                    <div class="stroke-row">
                        <label>Stroke Width</label>
                        <input type="range" class="stroke-slider" id="stroke-width" min="0" max="10" step="0.5"
                            value="0" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                            onchange="updateStrokeWidth(this.value, true)" oninput="updateStrokeWidth(this.value)">
                        <span class="stroke-value" id="stroke-value">0</span>
                    </div>
                </div>

                <!-- Background Section -->
                <div class="control-section ib-editor-only">
                    <h3>Background</h3>
                    <div class="bg-toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="bg-enabled" onchange="toggleBackground(this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Enable Background</span>
                    </div>
                    <div class="bg-options" id="bg-options">
                        <div class="color-row">
                            <label>Color</label>
                            <div class="color-picker-wrapper">
                                <div class="color-preview" id="bg-color-preview" style="background: #ffffff">
                                    <input type="color" id="bg-color" value="#ffffff">
                                </div>
                                <input type="text" class="color-hex" id="bg-hex" value="#ffffff"
                                    onchange="this.value=normalizeHex(this.value); updateBgColor(this.value)">
                            </div>
                        </div>
                        <div class="shape-options">
                            <button class="shape-btn" onclick="setBgEdges(0)" id="shape-edges-0">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <circle cx="12" cy="12" r="10" />
                                </svg>
                                <span>Circle</span>
                            </button>
                            <button class="shape-btn" onclick="setBgEdges(3)" id="shape-edges-3">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <polygon points="12,2 22,20 2,20" />
                                </svg>
                                <span>Tri</span>
                            </button>
                            <button class="shape-btn active" onclick="setBgEdges(4)" id="shape-edges-4">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <rect x="3" y="3" width="18" height="18" rx="2" />
                                </svg>
                                <span>Square</span>
                            </button>
                            <button class="shape-btn" onclick="setBgEdges(5)" id="shape-edges-5">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <polygon points="12,2 21.5,9.5 18,20.5 6,20.5 2.5,9.5" />
                                </svg>
                                <span>Pent</span>
                            </button>
                            <button class="shape-btn" onclick="setBgEdges(6)" id="shape-edges-6">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <polygon points="12,2 20.7,6 20.7,18 12,22 3.3,18 3.3,6" />
                                </svg>
                                <span>Hex</span>
                            </button>
                        </div>
                        <div class="edges-stepper">
                            <button onclick="adjustBgEdges(-1)">&#8722;</button>
                            <span class="edges-value" id="edges-value">4</span>
                            <button onclick="adjustBgEdges(1)">+</button>
                            <span class="edges-label" id="edges-label">Square</span>
                        </div>
                        <div class="padding-control">
                            <label>Icon Padding</label>
                            <div class="stroke-row" style="margin-bottom: 0;">
                                <input type="range" class="stroke-slider" id="icon-padding" min="0" max="30" step="1"
                                    value="10" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                    onchange="updatePadding(this.value, true)" oninput="updatePadding(this.value)">
                                <span class="stroke-value" id="padding-value">10%</span>
                            </div>
                        </div>
                        <div class="corner-radius-control" id="corner-radius-control">
                            <label>Corner Radius</label>
                            <div class="stroke-row" style="margin-bottom: 0;">
                                <input type="range" class="stroke-slider" id="corner-radius" min="0" max="50" step="1"
                                    value="10" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                    onchange="updateCornerRadius(this.value, true)"
                                    oninput="updateCornerRadius(this.value)">
                                <span class="stroke-value" id="radius-value">10%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Rotate & Transform Section -->
                <div class="control-section ib-editor-only">
                    <h3>Rotate & Transform</h3>
                    <div class="rotation-controls">
                        <button class="rotation-btn" onclick="rotate(-1)" title="Rotate Counter-clockwise">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                                <path d="M3 3v5h5" />
                            </svg>
                        </button>
                        <div class="rotation-value" id="rotation-value">0</div>
                        <button class="rotation-btn" onclick="rotate(1)" title="Rotate Clockwise">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 12a9 9 0 1 1-9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                                <path d="M21 3v5h-5" />
                            </svg>
                        </button>
                    </div>
                    <div class="rotation-increment">
                        <label>Increment</label>
                        <div class="increment-options">
                            <button class="increment-btn" onclick="setIncrement(15)">15</button>
                            <button class="increment-btn active" onclick="setIncrement(30)">30</button>
                            <button class="increment-btn" onclick="setIncrement(45)">45</button>
                            <button class="increment-btn" onclick="setIncrement(90)">90</button>
                        </div>
                    </div>
                    <div class="transform-grid">
                        <button class="transform-btn" onclick="flipHorizontal()" title="Flip Horizontal">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 3v18M16 7l4 5-4 5M8 7l-4 5 4 5" />
                            </svg>
                            Flip H
                        </button>
                        <button class="transform-btn" onclick="flipVertical()" title="Flip Vertical">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12h18M7 8l5-4 5 4M7 16l5 4 5-4" />
                            </svg>
                            Flip V
                        </button>
                    </div>
                </div>

                <!-- Adjustments Section -->
                <div class="control-section ib-editor-only">
                    <h3>Adjustments</h3>
                    <div class="adjustment-row">
                        <label>Opacity</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="opacity-slider" min="0" max="100" step="1"
                                value="100" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateOpacity(this.value, true)" oninput="updateOpacity(this.value)">
                            <span class="stroke-value" id="opacity-value">100%</span>
                        </div>
                    </div>
                    <div class="adjustment-row">
                        <label>Scale</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="scale-slider" min="50" max="150" step="1"
                                value="100" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateScale(this.value, true)" oninput="updateScale(this.value)">
                            <span class="stroke-value" id="scale-value">100%</span>
                        </div>
                    </div>
                    <div class="adjustment-row">
                        <label>X Offset</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="offset-x-slider" min="-50" max="50" step="1"
                                value="0" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateOffsetX(this.value, true)" oninput="updateOffsetX(this.value)">
                            <span class="stroke-value" id="offset-x-value">0</span>
                        </div>
                    </div>
                    <div class="adjustment-row">
                        <label>Y Offset</label>
                        <div class="slider-row">
                            <input type="range" class="stroke-slider" id="offset-y-slider" min="-50" max="50" step="1"
                                value="0" onmousedown="saveSliderState()" ontouchstart="saveSliderState()"
                                onchange="updateOffsetY(this.value, true)" oninput="updateOffsetY(this.value)">
                            <span class="stroke-value" id="offset-y-value">0</span>
                        </div>
                    </div>
                    <div class="transform-grid" style="margin-top: 8px;">
                        <button class="transform-btn" onclick="invertColors()" title="Invert Colors (swap black/white)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="9" />
                                <path d="M12 3v18" />
                                <path d="M12 3a9 9 0 0 1 0 18" fill="currentColor" />
                            </svg>
                            Invert
                        </button>
                        <button class="transform-btn" onclick="resetAdjustments()"
                            title="Reset all adjustments to defaults">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                                <path d="M3 3v5h5" />
                            </svg>
                            Reset Adj.
                        </button>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal-card">
            <div class="modal-icon" id="modal-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                    <path d="M3 3v5h5" />
                </svg>
            </div>
            <div class="modal-title" id="modal-title">Reset to Original?</div>
            <div class="modal-message" id="modal-message">
                You have unsaved changes. Are you sure you want to reset to the original SVG? This action cannot be
                undone.
            </div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" id="modal-cancel-btn"
                    onclick="hideConfirmModal()">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="modal-confirm-btn"
                    onclick="confirmModalAction()">Reset</button>
            </div>
        </div>
    </div>

    <!-- Code View Modal -->
    <div class="code-view-overlay" id="code-view-modal">
        <div class="code-view-card">
            <div class="code-view-header">
                <h3 id="code-view-title">SVG Code</h3>
                <div class="code-view-actions">
                    <button class="btn btn-secondary" id="code-view-copy-btn" onclick="copyCodeViewContent()"
                        style="padding: 6px 12px; font-size: 11px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12"
                            height="12">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                        </svg>
                        Copy
                    </button>
                    <button class="code-view-close" onclick="hideCodeView()">&times;</button>
                </div>
            </div>
            <pre class="code-view-pre" id="code-view-content"></pre>
        </div>
    </div>

    <!-- SVG Selection Modal -->
    <div class="modal-overlay" id="svg-selection-modal">
        <div class="modal-card" style="max-width: 360px;">
            <div class="modal-title" id="svg-selection-title">Select SVG</div>
            <div class="modal-message" id="svg-selection-message">Choose an SVG:</div>
            <ul class="svg-selection-list" id="svg-selection-list"></ul>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" onclick="hideSVGSelectionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Issue Report Modal -->
    <div class="modal-overlay" id="issue-report-modal">
        <div class="issue-report-card">
            <div class="modal-icon">
                <svg viewBox="0 0 1200 1200" fill="#f59e0b" stroke="none">
                    <path
                        d="m1128.9 905.81-424.31-734.63c-21.75-37.875-60.938-60.375-104.62-60.375s-82.875 22.5-104.62 60.375l-424.31 734.63c-21.75 37.875-21.75 83.062 0 120.94 21.938 37.875 61.125 60.562 104.81 60.562h848.26c43.688 0 82.875-22.688 104.81-60.562 21.75-37.875 21.75-83.062 0-120.94zm-597.19-6.375c0-37.688 30.562-68.25 68.25-68.25s68.25 30.562 68.25 68.25-30.562 68.438-68.25 68.438-68.25-30.75-68.25-68.438zm127.69-155.63c-1.5 31.875-27.562 56.812-59.438 56.812s-57.938-24.938-59.438-56.812l-14.625-322.13c-0.9375-20.438 6.1875-39.938 20.438-54.75 14.062-14.625 33.188-22.875 53.625-22.875s39.562 8.25 53.625 22.875c14.25 14.812 21.375 34.312 20.438 54.75z" />
                </svg>
            </div>
            <div class="modal-title">Report an Issue</div>
            <div class="issue-report-description">
                Having trouble with your SVG output? Not looking like what you'd expect in FileMaker? Submit a report
                and I'll diagnose and address the problem. Your current SVG(s) and editor settings will be included
                automatically. Thanks! &mdash; Daniel (FM Weetbicks)
            </div>
            <div class="issue-report-field">
                <label for="issue-report-email">Email <span
                        style="font-weight:400;color:var(--text-secondary)">(optional)</span></label>
                <input type="email" id="issue-report-email" placeholder="you@example.com">
                <div class="field-hint">Get notified when a fix is available</div>
            </div>
            <div class="issue-report-field">
                <label for="issue-report-details">What's the problem?</label>
                <textarea id="issue-report-details"
                    placeholder="Describe what you're seeing, e.g. &quot;The icon loses its fill color when saved&quot; or &quot;Arcs look distorted in FileMaker&quot;"></textarea>
            </div>
            <div class="issue-report-info">
                This report will include: your loaded SVG file(s), the processed output, and current editor settings. No
                other data is collected.
            </div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" onclick="hideIssueReport()">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="issue-report-submit-btn"
                    onclick="submitIssueReport()">Submit Report</button>
            </div>
        </div>
    </div>

    <!-- Release Notes Modal -->
    <div class="modal-overlay" id="release-notes-modal">
        <div class="release-notes-card">
            <div class="modal-title">Release Notes</div>
            <div class="release-notes-list" id="release-notes-list">
                <div class="release-notes-loading">Loading release notes...</div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="hideReleaseNotes()">Close</button>
            </div>
        </div>
    </div>

    <!-- About Elemental FM Modal -->
    <div class="modal-overlay" id="about-modal" onclick="if(event.target===this)hideAboutModal()">
        <div class="modal-card" style="max-width:560px;">
            <div class="modal-icon">
                <svg viewBox="0 0 512 512" width="48" height="48">
                    <polygon style="fill:#BAFFA0;"
                        points="158.897,273.655 88.276,264.828 61.793,326.621 194.207,494.345 247.172,512" />
                    <polygon style="fill:#E2FFCB;"
                        points="88.276,264.828 123.586,308.966 150.069,291.31 158.897,273.655" />
                    <polygon style="fill:#99DCA3;"
                        points="123.586,308.966 220.69,503.172 194.207,494.345 61.793,326.621" />
                    <polygon style="fill:#99DCA3;"
                        points="370.759,476.69 450.207,335.448 432.552,273.655 353.103,317.793 344.276,476.69" />
                    <polygon style="fill:#BAFFA0;"
                        points="397.241,317.793 406.069,361.931 432.552,273.655 397.241,291.31 397.241,308.966" />
                    <polygon style="fill:#E2FFCB;" points="432.552,273.655 450.207,335.448 406.069,361.931" />
                    <polygon style="fill:#BAFFA0;"
                        points="406.069,361.931 353.103,476.69 370.759,476.69 450.207,335.448" />
                    <polygon style="fill:#3DB9C9;"
                        points="211.862,52.966 247.172,476.69 282.483,414.897 273.655,97.103" />
                    <polygon style="fill:#00C39F;"
                        points="344.276,494.345 432.552,211.862 388.414,123.586 317.793,141.241 247.172,512" />
                    <polygon style="fill:#67EBBC;"
                        points="314.489,158.585 370.759,229.517 388.414,123.586 317.793,141.241" />
                    <polygon style="fill:#64CDF6;"
                        points="247.172,512 282.483,238.345 344.276,185.379 370.759,256 308.966,512" />
                    <polygon style="fill:#2CA6DE;" points="282.483,238.345 317.793,317.793 273.655,512 247.172,512" />
                    <polygon style="fill:#67EBBC;" points="370.759,229.517 344.276,494.345 432.552,211.862" />
                    <polygon style="fill:#B8F9D0;" points="432.552,211.862 388.414,123.586 370.759,229.517" />
                    <polygon style="fill:#A0EBFA;" points="317.793,317.793 344.276,185.379 370.759,256" />
                    <polygon style="fill:#53DCDC;" points="211.862,52.966 273.655,97.103 256,0" />
                    <polygon style="fill:#53DCDC;"
                        points="326.621,61.793 273.655,97.103 264.828,441.379 317.793,220.69" />
                    <polygon style="fill:#B0F9F9;" points="256,0 273.655,97.103 326.621,61.793" />
                    <polygon style="fill:#64CDF6;"
                        points="273.655,512 211.862,158.897 141.241,105.931 114.759,220.69 220.69,512" />
                    <polygon style="fill:#A0EBFA;" points="141.241,105.931 158.897,220.69 211.862,158.897" />
                    <polygon style="fill:#2CA6DE;" points="220.69,512 247.172,512 158.897,220.69 114.759,220.69" />
                </svg>
            </div>
            <div class="modal-title" id="about-title">Elemental FM</div>
            <div class="about-description" id="about-description"></div>
            <hr style="border:none; border-top:1px solid var(--border-color); margin:16px 0;">
            <div id="about-products" class="about-scrollable"></div>
            <div class="modal-actions" style="justify-content:flex-end;">
                <button class="modal-btn modal-btn-cancel" onclick="hideAboutModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Progress Modal (stroke conversion) -->
    <div class="modal-overlay" id="progress-modal">
        <div class="modal-card" style="max-width: 320px; text-align: center;">
            <div class="modal-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="16 16 12 12 8 8" />
                    <line x1="12" y1="12" x2="12" y2="21" />
                    <path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3" />
                </svg>
            </div>
            <div class="modal-title" id="progress-title">Converting Icons...</div>
            <div style="margin: 16px 0 8px;">
                <div style="background: var(--bg-tertiary); border-radius: 4px; height: 6px; overflow: hidden;">
                    <div id="progress-bar"
                        style="height: 100%; background: var(--accent); border-radius: 4px; width: 0%; transition: width 0.15s ease;">
                    </div>
                </div>
            </div>
            <div id="progress-text"
                style="font-size: 12px; color: var(--text-secondary); font-variant-numeric: tabular-nums;">
                0 of 0
            </div>
            <div class="modal-actions" style="margin-top: 16px; justify-content: center;">
                <button class="modal-btn modal-btn-cancel" onclick="cancelProgressModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="toast-icon">
            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
            <polyline points="22 4 12 14.01 9 11.01" />
        </svg>
        <span id="toast-text"></span>
    </div>

    <!-- Potrace library for stroke-to-fill conversion (bitmap tracing) -->
    <script>
        /* 
         * A javascript port of Potrace (http://potrace.sourceforge.net).
         * 
         * Licensed under the GPL
         * 
         * Usage
         *   loadImageFromFile(file) : load image from File API
         *   loadImageFromUrl(url): load image from URL
         *     because of the same-origin policy, can not load image from another domain.
         *     input color/grayscale image is simply converted to binary image. no pre-
         *     process is performed.
         * 
         *   setParameter({para1: value, ...}) : set parameters
         *     parameters:
         *        turnpolicy ("black" / "white" / "left" / "right" / "minority" / "majority")
         *          how to resolve ambiguities in path decomposition. (default: "minority")       
         *        turdsize
         *          suppress speckles of up to this size (default: 2)
         *        optcurve (true / false)
         *          turn on/off curve optimization (default: true)
         *        alphamax
         *          corner threshold parameter (default: 1)
         *        opttolerance 
         *          curve optimization tolerance (default: 0.2)
         *       
         *   process(callback) : wait for the image be loaded, then run potrace algorithm,
         *                       then call callback function.
         * 
         *   getSVG: getSVG(size, opt_type) : return a string of generated SVG image.
         *                                    result_image_size = original_image_size * size
         *                                    optional parameter opt_type can be "curve"
         */

        var Potrace = (function () {

            function Point(x, y) {
                this.x = x;
                this.y = y;
            }

            Point.prototype.copy = function () {
                return new Point(this.x, this.y);
            };

            function Bitmap(w, h) {
                this.w = w;
                this.h = h;
                this.size = w * h;
                this.arraybuffer = new ArrayBuffer(this.size);
                this.data = new Int8Array(this.arraybuffer);
            }

            Bitmap.prototype.at = function (x, y) {
                return (x >= 0 && x < this.w && y >= 0 && y < this.h) &&
                    this.data[this.w * y + x] === 1;
            };

            Bitmap.prototype.index = function (i) {
                var point = new Point();
                point.y = Math.floor(i / this.w);
                point.x = i - point.y * this.w;
                return point;
            };

            Bitmap.prototype.flip = function (x, y) {
                if (this.at(x, y)) {
                    this.data[this.w * y + x] = 0;
                } else {
                    this.data[this.w * y + x] = 1;
                }
            };

            Bitmap.prototype.copy = function () {
                var bm = new Bitmap(this.w, this.h), i;
                for (i = 0; i < this.size; i++) {
                    bm.data[i] = this.data[i];
                }
                return bm;
            };

            function Path() {
                this.area = 0;
                this.len = 0;
                this.curve = {};
                this.pt = [];
                this.minX = 100000;
                this.minY = 100000;
                this.maxX = -1;
                this.maxY = -1;
            }

            function Curve(n) {
                this.n = n;
                this.tag = new Array(n);
                this.c = new Array(n * 3);
                this.alphaCurve = 0;
                this.vertex = new Array(n);
                this.alpha = new Array(n);
                this.alpha0 = new Array(n);
                this.beta = new Array(n);
            }

            var imgElement = document.createElement("img"),
                imgCanvas = document.createElement("canvas"),
                bm = null,
                pathlist = [],
                callback,
                info = {
                    isReady: false,
                    turnpolicy: "minority",
                    turdsize: 2,
                    optcurve: true,
                    alphamax: 1,
                    opttolerance: 0.2
                };

            imgElement.onload = function () {
                loadCanvas();
                loadBm();
            };

            function loadImageFromFile(file) {
                if (info.isReady) {
                    clear();
                }
                imgElement.file = file;
                var reader = new FileReader();
                reader.onload = (function (aImg) {
                    return function (e) {
                        aImg.src = e.target.result;
                    };
                })(imgElement);
                reader.readAsDataURL(file);
            }

            function loadImageFromUrl(url) {
                if (info.isReady) {
                    clear();
                }
                imgElement.src = url;

            }

            function setParameter(obj) {
                var key;
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        info[key] = obj[key];
                    }
                }
            }

            function loadCanvas() {
                imgCanvas.width = imgElement.width;
                imgCanvas.height = imgElement.height;
                var ctx = imgCanvas.getContext('2d');
                ctx.drawImage(imgElement, 0, 0);
            }

            function loadBm() {
                var ctx = imgCanvas.getContext('2d');
                bm = new Bitmap(imgCanvas.width, imgCanvas.height);
                var imgdataobj = ctx.getImageData(0, 0, bm.w, bm.h);
                var l = imgdataobj.data.length, i, j, color;
                for (i = 0, j = 0; i < l; i += 4, j++) {
                    color = 0.2126 * imgdataobj.data[i] + 0.7153 * imgdataobj.data[i + 1] +
                        0.0721 * imgdataobj.data[i + 2];
                    bm.data[j] = (color < 128 ? 1 : 0);
                }
                info.isReady = true;
            }


            function bmToPathlist() {

                var bm1 = bm.copy(),
                    currentPoint = new Point(0, 0),
                    path;

                function findNext(point) {
                    var i = bm1.w * point.y + point.x;
                    while (i < bm1.size && bm1.data[i] !== 1) {
                        i++;
                    }
                    return i < bm1.size && bm1.index(i);
                }

                function majority(x, y) {
                    var i, a, ct;
                    for (i = 2; i < 5; i++) {
                        ct = 0;
                        for (a = -i + 1; a <= i - 1; a++) {
                            ct += bm1.at(x + a, y + i - 1) ? 1 : -1;
                            ct += bm1.at(x + i - 1, y + a - 1) ? 1 : -1;
                            ct += bm1.at(x + a - 1, y - i) ? 1 : -1;
                            ct += bm1.at(x - i, y + a) ? 1 : -1;
                        }
                        if (ct > 0) {
                            return 1;
                        } else if (ct < 0) {
                            return 0;
                        }
                    }
                    return 0;
                }

                function findPath(point) {
                    var path = new Path(),
                        x = point.x, y = point.y,
                        dirx = 0, diry = 1, tmp;

                    path.sign = bm.at(point.x, point.y) ? "+" : "-";

                    while (1) {
                        path.pt.push(new Point(x, y));
                        if (x > path.maxX)
                            path.maxX = x;
                        if (x < path.minX)
                            path.minX = x;
                        if (y > path.maxY)
                            path.maxY = y;
                        if (y < path.minY)
                            path.minY = y;
                        path.len++;

                        x += dirx;
                        y += diry;
                        path.area -= x * diry;

                        if (x === point.x && y === point.y)
                            break;

                        var l = bm1.at(x + (dirx + diry - 1) / 2, y + (diry - dirx - 1) / 2);
                        var r = bm1.at(x + (dirx - diry - 1) / 2, y + (diry + dirx - 1) / 2);

                        if (r && !l) {
                            if (info.turnpolicy === "right" ||
                                (info.turnpolicy === "black" && path.sign === '+') ||
                                (info.turnpolicy === "white" && path.sign === '-') ||
                                (info.turnpolicy === "majority" && majority(x, y)) ||
                                (info.turnpolicy === "minority" && !majority(x, y))) {
                                tmp = dirx;
                                dirx = -diry;
                                diry = tmp;
                            } else {
                                tmp = dirx;
                                dirx = diry;
                                diry = -tmp;
                            }
                        } else if (r) {
                            tmp = dirx;
                            dirx = -diry;
                            diry = tmp;
                        } else if (!l) {
                            tmp = dirx;
                            dirx = diry;
                            diry = -tmp;
                        }
                    }
                    return path;
                }

                function xorPath(path) {
                    var y1 = path.pt[0].y,
                        len = path.len,
                        x, y, maxX, minY, i, j;
                    for (i = 1; i < len; i++) {
                        x = path.pt[i].x;
                        y = path.pt[i].y;

                        if (y !== y1) {
                            minY = y1 < y ? y1 : y;
                            maxX = path.maxX;
                            for (j = x; j < maxX; j++) {
                                bm1.flip(j, minY);
                            }
                            y1 = y;
                        }
                    }

                }

                while (currentPoint = findNext(currentPoint)) {

                    path = findPath(currentPoint);

                    xorPath(path);

                    if (path.area > info.turdsize) {
                        pathlist.push(path);
                    }
                }

            }


            function processPath() {

                function Quad() {
                    this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                }

                Quad.prototype.at = function (x, y) {
                    return this.data[x * 3 + y];
                };

                function Sum(x, y, xy, x2, y2) {
                    this.x = x;
                    this.y = y;
                    this.xy = xy;
                    this.x2 = x2;
                    this.y2 = y2;
                }

                function mod(a, n) {
                    return a >= n ? a % n : a >= 0 ? a : n - 1 - (-1 - a) % n;
                }

                function xprod(p1, p2) {
                    return p1.x * p2.y - p1.y * p2.x;
                }

                function cyclic(a, b, c) {
                    if (a <= c) {
                        return (a <= b && b < c);
                    } else {
                        return (a <= b || b < c);
                    }
                }

                function sign(i) {
                    return i > 0 ? 1 : i < 0 ? -1 : 0;
                }

                function quadform(Q, w) {
                    var v = new Array(3), i, j, sum;

                    v[0] = w.x;
                    v[1] = w.y;
                    v[2] = 1;
                    sum = 0.0;

                    for (i = 0; i < 3; i++) {
                        for (j = 0; j < 3; j++) {
                            sum += v[i] * Q.at(i, j) * v[j];
                        }
                    }
                    return sum;
                }

                function interval(lambda, a, b) {
                    var res = new Point();

                    res.x = a.x + lambda * (b.x - a.x);
                    res.y = a.y + lambda * (b.y - a.y);
                    return res;
                }

                function dorth_infty(p0, p2) {
                    var r = new Point();

                    r.y = sign(p2.x - p0.x);
                    r.x = -sign(p2.y - p0.y);

                    return r;
                }

                function ddenom(p0, p2) {
                    var r = dorth_infty(p0, p2);

                    return r.y * (p2.x - p0.x) - r.x * (p2.y - p0.y);
                }

                function dpara(p0, p1, p2) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p2.x - p0.x;
                    y2 = p2.y - p0.y;

                    return x1 * y2 - x2 * y1;
                }

                function cprod(p0, p1, p2, p3) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p3.x - p2.x;
                    y2 = p3.y - p2.y;

                    return x1 * y2 - x2 * y1;
                }

                function iprod(p0, p1, p2) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p2.x - p0.x;
                    y2 = p2.y - p0.y;

                    return x1 * x2 + y1 * y2;
                }

                function iprod1(p0, p1, p2, p3) {
                    var x1, y1, x2, y2;

                    x1 = p1.x - p0.x;
                    y1 = p1.y - p0.y;
                    x2 = p3.x - p2.x;
                    y2 = p3.y - p2.y;

                    return x1 * x2 + y1 * y2;
                }

                function ddist(p, q) {
                    return Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
                }

                function bezier(t, p0, p1, p2, p3) {
                    var s = 1 - t, res = new Point();

                    res.x = s * s * s * p0.x + 3 * (s * s * t) * p1.x + 3 * (t * t * s) * p2.x + t * t * t * p3.x;
                    res.y = s * s * s * p0.y + 3 * (s * s * t) * p1.y + 3 * (t * t * s) * p2.y + t * t * t * p3.y;

                    return res;
                }

                function tangent(p0, p1, p2, p3, q0, q1) {
                    var A, B, C, a, b, c, d, s, r1, r2;

                    A = cprod(p0, p1, q0, q1);
                    B = cprod(p1, p2, q0, q1);
                    C = cprod(p2, p3, q0, q1);

                    a = A - 2 * B + C;
                    b = -2 * A + 2 * B;
                    c = A;

                    d = b * b - 4 * a * c;

                    if (a === 0 || d < 0) {
                        return -1.0;
                    }

                    s = Math.sqrt(d);

                    r1 = (-b + s) / (2 * a);
                    r2 = (-b - s) / (2 * a);

                    if (r1 >= 0 && r1 <= 1) {
                        return r1;
                    } else if (r2 >= 0 && r2 <= 1) {
                        return r2;
                    } else {
                        return -1.0;
                    }
                }

                function calcSums(path) {
                    var i, x, y;
                    path.x0 = path.pt[0].x;
                    path.y0 = path.pt[0].y;

                    path.sums = [];
                    var s = path.sums;
                    s.push(new Sum(0, 0, 0, 0, 0));
                    for (i = 0; i < path.len; i++) {
                        x = path.pt[i].x - path.x0;
                        y = path.pt[i].y - path.y0;
                        s.push(new Sum(s[i].x + x, s[i].y + y, s[i].xy + x * y,
                            s[i].x2 + x * x, s[i].y2 + y * y));
                    }
                }

                function calcLon(path) {

                    var n = path.len, pt = path.pt, dir,
                        pivk = new Array(n),
                        nc = new Array(n),
                        ct = new Array(4);
                    path.lon = new Array(n);

                    var constraint = [new Point(), new Point()],
                        cur = new Point(),
                        off = new Point(),
                        dk = new Point(),
                        foundk;

                    var i, j, k1, a, b, c, d, k = 0;
                    for (i = n - 1; i >= 0; i--) {
                        if (pt[i].x != pt[k].x && pt[i].y != pt[k].y) {
                            k = i + 1;
                        }
                        nc[i] = k;
                    }

                    for (i = n - 1; i >= 0; i--) {
                        ct[0] = ct[1] = ct[2] = ct[3] = 0;
                        dir = (3 + 3 * (pt[mod(i + 1, n)].x - pt[i].x) +
                            (pt[mod(i + 1, n)].y - pt[i].y)) / 2;
                        ct[dir]++;

                        constraint[0].x = 0;
                        constraint[0].y = 0;
                        constraint[1].x = 0;
                        constraint[1].y = 0;

                        k = nc[i];
                        k1 = i;
                        while (1) {
                            foundk = 0;
                            dir = (3 + 3 * sign(pt[k].x - pt[k1].x) +
                                sign(pt[k].y - pt[k1].y)) / 2;
                            ct[dir]++;

                            if (ct[0] && ct[1] && ct[2] && ct[3]) {
                                pivk[i] = k1;
                                foundk = 1;
                                break;
                            }

                            cur.x = pt[k].x - pt[i].x;
                            cur.y = pt[k].y - pt[i].y;

                            if (xprod(constraint[0], cur) < 0 || xprod(constraint[1], cur) > 0) {
                                break;
                            }

                            if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) {

                            } else {
                                off.x = cur.x + ((cur.y >= 0 && (cur.y > 0 || cur.x < 0)) ? 1 : -1);
                                off.y = cur.y + ((cur.x <= 0 && (cur.x < 0 || cur.y < 0)) ? 1 : -1);
                                if (xprod(constraint[0], off) >= 0) {
                                    constraint[0].x = off.x;
                                    constraint[0].y = off.y;
                                }
                                off.x = cur.x + ((cur.y <= 0 && (cur.y < 0 || cur.x < 0)) ? 1 : -1);
                                off.y = cur.y + ((cur.x >= 0 && (cur.x > 0 || cur.y < 0)) ? 1 : -1);
                                if (xprod(constraint[1], off) <= 0) {
                                    constraint[1].x = off.x;
                                    constraint[1].y = off.y;
                                }
                            }
                            k1 = k;
                            k = nc[k1];
                            if (!cyclic(k, i, k1)) {
                                break;
                            }
                        }
                        if (foundk === 0) {
                            dk.x = sign(pt[k].x - pt[k1].x);
                            dk.y = sign(pt[k].y - pt[k1].y);
                            cur.x = pt[k1].x - pt[i].x;
                            cur.y = pt[k1].y - pt[i].y;

                            a = xprod(constraint[0], cur);
                            b = xprod(constraint[0], dk);
                            c = xprod(constraint[1], cur);
                            d = xprod(constraint[1], dk);

                            j = 10000000;
                            if (b < 0) {
                                j = Math.floor(a / -b);
                            }
                            if (d > 0) {
                                j = Math.min(j, Math.floor(-c / d));
                            }
                            pivk[i] = mod(k1 + j, n);
                        }
                    }

                    j = pivk[n - 1];
                    path.lon[n - 1] = j;
                    for (i = n - 2; i >= 0; i--) {
                        if (cyclic(i + 1, pivk[i], j)) {
                            j = pivk[i];
                        }
                        path.lon[i] = j;
                    }

                    for (i = n - 1; cyclic(mod(i + 1, n), j, path.lon[i]); i--) {
                        path.lon[i] = j;
                    }
                }

                function bestPolygon(path) {

                    function penalty3(path, i, j) {

                        var n = path.len, pt = path.pt, sums = path.sums;
                        var x, y, xy, x2, y2,
                            k, a, b, c, s,
                            px, py, ex, ey,
                            r = 0;
                        if (j >= n) {
                            j -= n;
                            r = 1;
                        }

                        if (r === 0) {
                            x = sums[j + 1].x - sums[i].x;
                            y = sums[j + 1].y - sums[i].y;
                            x2 = sums[j + 1].x2 - sums[i].x2;
                            xy = sums[j + 1].xy - sums[i].xy;
                            y2 = sums[j + 1].y2 - sums[i].y2;
                            k = j + 1 - i;
                        } else {
                            x = sums[j + 1].x - sums[i].x + sums[n].x;
                            y = sums[j + 1].y - sums[i].y + sums[n].y;
                            x2 = sums[j + 1].x2 - sums[i].x2 + sums[n].x2;
                            xy = sums[j + 1].xy - sums[i].xy + sums[n].xy;
                            y2 = sums[j + 1].y2 - sums[i].y2 + sums[n].y2;
                            k = j + 1 - i + n;
                        }

                        px = (pt[i].x + pt[j].x) / 2.0 - pt[0].x;
                        py = (pt[i].y + pt[j].y) / 2.0 - pt[0].y;
                        ey = (pt[j].x - pt[i].x);
                        ex = -(pt[j].y - pt[i].y);

                        a = ((x2 - 2 * x * px) / k + px * px);
                        b = ((xy - x * py - y * px) / k + px * py);
                        c = ((y2 - 2 * y * py) / k + py * py);

                        s = ex * ex * a + 2 * ex * ey * b + ey * ey * c;

                        return Math.sqrt(s);
                    }

                    var i, j, m, k,
                        n = path.len,
                        pen = new Array(n + 1),
                        prev = new Array(n + 1),
                        clip0 = new Array(n),
                        clip1 = new Array(n + 1),
                        seg0 = new Array(n + 1),
                        seg1 = new Array(n + 1),
                        thispen, best, c;

                    for (i = 0; i < n; i++) {
                        c = mod(path.lon[mod(i - 1, n)] - 1, n);
                        if (c == i) {
                            c = mod(i + 1, n);
                        }
                        if (c < i) {
                            clip0[i] = n;
                        } else {
                            clip0[i] = c;
                        }
                    }

                    j = 1;
                    for (i = 0; i < n; i++) {
                        while (j <= clip0[i]) {
                            clip1[j] = i;
                            j++;
                        }
                    }

                    i = 0;
                    for (j = 0; i < n; j++) {
                        seg0[j] = i;
                        i = clip0[i];
                    }
                    seg0[j] = n;
                    m = j;

                    i = n;
                    for (j = m; j > 0; j--) {
                        seg1[j] = i;
                        i = clip1[i];
                    }
                    seg1[0] = 0;

                    pen[0] = 0;
                    for (j = 1; j <= m; j++) {
                        for (i = seg1[j]; i <= seg0[j]; i++) {
                            best = -1;
                            for (k = seg0[j - 1]; k >= clip1[i]; k--) {
                                thispen = penalty3(path, k, i) + pen[k];
                                if (best < 0 || thispen < best) {
                                    prev[i] = k;
                                    best = thispen;
                                }
                            }
                            pen[i] = best;
                        }
                    }
                    path.m = m;
                    path.po = new Array(m);

                    for (i = n, j = m - 1; i > 0; j--) {
                        i = prev[i];
                        path.po[j] = i;
                    }
                }

                function adjustVertices(path) {

                    function pointslope(path, i, j, ctr, dir) {

                        var n = path.len, sums = path.sums,
                            x, y, x2, xy, y2,
                            k, a, b, c, lambda2, l, r = 0;

                        while (j >= n) {
                            j -= n;
                            r += 1;
                        }
                        while (i >= n) {
                            i -= n;
                            r -= 1;
                        }
                        while (j < 0) {
                            j += n;
                            r -= 1;
                        }
                        while (i < 0) {
                            i += n;
                            r += 1;
                        }

                        x = sums[j + 1].x - sums[i].x + r * sums[n].x;
                        y = sums[j + 1].y - sums[i].y + r * sums[n].y;
                        x2 = sums[j + 1].x2 - sums[i].x2 + r * sums[n].x2;
                        xy = sums[j + 1].xy - sums[i].xy + r * sums[n].xy;
                        y2 = sums[j + 1].y2 - sums[i].y2 + r * sums[n].y2;
                        k = j + 1 - i + r * n;

                        ctr.x = x / k;
                        ctr.y = y / k;

                        a = (x2 - x * x / k) / k;
                        b = (xy - x * y / k) / k;
                        c = (y2 - y * y / k) / k;

                        lambda2 = (a + c + Math.sqrt((a - c) * (a - c) + 4 * b * b)) / 2;

                        a -= lambda2;
                        c -= lambda2;

                        if (Math.abs(a) >= Math.abs(c)) {
                            l = Math.sqrt(a * a + b * b);
                            if (l !== 0) {
                                dir.x = -b / l;
                                dir.y = a / l;
                            }
                        } else {
                            l = Math.sqrt(c * c + b * b);
                            if (l !== 0) {
                                dir.x = -c / l;
                                dir.y = b / l;
                            }
                        }
                        if (l === 0) {
                            dir.x = dir.y = 0;
                        }
                    }

                    var m = path.m, po = path.po, n = path.len, pt = path.pt,
                        x0 = path.x0, y0 = path.y0,
                        ctr = new Array(m), dir = new Array(m),
                        q = new Array(m),
                        v = new Array(3), d, i, j, k, l,
                        s = new Point();

                    path.curve = new Curve(m);

                    for (i = 0; i < m; i++) {
                        j = po[mod(i + 1, m)];
                        j = mod(j - po[i], n) + po[i];
                        ctr[i] = new Point();
                        dir[i] = new Point();
                        pointslope(path, po[i], j, ctr[i], dir[i]);
                    }

                    for (i = 0; i < m; i++) {
                        q[i] = new Quad();
                        d = dir[i].x * dir[i].x + dir[i].y * dir[i].y;
                        if (d === 0.0) {
                            for (j = 0; j < 3; j++) {
                                for (k = 0; k < 3; k++) {
                                    q[i].data[j * 3 + k] = 0;
                                }
                            }
                        } else {
                            v[0] = dir[i].y;
                            v[1] = -dir[i].x;
                            v[2] = - v[1] * ctr[i].y - v[0] * ctr[i].x;
                            for (l = 0; l < 3; l++) {
                                for (k = 0; k < 3; k++) {
                                    q[i].data[l * 3 + k] = v[l] * v[k] / d;
                                }
                            }
                        }
                    }

                    var Q, w, dx, dy, det, min, cand, xmin, ymin, z;
                    for (i = 0; i < m; i++) {
                        Q = new Quad();
                        w = new Point();

                        s.x = pt[po[i]].x - x0;
                        s.y = pt[po[i]].y - y0;

                        j = mod(i - 1, m);

                        for (l = 0; l < 3; l++) {
                            for (k = 0; k < 3; k++) {
                                Q.data[l * 3 + k] = q[j].at(l, k) + q[i].at(l, k);
                            }
                        }

                        while (1) {

                            det = Q.at(0, 0) * Q.at(1, 1) - Q.at(0, 1) * Q.at(1, 0);
                            if (det !== 0.0) {
                                w.x = (-Q.at(0, 2) * Q.at(1, 1) + Q.at(1, 2) * Q.at(0, 1)) / det;
                                w.y = (Q.at(0, 2) * Q.at(1, 0) - Q.at(1, 2) * Q.at(0, 0)) / det;
                                break;
                            }

                            if (Q.at(0, 0) > Q.at(1, 1)) {
                                v[0] = -Q.at(0, 1);
                                v[1] = Q.at(0, 0);
                            } else if (Q.at(1, 1)) {
                                v[0] = -Q.at(1, 1);
                                v[1] = Q.at(1, 0);
                            } else {
                                v[0] = 1;
                                v[1] = 0;
                            }
                            d = v[0] * v[0] + v[1] * v[1];
                            v[2] = - v[1] * s.y - v[0] * s.x;
                            for (l = 0; l < 3; l++) {
                                for (k = 0; k < 3; k++) {
                                    Q.data[l * 3 + k] += v[l] * v[k] / d;
                                }
                            }
                        }
                        dx = Math.abs(w.x - s.x);
                        dy = Math.abs(w.y - s.y);
                        if (dx <= 0.5 && dy <= 0.5) {
                            path.curve.vertex[i] = new Point(w.x + x0, w.y + y0);
                            continue;
                        }

                        min = quadform(Q, s);
                        xmin = s.x;
                        ymin = s.y;

                        if (Q.at(0, 0) !== 0.0) {
                            for (z = 0; z < 2; z++) {
                                w.y = s.y - 0.5 + z;
                                w.x = - (Q.at(0, 1) * w.y + Q.at(0, 2)) / Q.at(0, 0);
                                dx = Math.abs(w.x - s.x);
                                cand = quadform(Q, w);
                                if (dx <= 0.5 && cand < min) {
                                    min = cand;
                                    xmin = w.x;
                                    ymin = w.y;
                                }
                            }
                        }

                        if (Q.at(1, 1) !== 0.0) {
                            for (z = 0; z < 2; z++) {
                                w.x = s.x - 0.5 + z;
                                w.y = - (Q.at(1, 0) * w.x + Q.at(1, 2)) / Q.at(1, 1);
                                dy = Math.abs(w.y - s.y);
                                cand = quadform(Q, w);
                                if (dy <= 0.5 && cand < min) {
                                    min = cand;
                                    xmin = w.x;
                                    ymin = w.y;
                                }
                            }
                        }

                        for (l = 0; l < 2; l++) {
                            for (k = 0; k < 2; k++) {
                                w.x = s.x - 0.5 + l;
                                w.y = s.y - 0.5 + k;
                                cand = quadform(Q, w);
                                if (cand < min) {
                                    min = cand;
                                    xmin = w.x;
                                    ymin = w.y;
                                }
                            }
                        }

                        path.curve.vertex[i] = new Point(xmin + x0, ymin + y0);
                    }
                }

                function reverse(path) {
                    var curve = path.curve, m = curve.n, v = curve.vertex, i, j, tmp;

                    for (i = 0, j = m - 1; i < j; i++, j--) {
                        tmp = v[i];
                        v[i] = v[j];
                        v[j] = tmp;
                    }
                }

                function smooth(path) {
                    var m = path.curve.n, curve = path.curve;

                    var i, j, k, dd, denom, alpha,
                        p2, p3, p4;

                    for (i = 0; i < m; i++) {
                        j = mod(i + 1, m);
                        k = mod(i + 2, m);
                        p4 = interval(1 / 2.0, curve.vertex[k], curve.vertex[j]);

                        denom = ddenom(curve.vertex[i], curve.vertex[k]);
                        if (denom !== 0.0) {
                            dd = dpara(curve.vertex[i], curve.vertex[j], curve.vertex[k]) / denom;
                            dd = Math.abs(dd);
                            alpha = dd > 1 ? (1 - 1.0 / dd) : 0;
                            alpha = alpha / 0.75;
                        } else {
                            alpha = 4 / 3.0;
                        }
                        curve.alpha0[j] = alpha;

                        if (alpha >= info.alphamax) {
                            curve.tag[j] = "CORNER";
                            curve.c[3 * j + 1] = curve.vertex[j];
                            curve.c[3 * j + 2] = p4;
                        } else {
                            if (alpha < 0.55) {
                                alpha = 0.55;
                            } else if (alpha > 1) {
                                alpha = 1;
                            }
                            p2 = interval(0.5 + 0.5 * alpha, curve.vertex[i], curve.vertex[j]);
                            p3 = interval(0.5 + 0.5 * alpha, curve.vertex[k], curve.vertex[j]);
                            curve.tag[j] = "CURVE";
                            curve.c[3 * j + 0] = p2;
                            curve.c[3 * j + 1] = p3;
                            curve.c[3 * j + 2] = p4;
                        }
                        curve.alpha[j] = alpha;
                        curve.beta[j] = 0.5;
                    }
                    curve.alphacurve = 1;
                }

                function optiCurve(path) {
                    function Opti() {
                        this.pen = 0;
                        this.c = [new Point(), new Point()];
                        this.t = 0;
                        this.s = 0;
                        this.alpha = 0;
                    }

                    function opti_penalty(path, i, j, res, opttolerance, convc, areac) {
                        var m = path.curve.n, curve = path.curve, vertex = curve.vertex,
                            k, k1, k2, conv, i1,
                            area, alpha, d, d1, d2,
                            p0, p1, p2, p3, pt,
                            A, R, A1, A2, A3, A4,
                            s, t;

                        if (i == j) {
                            return 1;
                        }

                        k = i;
                        i1 = mod(i + 1, m);
                        k1 = mod(k + 1, m);
                        conv = convc[k1];
                        if (conv === 0) {
                            return 1;
                        }
                        d = ddist(vertex[i], vertex[i1]);
                        for (k = k1; k != j; k = k1) {
                            k1 = mod(k + 1, m);
                            k2 = mod(k + 2, m);
                            if (convc[k1] != conv) {
                                return 1;
                            }
                            if (sign(cprod(vertex[i], vertex[i1], vertex[k1], vertex[k2])) !=
                                conv) {
                                return 1;
                            }
                            if (iprod1(vertex[i], vertex[i1], vertex[k1], vertex[k2]) <
                                d * ddist(vertex[k1], vertex[k2]) * -0.999847695156) {
                                return 1;
                            }
                        }

                        p0 = curve.c[mod(i, m) * 3 + 2].copy();
                        p1 = vertex[mod(i + 1, m)].copy();
                        p2 = vertex[mod(j, m)].copy();
                        p3 = curve.c[mod(j, m) * 3 + 2].copy();

                        area = areac[j] - areac[i];
                        area -= dpara(vertex[0], curve.c[i * 3 + 2], curve.c[j * 3 + 2]) / 2;
                        if (i >= j) {
                            area += areac[m];
                        }

                        A1 = dpara(p0, p1, p2);
                        A2 = dpara(p0, p1, p3);
                        A3 = dpara(p0, p2, p3);

                        A4 = A1 + A3 - A2;

                        if (A2 == A1) {
                            return 1;
                        }

                        t = A3 / (A3 - A4);
                        s = A2 / (A2 - A1);
                        A = A2 * t / 2.0;

                        if (A === 0.0) {
                            return 1;
                        }

                        R = area / A;
                        alpha = 2 - Math.sqrt(4 - R / 0.3);

                        res.c[0] = interval(t * alpha, p0, p1);
                        res.c[1] = interval(s * alpha, p3, p2);
                        res.alpha = alpha;
                        res.t = t;
                        res.s = s;

                        p1 = res.c[0].copy();
                        p2 = res.c[1].copy();

                        res.pen = 0;

                        for (k = mod(i + 1, m); k != j; k = k1) {
                            k1 = mod(k + 1, m);
                            t = tangent(p0, p1, p2, p3, vertex[k], vertex[k1]);
                            if (t < -0.5) {
                                return 1;
                            }
                            pt = bezier(t, p0, p1, p2, p3);
                            d = ddist(vertex[k], vertex[k1]);
                            if (d === 0.0) {
                                return 1;
                            }
                            d1 = dpara(vertex[k], vertex[k1], pt) / d;
                            if (Math.abs(d1) > opttolerance) {
                                return 1;
                            }
                            if (iprod(vertex[k], vertex[k1], pt) < 0 ||
                                iprod(vertex[k1], vertex[k], pt) < 0) {
                                return 1;
                            }
                            res.pen += d1 * d1;
                        }

                        for (k = i; k != j; k = k1) {
                            k1 = mod(k + 1, m);
                            t = tangent(p0, p1, p2, p3, curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
                            if (t < -0.5) {
                                return 1;
                            }
                            pt = bezier(t, p0, p1, p2, p3);
                            d = ddist(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
                            if (d === 0.0) {
                                return 1;
                            }
                            d1 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], pt) / d;
                            d2 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], vertex[k1]) / d;
                            d2 *= 0.75 * curve.alpha[k1];
                            if (d2 < 0) {
                                d1 = -d1;
                                d2 = -d2;
                            }
                            if (d1 < d2 - opttolerance) {
                                return 1;
                            }
                            if (d1 < d2) {
                                res.pen += (d1 - d2) * (d1 - d2);
                            }
                        }

                        return 0;
                    }

                    var curve = path.curve, m = curve.n, vert = curve.vertex,
                        pt = new Array(m + 1),
                        pen = new Array(m + 1),
                        len = new Array(m + 1),
                        opt = new Array(m + 1),
                        om, i, j, r,
                        o = new Opti(), p0,
                        i1, area, alpha, ocurve,
                        s, t;

                    var convc = new Array(m), areac = new Array(m + 1);

                    for (i = 0; i < m; i++) {
                        if (curve.tag[i] == "CURVE") {
                            convc[i] = sign(dpara(vert[mod(i - 1, m)], vert[i], vert[mod(i + 1, m)]));
                        } else {
                            convc[i] = 0;
                        }
                    }

                    area = 0.0;
                    areac[0] = 0.0;
                    p0 = curve.vertex[0];
                    for (i = 0; i < m; i++) {
                        i1 = mod(i + 1, m);
                        if (curve.tag[i1] == "CURVE") {
                            alpha = curve.alpha[i1];
                            area += 0.3 * alpha * (4 - alpha) *
                                dpara(curve.c[i * 3 + 2], vert[i1], curve.c[i1 * 3 + 2]) / 2;
                            area += dpara(p0, curve.c[i * 3 + 2], curve.c[i1 * 3 + 2]) / 2;
                        }
                        areac[i + 1] = area;
                    }

                    pt[0] = -1;
                    pen[0] = 0;
                    len[0] = 0;


                    for (j = 1; j <= m; j++) {
                        pt[j] = j - 1;
                        pen[j] = pen[j - 1];
                        len[j] = len[j - 1] + 1;

                        for (i = j - 2; i >= 0; i--) {
                            r = opti_penalty(path, i, mod(j, m), o, info.opttolerance, convc,
                                areac);
                            if (r) {
                                break;
                            }
                            if (len[j] > len[i] + 1 ||
                                (len[j] == len[i] + 1 && pen[j] > pen[i] + o.pen)) {
                                pt[j] = i;
                                pen[j] = pen[i] + o.pen;
                                len[j] = len[i] + 1;
                                opt[j] = o;
                                o = new Opti();
                            }
                        }
                    }
                    om = len[m];
                    ocurve = new Curve(om);
                    s = new Array(om);
                    t = new Array(om);

                    j = m;
                    for (i = om - 1; i >= 0; i--) {
                        if (pt[j] == j - 1) {
                            ocurve.tag[i] = curve.tag[mod(j, m)];
                            ocurve.c[i * 3 + 0] = curve.c[mod(j, m) * 3 + 0];
                            ocurve.c[i * 3 + 1] = curve.c[mod(j, m) * 3 + 1];
                            ocurve.c[i * 3 + 2] = curve.c[mod(j, m) * 3 + 2];
                            ocurve.vertex[i] = curve.vertex[mod(j, m)];
                            ocurve.alpha[i] = curve.alpha[mod(j, m)];
                            ocurve.alpha0[i] = curve.alpha0[mod(j, m)];
                            ocurve.beta[i] = curve.beta[mod(j, m)];
                            s[i] = t[i] = 1.0;
                        } else {
                            ocurve.tag[i] = "CURVE";
                            ocurve.c[i * 3 + 0] = opt[j].c[0];
                            ocurve.c[i * 3 + 1] = opt[j].c[1];
                            ocurve.c[i * 3 + 2] = curve.c[mod(j, m) * 3 + 2];
                            ocurve.vertex[i] = interval(opt[j].s, curve.c[mod(j, m) * 3 + 2],
                                vert[mod(j, m)]);
                            ocurve.alpha[i] = opt[j].alpha;
                            ocurve.alpha0[i] = opt[j].alpha;
                            s[i] = opt[j].s;
                            t[i] = opt[j].t;
                        }
                        j = pt[j];
                    }

                    for (i = 0; i < om; i++) {
                        i1 = mod(i + 1, om);
                        ocurve.beta[i] = s[i] / (s[i] + t[i1]);
                    }
                    ocurve.alphacurve = 1;
                    path.curve = ocurve;
                }

                for (var i = 0; i < pathlist.length; i++) {
                    var path = pathlist[i];
                    calcSums(path);
                    calcLon(path);
                    bestPolygon(path);
                    adjustVertices(path);

                    if (path.sign === "-") {
                        reverse(path);
                    }

                    smooth(path);

                    if (info.optcurve) {
                        optiCurve(path);
                    }
                }

            }

            function process(c) {
                if (c) {
                    callback = c;
                }
                if (!info.isReady) {
                    setTimeout(process, 100);
                    return;
                }
                bmToPathlist();
                processPath();
                callback();
                callback = null;
            }

            function clear() {
                bm = null;
                pathlist = [];
                callback = null;
                info.isReady = false;
            }

            function getSVG(size, opt_type) {

                function path(curve) {

                    function bezier(i) {
                        var b = 'C ' + (curve.c[i * 3 + 0].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 0].y * size).toFixed(3) + ',';
                        b += (curve.c[i * 3 + 1].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 1].y * size).toFixed(3) + ',';
                        b += (curve.c[i * 3 + 2].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 2].y * size).toFixed(3) + ' ';
                        return b;
                    }

                    function segment(i) {
                        var s = 'L ' + (curve.c[i * 3 + 1].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 1].y * size).toFixed(3) + ' ';
                        s += (curve.c[i * 3 + 2].x * size).toFixed(3) + ' ' +
                            (curve.c[i * 3 + 2].y * size).toFixed(3) + ' ';
                        return s;
                    }

                    var n = curve.n, i;
                    var p = 'M' + (curve.c[(n - 1) * 3 + 2].x * size).toFixed(3) +
                        ' ' + (curve.c[(n - 1) * 3 + 2].y * size).toFixed(3) + ' ';
                    for (i = 0; i < n; i++) {
                        if (curve.tag[i] === "CURVE") {
                            p += bezier(i);
                        } else if (curve.tag[i] === "CORNER") {
                            p += segment(i);
                        }
                    }
                    //p += 
                    return p;
                }

                var w = bm.w * size, h = bm.h * size,
                    len = pathlist.length, c, i, strokec, fillc, fillrule;

                var svg = '<svg id="svg" version="1.1" width="' + w + '" height="' + h +
                    '" xmlns="http://www.w3.org/2000/svg">';
                svg += '<path d="';
                for (i = 0; i < len; i++) {
                    c = pathlist[i].curve;
                    svg += path(c);
                }
                if (opt_type === "curve") {
                    strokec = "black";
                    fillc = "none";
                    fillrule = '';
                } else {
                    strokec = "none";
                    fillc = "black";
                    fillrule = ' fill-rule="evenodd"';
                }
                svg += '" stroke="' + strokec + '" fill="' + fillc + '"' + fillrule + '/></svg>';
                return svg;
            }

            return {
                loadImageFromFile: loadImageFromFile,
                loadImageFromUrl: loadImageFromUrl,
                setParameter: setParameter,
                process: process,
                getSVG: getSVG,
                img: imgElement
            };
        })();
    </script>

    <script>
        const EDITOR_VERSION = "1.1.1";
        const PRODUCT_ID = '1322BB7B-1510-4893-BD2D-FF1F19E404F7';
        const _proxyBase = 'https://elemental-svg-proxy.g7hjmj8t8f.workers.dev';

        // ============================================
        // SVG Editor State
        // ============================================
        const state = {
            initialized: false,
            theme: 'dark',
            accentColor: 'orange',
            svgItems: [],               // Array of {filename: string, originalSVG: string, currentSVG: SVGElement}
            rotation: 0,
            rotationIncrement: 30,
            flipH: false,
            flipV: false,
            opacity: 100,           // Icon opacity (0-100%)
            scale: 100,             // Icon scale (50-150%)
            offsetX: 0,             // X offset (-50 to +50% of viewBox)
            offsetY: 0,             // Y offset (-50 to +50% of viewBox)
            fillColor: '#000000',
            strokeColor: '#000000',
            strokeWidth: 0,
            bgEnabled: false,
            bgColor: '#ffffff',
            bgEdges: 4,
            iconPadding: 10,
            cornerRadius: 10,
            zoom: 1,
            fmCompatible: true,         // Apply FileMaker compatibility processing
            fmDynamicFill: true,        // Remove fills for FileMaker dynamic styling (vs baked-in color)
            fmDynamicTarget: 'icon',    // Which element FM controls: 'icon' or 'background'
            normalizePaths: false,      // Normalize path commands (can cause issues, off by default)
            fileMakerMode: false,       // True for FileMaker output, false for browser download. Set via initEditor({output_mode: 'fm'|'browser'})
            outputFormat: 'svg',        // 'svg' or 'png'
            outputSize: 512,            // Size for PNG export (e.g., 512 = 512x512)
            hasStrokeSVGs: false,       // True if any loaded SVGs are stroke-based
            convertStrokesToFills: true, // Convert stroke SVGs to filled paths on export
            previewBg: 'checkerboard',  // Preview background: 'checkerboard', 'white', 'black', 'custom'
            previewBgCustomColor: '#808080', // Custom preview background color
            autoConvert: false              // Auto-save converted files on load (browser mode only)
        };

        // ============================================
        // Undo/Redo History
        // ============================================
        const history = {
            undoStack: [],    // Stack of previous states
            redoStack: [],    // Stack of states for redo
            maxSize: 50       // Maximum history size
        };

        /**
         * Get the current state snapshot for history (only user-modifiable properties)
         */
        function getStateSnapshot() {
            return {
                rotation: state.rotation,
                flipH: state.flipH,
                flipV: state.flipV,
                opacity: state.opacity,
                scale: state.scale,
                offsetX: state.offsetX,
                offsetY: state.offsetY,
                fillColor: state.fillColor,
                strokeColor: state.strokeColor,
                strokeWidth: state.strokeWidth,
                bgEnabled: state.bgEnabled,
                bgColor: state.bgColor,
                bgEdges: state.bgEdges,
                iconPadding: state.iconPadding,
                cornerRadius: state.cornerRadius,
                svgItems: state.svgItems.map(item => ({
                    filename: item.filename,
                    originalSVG: item.originalSVG,
                    currentSVG: item.currentSVG.cloneNode(true)
                }))
            };
        }

        /**
         * Apply a state snapshot (restore from history)
         */
        function applyStateSnapshot(snapshot) {
            state.rotation = snapshot.rotation;
            state.flipH = snapshot.flipH;
            state.flipV = snapshot.flipV;
            state.opacity = snapshot.opacity !== undefined ? snapshot.opacity : 100;
            state.scale = snapshot.scale !== undefined ? snapshot.scale : 100;
            state.offsetX = snapshot.offsetX !== undefined ? snapshot.offsetX : 0;
            state.offsetY = snapshot.offsetY !== undefined ? snapshot.offsetY : 0;
            state.fillColor = snapshot.fillColor;
            state.strokeColor = snapshot.strokeColor;
            state.strokeWidth = snapshot.strokeWidth;
            state.bgEnabled = snapshot.bgEnabled;
            state.bgColor = snapshot.bgColor;
            // Support both new bgEdges and old bgShape format
            if (snapshot.bgEdges !== undefined) {
                state.bgEdges = snapshot.bgEdges;
            } else if (snapshot.bgShape !== undefined) {
                state.bgEdges = snapshot.bgShape === 'circle' ? 0 : 4;
            }
            state.iconPadding = snapshot.iconPadding;
            state.cornerRadius = snapshot.cornerRadius;

            // Restore svgItems if present in snapshot
            if (snapshot.svgItems) {
                state.svgItems = snapshot.svgItems.map(item => ({
                    filename: item.filename,
                    originalSVG: item.originalSVG,
                    currentSVG: item.currentSVG.cloneNode(true)
                }));
            }

            // Update UI to reflect restored state
            updateUIFromState();
            updateSaveButton();
            updateSizeInfo();
            renderPreview();

            // Show empty state if no SVGs remain
            if (!hasLoadedSVGs()) {
                showEmptyState();
            }
        }

        /**
         * Update all UI controls to reflect current state
         */
        function updateUIFromState() {
            // Rotation
            document.getElementById('rotation-value').textContent = state.rotation + '';

            // Adjustments
            document.getElementById('opacity-slider').value = state.opacity;
            document.getElementById('opacity-value').textContent = state.opacity + '%';
            document.getElementById('scale-slider').value = state.scale;
            document.getElementById('scale-value').textContent = state.scale + '%';
            document.getElementById('offset-x-slider').value = state.offsetX;
            document.getElementById('offset-x-value').textContent = state.offsetX;
            document.getElementById('offset-y-slider').value = state.offsetY;
            document.getElementById('offset-y-value').textContent = state.offsetY;

            // Fill color
            document.getElementById('fill-color').value = state.fillColor;
            document.getElementById('fill-hex').value = state.fillColor;
            document.getElementById('fill-color').parentElement.style.background = state.fillColor;

            // Stroke color
            document.getElementById('stroke-color').value = state.strokeColor;
            document.getElementById('stroke-hex').value = state.strokeColor;
            document.getElementById('stroke-color').parentElement.style.background = state.strokeColor;

            // Stroke width
            document.getElementById('stroke-width').value = state.strokeWidth;
            document.getElementById('stroke-value').textContent = state.strokeWidth;

            // Background
            document.getElementById('bg-enabled').checked = state.bgEnabled;
            document.getElementById('bg-options').classList.toggle('visible', state.bgEnabled);
            document.getElementById('bg-color').value = state.bgColor;
            document.getElementById('bg-hex').value = state.bgColor;
            document.getElementById('bg-color-preview').style.background = state.bgColor;

            // Padding and corner radius
            document.getElementById('icon-padding').value = state.iconPadding;
            document.getElementById('padding-value').textContent = state.iconPadding + '%';
            document.getElementById('corner-radius').value = state.cornerRadius;
            document.getElementById('radius-value').textContent = state.cornerRadius + '%';

            // Background edges
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === 'shape-edges-' + state.bgEdges);
            });
            document.getElementById('edges-value').textContent = state.bgEdges;
            document.getElementById('edges-label').textContent = getEdgesLabel(state.bgEdges);
            document.getElementById('corner-radius-control').style.display =
                (state.bgEdges === 0) ? 'none' : 'block';

            // Update FM target visibility
            updateFMTargetVisibility();
        }

        /**
         * Push current state to undo stack (call before making a change)
         */
        function pushToHistory() {
            const snapshot = getStateSnapshot();
            history.undoStack.push(snapshot);

            // Limit history size
            if (history.undoStack.length > history.maxSize) {
                history.undoStack.shift();
            }

            // Clear redo stack when new action is performed
            history.redoStack = [];

            updateHistoryButtons();
        }

        /**
         * Undo the last action
         */
        function undo() {
            if (history.undoStack.length === 0) return;

            // Save current state to redo stack
            history.redoStack.push(getStateSnapshot());

            // Pop and apply the previous state
            const previousState = history.undoStack.pop();
            applyStateSnapshot(previousState);

            updateHistoryButtons();
        }

        /**
         * Redo the last undone action
         */
        function redo() {
            if (history.redoStack.length === 0) return;

            // Save current state to undo stack
            history.undoStack.push(getStateSnapshot());

            // Pop and apply the redo state
            const redoState = history.redoStack.pop();
            applyStateSnapshot(redoState);

            updateHistoryButtons();
        }

        /**
         * Update the enabled/disabled state of undo/redo buttons
         */
        function updateHistoryButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');

            if (undoBtn) {
                undoBtn.disabled = history.undoStack.length === 0;
            }
            if (redoBtn) {
                redoBtn.disabled = history.redoStack.length === 0;
            }
        }

        /**
         * Clear all history
         */
        function clearHistory() {
            history.undoStack = [];
            history.redoStack = [];
            updateHistoryButtons();
        }

        /**
         * Check if there are changes that can be undone
         */
        function hasUndoableChanges() {
            return history.undoStack.length > 0;
        }

        // ============================================
        // Confirmation Modal
        // ============================================
        let modalConfirmCallback = null;

        /**
         * Show the confirmation modal
         * @param {Object} options - Modal configuration
         * @param {string} options.title - Modal title
         * @param {string} options.message - Modal message
         * @param {string} options.confirmText - Text for confirm button
         * @param {Function} options.onConfirm - Callback when confirmed
         */
        function showConfirmModal(options) {
            const modal = document.getElementById('confirm-modal');
            const titleEl = document.getElementById('modal-title');
            const messageEl = document.getElementById('modal-message');
            const confirmBtn = document.getElementById('modal-confirm-btn');
            const iconEl = document.getElementById('modal-icon');

            titleEl.textContent = options.title || 'Confirm';
            if (options.messageHtml) {
                messageEl.innerHTML = options.messageHtml;
            } else {
                messageEl.textContent = options.message || 'Are you sure?';
            }
            confirmBtn.textContent = options.confirmText || 'Confirm';
            modalConfirmCallback = options.onConfirm || null;

            if (options.icon) {
                iconEl.innerHTML = options.icon;
            } else {
                iconEl.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /></svg>';
            }

            document.getElementById('modal-cancel-btn').style.display = options.hideCancel ? 'none' : '';

            modal.classList.add('visible');

            // Close on escape key
            document.addEventListener('keydown', handleModalEscape);

            // Close on overlay click
            modal.addEventListener('click', handleModalOverlayClick);
        }

        /**
         * Hide the confirmation modal
         */
        function hideConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            modal.classList.remove('visible');
            modalConfirmCallback = null;

            document.removeEventListener('keydown', handleModalEscape);
            modal.removeEventListener('click', handleModalOverlayClick);
        }

        /**
         * Handle confirm button click
         */
        function confirmModalAction() {
            if (modalConfirmCallback) {
                modalConfirmCallback();
            }
            hideConfirmModal();
        }

        /**
         * Handle escape key to close modal
         */
        function handleModalEscape(e) {
            if (e.key === 'Escape') {
                hideConfirmModal();
            }
        }

        /**
         * Handle click on overlay (outside card) to close modal
         */
        function handleModalOverlayClick(e) {
            if (e.target.id === 'confirm-modal') {
                hideConfirmModal();
            }
        }

        // ============================================
        // Progress Modal (for batch conversion)
        // ============================================

        let _progressCancelled = false;

        function showProgressModal(title, total) {
            _progressCancelled = false;
            const modal = document.getElementById('progress-modal');
            document.getElementById('progress-title').textContent = title;
            document.getElementById('progress-text').textContent = `0 of ${total}`;
            document.getElementById('progress-bar').style.width = '0%';
            modal.classList.add('visible');
        }

        function updateProgressModal(current, total) {
            document.getElementById('progress-text').textContent = `${current} of ${total}`;
            document.getElementById('progress-bar').style.width = `${Math.round((current / total) * 100)}%`;
        }

        function hideProgressModal() {
            document.getElementById('progress-modal').classList.remove('visible');
        }

        function cancelProgressModal() {
            _progressCancelled = true;
            hideProgressModal();
        }

        function isProgressCancelled() {
            return _progressCancelled;
        }

        // ============================================
        // Issue Report Modal
        // ============================================

        function showIssueReport() {
            const modal = document.getElementById('issue-report-modal');
            // Clear previous inputs
            document.getElementById('issue-report-email').value = '';
            document.getElementById('issue-report-details').value = '';
            modal.classList.add('visible');
            setTimeout(() => document.getElementById('issue-report-email').focus(), 200);

            document.addEventListener('keydown', handleIssueReportEscape);
            modal.addEventListener('click', handleIssueReportOverlayClick);
        }

        function hideIssueReport() {
            const modal = document.getElementById('issue-report-modal');
            modal.classList.remove('visible');
            document.removeEventListener('keydown', handleIssueReportEscape);
            modal.removeEventListener('click', handleIssueReportOverlayClick);
        }

        function handleIssueReportEscape(e) {
            if (e.key === 'Escape') {
                hideIssueReport();
            }
        }

        function handleIssueReportOverlayClick(e) {
            if (e.target.id === 'issue-report-modal') {
                hideIssueReport();
            }
        }

        /**
         * Build the diagnostic payload with all relevant info
         */
        function buildIssueReportPayload() {
            const serializer = new XMLSerializer();
            const svgs = state.svgItems.map(item => {
                // Generate the processed output the same way saveSVGFormat does
                let processedSVG = null;
                try {
                    const finalSVG = generateFinalSVG(item);
                    if (finalSVG) {
                        if (state.fmCompatible) {
                            processedSVG = serializer.serializeToString(processSVGForFileMaker(finalSVG));
                        } else {
                            processedSVG = serializer.serializeToString(finalSVG);
                        }
                    }
                } catch (e) {
                    processedSVG = '(error generating output: ' + e.message + ')';
                }

                return {
                    filename: item.filename,
                    original: item.originalSVG,
                    processed: processedSVG
                };
            });

            // Snapshot editor settings (exclude non-serializable stuff)
            const editorState = {
                rotation: state.rotation,
                rotationIncrement: state.rotationIncrement,
                flipH: state.flipH,
                flipV: state.flipV,
                opacity: state.opacity,
                scale: state.scale,
                offsetX: state.offsetX,
                offsetY: state.offsetY,
                fillColor: state.fillColor,
                strokeColor: state.strokeColor,
                strokeWidth: state.strokeWidth,
                bgEnabled: state.bgEnabled,
                bgColor: state.bgColor,
                bgEdges: state.bgEdges,
                iconPadding: state.iconPadding,
                cornerRadius: state.cornerRadius,
                fmCompatible: state.fmCompatible,
                fmDynamicFill: state.fmDynamicFill,
                fmDynamicTarget: state.fmDynamicTarget,
                normalizePaths: state.normalizePaths,
                fileMakerMode: state.fileMakerMode,
                outputFormat: state.outputFormat,
                outputSize: state.outputSize,
                hasStrokeSVGs: state.hasStrokeSVGs,
                convertStrokesToFills: state.convertStrokesToFills
            };

            // Environment info (same as usage tracking payload)
            const ua = navigator.userAgent;
            let browserName = 'Unknown', browserVersion = '';
            if (ua.match(/edg\//i)) { browserName = 'Edge'; browserVersion = (ua.match(/edg\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/opr\//i) || ua.match(/opera/i)) { browserName = 'Opera'; browserVersion = (ua.match(/(?:opr|opera)\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/chrome/i) && !ua.match(/edg/i)) { browserName = 'Chrome'; browserVersion = (ua.match(/chrome\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/safari/i) && !ua.match(/chrome/i)) { browserName = 'Safari'; browserVersion = (ua.match(/version\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/firefox/i)) { browserName = 'Firefox'; browserVersion = (ua.match(/firefox\/([\d.]+)/i) || [])[1]; }

            return {
                product_id: PRODUCT_ID,
                timestamp: new Date().toISOString(),
                email: document.getElementById('issue-report-email').value.trim() || null,
                description: document.getElementById('issue-report-details').value.trim() || null,
                svgCount: svgs.length,
                svgs: svgs,
                editorVersion: EDITOR_VERSION,
                editorState: editorState,
                userAgent: ua,
                browser: browserName + (browserVersion ? ' ' + browserVersion : ''),
                platform: navigator.platform || '',
                language: navigator.language || '',
                screenWidth: screen.width,
                screenHeight: screen.height,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || '',
                referrer: document.referrer || '',
                colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light',
                touchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
                connectionType: (navigator.connection && navigator.connection.effectiveType) || ''
            };
        }

        const ISSUE_REPORT_WEBHOOK = _proxyBase + '/report';

        async function submitIssueReport() {
            const description = document.getElementById('issue-report-details').value.trim();
            if (!description) {
                document.getElementById('issue-report-details').focus();
                document.getElementById('issue-report-details').style.borderColor = 'var(--accent)';
                setTimeout(() => {
                    document.getElementById('issue-report-details').style.borderColor = '';
                }, 2000);
                return;
            }

            const submitBtn = document.getElementById('issue-report-submit-btn');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';

            const payload = buildIssueReportPayload();

            // Try to include public IP (best-effort, don't block on failure)
            try {
                const ipResp = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipResp.json();
                payload.ip = ipData.ip;
            } catch (e) { payload.ip = ''; }

            try {
                const response = await fetch(ISSUE_REPORT_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                hideIssueReport();

                if (response.ok) {
                    showConfirmModal({
                        title: 'Report Submitted',
                        message: 'Thank you! Your issue has been sent to me for further investigation.' +
                            (payload.email ? ' I\'ll contact you at ' + payload.email + ' when a fix is available.' : '') +
                            '\n\n- Daniel (FM Weetbicks)',
                        confirmText: 'OK',
                        hideCancel: true,
                        icon: '<svg viewBox="0 0 24 24" fill="#4ade80" stroke="none"><path d="M14 9V5.5A2.5 2.5 0 0 0 11.5 3c-.55 0-1.05.22-1.41.59L4 10v11h14.28a2 2 0 0 0 1.97-1.67l1.23-7A2 2 0 0 0 19.52 10H14zM4 10H2v11h2V10z"/></svg>',
                        onConfirm: () => { }
                    });
                } else {
                    showConfirmModal({
                        title: 'Submission Failed',
                        message: 'The report could not be sent (server returned ' + response.status + '). Please try again later.',
                        confirmText: 'OK',
                        hideCancel: true,
                        onConfirm: () => { }
                    });
                }
            } catch (e) {
                hideIssueReport();
                showConfirmModal({
                    title: 'Submission Failed',
                    message: 'Could not connect to the server. Please check your internet connection and try again.',
                    confirmText: 'OK',
                    hideCancel: true,
                    onConfirm: () => { }
                });
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        // Temporary storage for slider state before drag
        let sliderStateBeforeDrag = null;

        /**
         * Save state before slider drag starts
         * Called on mousedown/touchstart of sliders
         */
        function saveSliderState() {
            if (!sliderStateBeforeDrag) sliderStateBeforeDrag = getStateSnapshot();
        }

        /**
         * Commit slider state to history if it changed
         * Called by slider update functions with commit=true
         */
        function commitSliderState() {
            if (sliderStateBeforeDrag) {
                // Push the saved state before drag to history
                history.undoStack.push(sliderStateBeforeDrag);
                if (history.undoStack.length > history.maxSize) {
                    history.undoStack.shift();
                }
                history.redoStack = [];
                updateHistoryButtons();
                sliderStateBeforeDrag = null;
            }
        }

        // ============================================
        // Initialization
        // ============================================

        /**
         * Initialize the SVG Editor
         * @param {Object} config - Configuration object
         * @param {string} config.style - 'dark' or 'light' theme (defaults to OS preference)
         * @param {string} config.style_colour - Accent color: 'red', 'blue', 'green', 'purple', 'pink', 'orange' (defaults to 'orange')
         * @param {string} config.output_mode - 'fm' for FileMaker or 'browser' for local download (defaults to 'browser')
         * @param {string} config.output_format - 'svg' or 'png' (defaults to 'svg')
         * @param {number} config.output_size - Size for PNG export, e.g. 512 for 512x512 (defaults to 512)
         */
        function initEditor(config = {}) {
            const alreadyInitialized = state.initialized;

            // Parse config if it's a string (JSON)
            let cfg = config;
            if (typeof config === 'string') {
                try {
                    cfg = JSON.parse(config);
                } catch (e) {
                    console.warn('Invalid config JSON, using defaults');
                    cfg = {};
                }
            }

            // Set output mode - default to browser mode
            state.fileMakerMode = (cfg.output_mode === 'fm');

            // Track whether the BaseElements plugin is available (needed for button bar)
            state.pluginMissing = (cfg.plugin_missing === 1);

            // Set output format - default to 'svg'
            if (cfg.output_format === 'png') {
                state.outputFormat = 'png';
            } else {
                state.outputFormat = 'svg';
            }

            // Set output size for PNG - default to 512
            const validSizes = [32, 64, 128, 256, 512, 1024];
            if (cfg.output_size && validSizes.includes(cfg.output_size)) {
                state.outputSize = cfg.output_size;
            } else {
                state.outputSize = 512;
            }

            // Load saved preferences (localStorage) - used as fallback when config doesn't specify
            const savedPrefs = loadPreferences();

            // Set theme - config > saved prefs > OS preference
            let validTheme;
            if (cfg.style === 'light' || cfg.style === 'dark') {
                validTheme = cfg.style;
            } else if (savedPrefs && (savedPrefs.theme === 'light' || savedPrefs.theme === 'dark')) {
                validTheme = savedPrefs.theme;
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                validTheme = prefersDark ? 'dark' : 'light';
            }
            state.theme = validTheme;
            document.body.setAttribute('data-theme', validTheme);

            // Set accent color - config > saved prefs > default orange
            const validAccents = ['red', 'blue', 'green', 'purple', 'pink', 'orange'];
            let accentColor;
            if (validAccents.includes(cfg.style_colour)) {
                accentColor = cfg.style_colour;
            } else if (savedPrefs && validAccents.includes(savedPrefs.accentColor)) {
                accentColor = savedPrefs.accentColor;
            } else {
                accentColor = 'orange';
            }
            state.accentColor = accentColor;
            if (accentColor !== 'orange') {
                document.body.setAttribute('data-accent', accentColor);
            }
            // Update swatch UI
            document.querySelectorAll('.accent-swatch').forEach(swatch => {
                swatch.classList.toggle('active', swatch.dataset.color === accentColor);
            });

            // Restore other saved preferences (only on first init, don't override config)
            if (!alreadyInitialized && savedPrefs) {
                if (savedPrefs.fmCompatible !== undefined) {
                    state.fmCompatible = savedPrefs.fmCompatible;
                    const fmCheckbox = document.getElementById('fm-compat');
                    if (fmCheckbox) fmCheckbox.checked = state.fmCompatible;
                }
                if (savedPrefs.fmDynamicFill !== undefined) {
                    state.fmDynamicFill = savedPrefs.fmDynamicFill;
                    const dynCheckbox = document.getElementById('fm-dynamic');
                    if (dynCheckbox) dynCheckbox.checked = state.fmDynamicFill;
                }
                if (savedPrefs.previewBg) {
                    state.previewBg = savedPrefs.previewBg;
                }
                if (savedPrefs.previewBgCustomColor) {
                    state.previewBgCustomColor = savedPrefs.previewBgCustomColor;
                }
                if (savedPrefs.autoConvert !== undefined) {
                    state.autoConvert = savedPrefs.autoConvert;
                    const acCheckbox = document.getElementById('auto-convert');
                    if (acCheckbox) acCheckbox.checked = state.autoConvert;
                }
            }

            // One-time setup (only on first init)
            if (!alreadyInitialized) {
                // Show the editor
                const container = document.getElementById('editor-container');
                container.classList.add('initialized');

                // Setup drag and drop
                setupDragAndDrop();

                // Setup message listener
                setupMessageListener();

                // Setup scroll wheel zoom
                setupScrollZoom();

                // Setup scroll wheel rotation
                setupScrollRotation();

                // Setup keyboard shortcuts
                setupKeyboardShortcuts();

                // Setup collapsible sections
                setupCollapsibleSections();

                state.initialized = true;
            }

            // Update UI to reflect current state
            updateFormatUI();
            updateSaveButton();

            // Apply restored preview background
            if (state.previewBg !== 'checkerboard') {
                setPreviewBg(state.previewBg);
            }

            // Hide controls panel initially when no SVGs loaded
            updateControlsPanelVisibility();

            // Restore from issue report if initStateJSON is provided
            if (cfg.initStateJSON) {
                let reportData = cfg.initStateJSON;
                if (typeof reportData === 'string') {
                    try { reportData = JSON.parse(reportData); } catch (e) {
                        console.warn('Invalid initStateJSON, ignoring');
                        reportData = null;
                    }
                }
                if (reportData) {
                    setTimeout(() => restoreFromReport(reportData), 100);
                }
            }

            console.log('SVG Editor', alreadyInitialized ? 'reconfigured' : 'initialized', 'with theme:', validTheme, 'accent:', accentColor, 'output mode:', cfg.output_mode || 'browser', 'format:', state.outputFormat, 'size:', state.outputSize);
        }

        /**
         * Restore the editor to the exact state captured in an issue report.
         * Loads the original SVGs and applies all editor settings + UI.
         * @param {Object} reportData - The issue report payload (or its shape)
         */
        function restoreFromReport(reportData) {
            try {
                // 1. Load the original SVGs
                const svgs = reportData.svgs || [];
                if (svgs.length > 0) {
                    state.svgItems = [];
                    resetState();
                    clearHistory();

                    let loaded = 0;
                    svgs.forEach(entry => {
                        const svgString = entry.original;
                        if (svgString && addSVGItem(entry.filename || 'untitled.svg', svgString)) {
                            loaded++;
                        }
                    });

                    if (loaded === 0) {
                        console.warn('[restoreFromReport] No valid SVGs found in report');
                        return;
                    }
                }

                // 2. Apply editor state
                const es = reportData.editorState;
                if (!es) {
                    renderPreview();
                    updateSizeInfo();
                    updateSaveButton();
                    detectStrokeSVGs();
                    setTimeout(autoZoom, 50);
                    return;
                }

                // Rotation
                if (es.rotation !== undefined) {
                    state.rotation = es.rotation;
                    document.getElementById('rotation-value').textContent = es.rotation + '\u00B0';
                }
                if (es.rotationIncrement !== undefined) {
                    state.rotationIncrement = es.rotationIncrement;
                    document.querySelectorAll('.increment-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.textContent === es.rotationIncrement + '\u00B0');
                    });
                }

                // Flip
                if (es.flipH !== undefined) state.flipH = es.flipH;
                if (es.flipV !== undefined) state.flipV = es.flipV;

                // Opacity
                if (es.opacity !== undefined) {
                    state.opacity = es.opacity;
                    document.getElementById('opacity-slider').value = es.opacity;
                    document.getElementById('opacity-value').textContent = es.opacity + '%';
                }

                // Scale
                if (es.scale !== undefined) {
                    state.scale = es.scale;
                    document.getElementById('scale-slider').value = es.scale;
                    document.getElementById('scale-value').textContent = es.scale + '%';
                }

                // Offsets
                if (es.offsetX !== undefined) {
                    state.offsetX = es.offsetX;
                    document.getElementById('offset-x-slider').value = es.offsetX;
                    document.getElementById('offset-x-value').textContent = es.offsetX;
                }
                if (es.offsetY !== undefined) {
                    state.offsetY = es.offsetY;
                    document.getElementById('offset-y-slider').value = es.offsetY;
                    document.getElementById('offset-y-value').textContent = es.offsetY;
                }

                // Fill color
                if (es.fillColor !== undefined) {
                    state.fillColor = es.fillColor;
                    document.getElementById('fill-color').value = es.fillColor;
                    document.getElementById('fill-hex').value = es.fillColor;
                    document.getElementById('fill-color').parentElement.style.background = es.fillColor;
                }

                // Stroke color & width
                if (es.strokeColor !== undefined) {
                    state.strokeColor = es.strokeColor;
                    document.getElementById('stroke-color').value = es.strokeColor;
                    document.getElementById('stroke-hex').value = es.strokeColor;
                    document.getElementById('stroke-color').parentElement.style.background = es.strokeColor;
                }
                if (es.strokeWidth !== undefined) {
                    state.strokeWidth = es.strokeWidth;
                    document.getElementById('stroke-width').value = es.strokeWidth;
                    document.getElementById('stroke-value').textContent = es.strokeWidth;
                }

                // Background
                if (es.bgEnabled !== undefined) {
                    state.bgEnabled = es.bgEnabled;
                    document.getElementById('bg-enabled').checked = es.bgEnabled;
                    document.getElementById('bg-options').classList.toggle('visible', es.bgEnabled);
                }
                if (es.bgColor !== undefined) {
                    state.bgColor = es.bgColor;
                    document.getElementById('bg-color').value = es.bgColor;
                    document.getElementById('bg-hex').value = es.bgColor;
                    document.getElementById('bg-color-preview').style.background = es.bgColor;
                }
                if (es.bgEdges !== undefined) {
                    state.bgEdges = es.bgEdges;
                    document.querySelectorAll('.shape-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.id === 'shape-edges-' + es.bgEdges);
                    });
                    document.getElementById('edges-value').textContent = es.bgEdges;
                    document.getElementById('edges-label').textContent = getEdgesLabel(es.bgEdges);
                    const radiusControl = document.getElementById('corner-radius-control');
                    radiusControl.style.display = (es.bgEdges === 0) ? 'none' : 'block';
                } else if (es.bgShape !== undefined) {
                    // Backward compat: convert old bgShape string
                    state.bgEdges = es.bgShape === 'circle' ? 0 : 4;
                    document.querySelectorAll('.shape-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.id === 'shape-edges-' + state.bgEdges);
                    });
                    document.getElementById('edges-value').textContent = state.bgEdges;
                    document.getElementById('edges-label').textContent = getEdgesLabel(state.bgEdges);
                    const radiusControl = document.getElementById('corner-radius-control');
                    radiusControl.style.display = (state.bgEdges === 0) ? 'none' : 'block';
                }
                if (es.iconPadding !== undefined) {
                    state.iconPadding = es.iconPadding;
                    document.getElementById('icon-padding').value = es.iconPadding;
                    document.getElementById('padding-value').textContent = es.iconPadding + '%';
                }
                if (es.cornerRadius !== undefined) {
                    state.cornerRadius = es.cornerRadius;
                    document.getElementById('corner-radius').value = es.cornerRadius;
                    document.getElementById('radius-value').textContent = es.cornerRadius + '%';
                }

                // Export settings
                if (es.fmCompatible !== undefined) {
                    state.fmCompatible = es.fmCompatible;
                    const cb = document.getElementById('fm-compat');
                    if (cb) cb.checked = es.fmCompatible;
                }
                if (es.fmDynamicFill !== undefined) {
                    state.fmDynamicFill = es.fmDynamicFill;
                    const cb = document.getElementById('fm-dynamic');
                    if (cb) cb.checked = es.fmDynamicFill;
                }
                if (es.fmDynamicTarget !== undefined) {
                    setFMTarget(es.fmDynamicTarget);
                }
                if (es.normalizePaths !== undefined) {
                    state.normalizePaths = es.normalizePaths;
                }
                if (es.outputFormat !== undefined) {
                    state.outputFormat = es.outputFormat;
                }
                if (es.outputSize !== undefined) {
                    state.outputSize = es.outputSize;
                }
                if (es.convertStrokesToFills !== undefined) {
                    state.convertStrokesToFills = es.convertStrokesToFills;
                    const cb = document.getElementById('convert-strokes');
                    if (cb) cb.checked = es.convertStrokesToFills;
                }

                updateFMTargetVisibility();
                updateFormatUI();
                renderPreview();
                updateSizeInfo();
                updateSaveButton();
                detectStrokeSVGs();
                setTimeout(autoZoom, 50);

                console.log('[restoreFromReport] Editor state restored from issue report');
            } catch (e) {
                console.error('[restoreFromReport] Error restoring state:', e);
            }
        }

        /**
         * Setup drag and drop handlers
         */
        function setupDragAndDrop() {
            const dropZone = document.getElementById('drop-zone');

            // Prevent default drag behaviors on the drop zone only
            // (Do NOT add to document.body - that blocks page scrolling when embedded)
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop zone when dragging over
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            // Handle dropped files
            dropZone.addEventListener('drop', handleDrop, false);
        }

        /**
         * Setup postMessage listener for iframe communication
         */
        function setupMessageListener() {
            window.addEventListener('message', function (event) {
                if (event.data && event.data.type === 'loadSVG') {
                    loadSVG(event.data.data);
                }
            });
        }

        /**
         * Setup scroll wheel zoom on the zoom level display and preview container
         */
        function setupScrollZoom() {
            const zoomLevel = document.getElementById('zoom-level');
            const previewContainer = document.querySelector('.preview-container');

            // Wheel handler for zooming (editor mode only)
            function handleWheelZoom(e) {
                if (ibIsLibraryMode()) return;
                e.preventDefault();

                // Determine scroll direction: negative deltaY = scroll up = zoom in
                const delta = e.deltaY < 0 ? 0.1 : -0.1;
                adjustZoom(delta);
            }

            // Add zoom to the zoom level text
            if (zoomLevel) {
                zoomLevel.addEventListener('wheel', handleWheelZoom, { passive: false });
                // Add cursor style to indicate scrollability
                zoomLevel.style.cursor = 'ns-resize';
            }

            // Add zoom to the preview container (only when modifier key held, editor mode only)
            if (previewContainer) {
                previewContainer.addEventListener('wheel', function (e) {
                    if (ibIsLibraryMode()) return;
                    // Only zoom when Cmd/Ctrl is held
                    if (!(e.metaKey || e.ctrlKey)) return;
                    // Only handle zoom if SVGs are loaded
                    if (!hasLoadedSVGs()) return;
                    e.preventDefault();
                    const delta = e.deltaY < 0 ? 0.05 : -0.05;
                    adjustZoom(delta);
                }, { passive: false });
            }
        }

        /**
         * Setup scroll wheel rotation on the rotation value display
         */
        function setupScrollRotation() {
            const rotationValue = document.getElementById('rotation-value');

            if (rotationValue) {
                rotationValue.addEventListener('wheel', function (e) {
                    e.preventDefault();

                    // Only rotate if SVGs are loaded
                    if (!hasLoadedSVGs()) return;

                    pushToHistory();

                    // Scroll up = increase rotation, scroll down = decrease
                    const delta = e.deltaY < 0 ? 1 : -1;

                    // Update rotation with wrapping (0-359)
                    state.rotation = (state.rotation + delta + 360) % 360;
                    document.getElementById('rotation-value').textContent = state.rotation + '';
                    renderPreview();
                }, { passive: false });

                // Add cursor style to indicate scrollability
                rotationValue.style.cursor = 'ns-resize';
            }
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e) {
            document.getElementById('drop-zone').classList.add('drag-over');
        }

        function unhighlight(e) {
            document.getElementById('drop-zone').classList.remove('drag-over');
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                handleDroppedFiles(Array.from(files));
            }
        }

        /**
         * Handle files dropped onto the preview area
         * @param {File[]} files - Array of files to handle
         */
        function handleDroppedFiles(files) {
            // Filter to only SVG files
            const svgFiles = files.filter(file =>
                file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')
            );

            if (svgFiles.length === 0) {
                alert('Please drop SVG files.');
                return;
            }

            // If there are existing SVGs with changes, ask for confirmation
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                pendingFiles = svgFiles;
                showConfirmModal({
                    title: 'Load New SVGs?',
                    message: 'You have unsaved changes to the current SVGs. Loading new files will discard these changes.',
                    confirmText: 'Load New',
                    onConfirm: loadPendingFiles
                });
                return;
            }

            // No existing changes, load directly
            loadFilesAsSVG(svgFiles);
        }

        // Pending files to load after confirmation
        let pendingFiles = null;

        /**
         * Trigger the file input dialog
         * Called by Load button or empty state click
         */
        function triggerFileLoad() {
            document.getElementById('svg-file-input').click();
        }

        /**
         * Handle file selection from the file input
         */
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            // Reset the input so the same files can be selected again
            event.target.value = '';

            // Filter to only SVG files
            const svgFiles = files.filter(file =>
                file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')
            );

            if (svgFiles.length === 0) {
                alert('Please select SVG files.');
                return;
            }

            // If there are existing SVGs with changes, ask for confirmation
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                pendingFiles = svgFiles;
                showConfirmModal({
                    title: 'Load New SVGs?',
                    message: 'You have unsaved changes to the current SVGs. Loading new files will discard these changes.',
                    confirmText: 'Load New',
                    onConfirm: loadPendingFiles
                });
                return;
            }

            // No existing changes, load directly
            loadFilesAsSVG(svgFiles);
        }

        /**
         * Load the pending files after confirmation
         */
        function loadPendingFiles() {
            if (pendingFiles) {
                loadFilesAsSVG(pendingFiles);
                pendingFiles = null;
            }
        }

        /**
         * Read multiple files and load as SVGs
         * @param {File[]} files - Array of SVG files to load
         */
        function loadFilesAsSVG(files) {
            // Clear existing SVGs and reset state
            state.svgItems = [];
            resetState();
            clearHistory();

            let loadedCount = 0;
            const totalFiles = files.length;

            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const svgContent = e.target.result;
                    addSVGItem(file.name, svgContent);
                    loadedCount++;

                    // When all files are loaded, render and auto-zoom
                    if (loadedCount === totalFiles) {
                        renderPreview();
                        updateSizeInfo();
                        updateSaveButton();
                        detectStrokeSVGs();
                        setTimeout(autoZoom, 50);
                        // Auto-convert: trigger save after load if enabled
                        if (state.autoConvert) {
                            const count = totalFiles;
                            const format = state.outputFormat === 'png' ? 'PNG' : 'SVG';
                            setTimeout(async () => {
                                await saveSVG();
                                const action = state.fileMakerMode ? 'converted and saved' : 'converted and downloaded';
                                showToast(`${count} ${format}${count === 1 ? '' : 's'} ${action}`);
                            }, 200);
                        }
                    }
                };
                reader.readAsText(file);
            });
        }

        /**
         * Add an SVG item to the state
         * @param {string} filename - Name of the file
         * @param {string} svgString - Raw SVG string
         * @returns {boolean} - Whether the SVG was added successfully
         */
        function addSVGItem(filename, svgString, skipResolve) {
            try {
                // Parse the SVG
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');

                // Check for parsing errors
                const parseError = doc.querySelector('parsererror');
                if (parseError || !svg) {
                    console.error('Invalid SVG data for file:', filename);
                    return false;
                }

                // Resolve CSS <style> rules into presentation attributes
                // so editor controls (fill, stroke) work with class-styled SVGs
                // Skip for library icons  they render fine as-is, conversion on export only
                if (!skipResolve) resolveStyleRules(svg);

                // Add to svgItems array
                state.svgItems.push({
                    filename: filename,
                    originalSVG: svgString,
                    currentSVG: svg.cloneNode(true)
                });

                return true;
            } catch (e) {
                console.error('Error adding SVG item:', filename, e);
                return false;
            }
        }

        /**
         * Check if any SVGs are loaded
         * @returns {boolean}
         */
        function hasLoadedSVGs() {
            return state.svgItems.length > 0;
        }

        /**
         * Clear all loaded SVGs
         */
        function clearAllSVGs() {
            state.svgItems = [];
            state.hasStrokeSVGs = false;
            clearHistory();
            renderPreview();
            showEmptyState();
            updateSaveButton();
            updateSizeInfo();
            updateStrokeConversionUI();
        }

        /**
         * Update the save button text and enabled state based on current mode and loaded SVGs
         */
        function updateSaveButton() {
            const btn = document.getElementById('save-btn');
            const btnText = document.getElementById('save-btn-text');
            if (!btn || !btnText) return;

            const hasItems = hasLoadedSVGs();
            const count = state.svgItems.length;
            const format = state.outputFormat.toUpperCase();

            // Enable/disable based on whether SVGs are loaded
            btn.disabled = !hasItems;

            // Enable/disable code view button
            const codeViewBtn = document.getElementById('code-view-btn');
            if (codeViewBtn) {
                codeViewBtn.disabled = !hasItems;
            }

            // Show/hide editor Button Bar button (FM mode with loaded SVGs)
            const edBbBtn = document.getElementById('editor-buttonbar-btn');
            if (edBbBtn) {
                edBbBtn.style.display = (state.fileMakerMode && hasItems) ? '' : 'none';
                const edBbText = document.getElementById('editor-buttonbar-text');
                if (edBbText) edBbText.textContent = count > 1 ? `Copy as Button Bar (${count})` : 'Copy as Button Bar';
            }

            // Update text and icon based on mode, format, and count
            const saveIcon = document.getElementById('save-btn-icon');
            if (state.fileMakerMode) {
                btnText.textContent = 'Save to FileMaker';
                if (saveIcon) saveIcon.style.display = '';
            } else {
                if (saveIcon) saveIcon.style.display = 'none';
                btnText.textContent = count > 1 ? `Save ${format}s` : `Save ${format}`;
            }

            // Also update header buttons (Clear/Reset visibility)
            updateHeaderButtons();
            // Update editor badge count in mode toggle
            ibUpdateEditorBadge();
        }

        /**
         * Update visibility of Clear and Reset buttons based on loaded SVGs
         */
        function updateHeaderButtons() {
            const clearBtn = document.getElementById('clear-btn');
            const resetBtn = document.getElementById('reset-btn');
            const resetSep = document.getElementById('reset-separator');
            const hasItems = hasLoadedSVGs();

            if (clearBtn) {
                clearBtn.style.display = hasItems ? '' : 'none';
            }
            if (resetBtn) {
                resetBtn.style.display = hasItems ? '' : 'none';
            }
            if (resetSep) {
                resetSep.style.display = hasItems ? '' : 'none';
            }
        }

        // ============================================
        // Theme Toggle
        // ============================================

        function toggleTheme() {
            const newTheme = state.theme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }

        function setTheme(theme) {
            const validTheme = (theme === 'light') ? 'light' : 'dark';
            state.theme = validTheme;
            document.body.setAttribute('data-theme', validTheme);
            savePreferences();
        }

        function toggleThemeDropdown(event) {
            event.stopPropagation();
            const container = document.getElementById('theme-container');
            container.classList.toggle('open');
        }

        function setAccentColor(color) {
            const validColors = ['red', 'blue', 'green', 'purple', 'pink', 'orange'];
            if (!validColors.includes(color)) color = 'red';

            state.accentColor = color;

            // Update body attribute for CSS
            if (color === 'orange') {
                document.body.removeAttribute('data-accent');
            } else {
                document.body.setAttribute('data-accent', color);
            }

            // Update swatch active state
            document.querySelectorAll('.accent-swatch').forEach(swatch => {
                swatch.classList.toggle('active', swatch.dataset.color === color);
            });

            // Close dropdown
            document.getElementById('theme-container').classList.remove('open');
            savePreferences();
        }

        // Close theme dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const container = document.getElementById('theme-container');
            if (container && !container.contains(event.target)) {
                container.classList.remove('open');
            }
        });

        // ============================================
        // SVG Loading
        // ============================================

        /**
         * Load SVG directly from string content (used by drag/drop for single files)
         * @param {string} svgString - Raw SVG string
         * @param {string} filename - Optional filename (defaults to 'untitled.svg')
         */
        function loadSVGFromString(svgString, filename = 'untitled.svg') {
            try {
                // Clear existing SVGs
                state.svgItems = [];

                // Reset state and clear history (new SVG = fresh start)
                resetState();
                clearHistory();

                // Add the SVG item
                if (!addSVGItem(filename, svgString)) {
                    throw new Error('Invalid SVG data');
                }

                // Render preview
                renderPreview();
                updateSizeInfo();
                updateSaveButton();
                detectStrokeSVGs();

                // Auto-zoom to fit nicely in preview (after a short delay to let DOM update)
                setTimeout(autoZoom, 50);

                return true;
            } catch (e) {
                console.error('Error loading SVG:', e);
                alert('Failed to load SVG: ' + e.message);
                return false;
            }
        }

        /**
         * Load SVG(s) from base64 encoded string or JSON array
         * Call this function from FileMaker to load SVG(s)
         * @param {string} input - Base64 encoded SVG data OR JSON array string '[{filename, base64}, ...]'
         */
        function loadSVG(input) {
            try {
                // Check if input is JSON array (starts with '[' or '{')
                const trimmed = input.trim();
                if (trimmed.startsWith('[') || trimmed.startsWith('{')) {
                    return loadSVGItems(trimmed);
                }

                // Legacy single base64 string support
                const svgString = atob(input);
                return loadSVGFromString(svgString, 'untitled.svg');
            } catch (e) {
                console.error('Error loading SVG:', e);
                alert('Failed to load SVG: ' + e.message);
                return false;
            }
        }

        /**
         * Load multiple SVGs from JSON array
         * @param {string} jsonString - JSON array string '[{filename, base64}, ...]'
         */
        function loadSVGItems(jsonString, options) {
            try {
                const opts = options || {};
                let items = JSON.parse(jsonString);

                // Handle single object wrapped or not
                if (!Array.isArray(items)) {
                    items = [items];
                }

                // Clear existing SVGs
                state.svgItems = [];
                resetState();
                clearHistory();

                // Load each item
                let successCount = 0;
                items.forEach(item => {
                    try {
                        const svgString = atob(item.base64);
                        if (addSVGItem(item.filename || 'untitled.svg', svgString, opts.skipResolve)) {
                            successCount++;
                        }
                    } catch (e) {
                        console.error('Error loading SVG item:', item.filename, e);
                    }
                });

                if (successCount === 0) {
                    throw new Error('No valid SVGs found in input');
                }

                // Render preview
                renderPreview();
                updateSizeInfo();
                updateSaveButton();
                detectStrokeSVGs();
                setTimeout(autoZoom, 50);

                return true;
            } catch (e) {
                console.error('Error loading SVG items:', e);
                alert('Failed to load SVGs: ' + e.message);
                return false;
            }
        }

        /**
         * Save all SVGs - either to FileMaker or download locally based on mode
         * Returns JSON array of {filename, base64} objects
         */
        async function saveSVG() {
            if (!hasLoadedSVGs()) {
                return null;
            }

            const btn = document.getElementById('save-btn');
            const btnText = document.getElementById('save-btn-text');
            const originalText = btnText ? btnText.textContent : '';

            try {
                // Show loading state if we're converting strokes
                const willConvert = state.outputFormat === 'svg' && state.hasStrokeSVGs && state.convertStrokesToFills;
                if (willConvert && btn && btnText) {
                    btn.disabled = true;
                    btnText.textContent = 'Converting...';
                }

                if (state.outputFormat === 'png') {
                    // PNG export
                    return await savePNG();
                } else {
                    // SVG export
                    return await saveSVGFormat();
                }
            } catch (e) {
                console.error('Error saving:', e);
                alert('Failed to save: ' + e.message);
                return null;
            } finally {
                // Restore button state
                if (btn && btnText) {
                    btn.disabled = false;
                    btnText.textContent = originalText;
                }
            }
        }

        /**
         * Save as SVG format
         */
        async function saveSVGFormat() {
            const results = [];
            const conversionErrors = [];
            const processingLog = [];  // Track what happens to each SVG

            for (let itemIndex = 0; itemIndex < state.svgItems.length; itemIndex++) {
                const item = state.svgItems[itemIndex];
                const logEntry = { filename: item.filename, steps: [] };

                // Apply stroke-to-fill conversion BEFORE generating final SVG
                // This must happen first so the background rect doesn't interfere
                // with Potrace tracing (a black bg rect would dominate the trace)
                const serializer = new XMLSerializer();
                let savedCurrentSVG = null;
                if (needsStrokeConversion(item)) {
                    logEntry.steps.push('stroke conversion starting (on raw icon)');
                    const rawSvgString = serializer.serializeToString(item.currentSVG);
                    const conversionResult = await convertStrokeToFill(rawSvgString);
                    if (conversionResult.success) {
                        logEntry.steps.push('stroke conversion succeeded');
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(conversionResult.svg, 'image/svg+xml');
                        const convertedSvg = doc.querySelector('svg');
                        if (convertedSvg) {
                            // Temporarily swap in the converted SVG for generateFinalSVG
                            savedCurrentSVG = item.currentSVG;
                            item.currentSVG = convertedSvg;
                        }
                    } else {
                        conversionErrors.push({
                            filename: item.filename,
                            error: conversionResult.error
                        });
                        logEntry.steps.push('stroke conversion failed: ' + conversionResult.error);
                        console.warn('Stroke conversion failed for', item.filename, ':', conversionResult.error);
                    }
                }

                // Generate the final SVG for this item (adds background, transforms, etc.)
                let finalSVG = generateFinalSVG(item);
                logEntry.steps.push('generateFinalSVG complete');

                // Restore original currentSVG if we swapped it for conversion
                if (savedCurrentSVG) {
                    item.currentSVG = savedCurrentSVG;
                }

                let svgString = serializer.serializeToString(finalSVG);

                // Apply FileMaker compatibility processing if enabled
                // This runs in both FileMaker and browser mode when the checkbox is checked
                if (state.fmCompatible) {
                    logEntry.steps.push('processSVGForFileMaker starting');
                    finalSVG = processSVGForFileMaker(finalSVG);
                    logEntry.steps.push('processSVGForFileMaker complete');
                    // Re-serialize after FM processing
                    svgString = serializer.serializeToString(finalSVG);
                    logEntry.steps.push('re-serialized');

                    // Check if paths were normalized (should have uppercase commands)
                    const hasLowercaseCommands = /\s[a-z]\s*[\d-]/.test(svgString) || /^[a-z][\d-]/.test(svgString.match(/d="([^"]+)"/)?.[1] || '');
                    if (hasLowercaseCommands) {
                        logEntry.steps.push('WARNING: paths still have lowercase commands (not normalized)');
                        console.warn(`[${item.filename}] Path normalization may have failed - lowercase commands detected`);
                    } else {
                        logEntry.steps.push('paths normalized successfully');
                    }
                }

                // Encode to base64
                const base64 = btoa(unescape(encodeURIComponent(svgString)));

                processingLog.push(logEntry);

                results.push({
                    filename: item.filename,
                    base64: base64,
                    svgString: svgString
                });
            }

            // Log processing summary
            console.log('=== SVG Processing Summary ===');
            processingLog.forEach((entry, i) => {
                console.log(`[${i + 1}] ${entry.filename}: ${entry.steps.join(' -> ')}`);
            });

            // Show warning if any conversions failed
            if (conversionErrors.length > 0) {
                const errorMsg = conversionErrors.length === 1
                    ? `Stroke conversion failed for ${conversionErrors[0].filename}: ${conversionErrors[0].error}`
                    : `Stroke conversion failed for ${conversionErrors.length} files. The original stroked SVGs were saved instead.\n\nTip: Use the online converter at outline-stroke.vercel.app and re-import the converted SVGs.`;
                alert(errorMsg);
            }

            if (state.fileMakerMode) {
                // FileMaker mode - send to FileMaker
                const jsonOutput = JSON.stringify({
                    format: 'svg',
                    icons: results.map(r => ({
                        filename: r.filename,
                        base64: r.base64
                    }))
                });
                callFileMaker('Save Icons', jsonOutput);
                return jsonOutput;
            } else {
                // Local mode - download files
                downloadFiles(results, 'svg');
                return JSON.stringify(results.map(r => ({
                    filename: r.filename,
                    base64: r.base64
                })));
            }
        }

        /**
         * Save as PNG format
         */
        async function savePNG() {
            const size = state.outputSize;
            const results = [];

            for (const item of state.svgItems) {
                // Generate the final SVG for this item
                const finalSVG = generateFinalSVG(item);

                // Convert to PNG
                const base64 = await svgToPng(finalSVG, size);

                results.push({
                    filename: item.filename,
                    base64: base64
                });
            }

            if (state.fileMakerMode) {
                // FileMaker mode - send to FileMaker
                const jsonOutput = JSON.stringify({
                    format: 'png',
                    icons: results.map(r => ({
                        filename: r.filename.replace(/\.svg$/i, '.png'),
                        base64: r.base64
                    }))
                });
                callFileMaker('Save Icons', jsonOutput);
                return jsonOutput;
            } else {
                // Local mode - download files
                downloadFiles(results, 'png');
                return JSON.stringify(results.map(r => ({
                    filename: r.filename.replace(/\.svg$/i, '.png'),
                    base64: r.base64
                })));
            }
        }

        /**
         * Download SVG files to the user's computer
         * @param {Array} items - Array of {filename, svgString} objects
         */
        /**
         * Build a ZIP file blob from an array of {name, data} entries.
         * Uses the STORE method (no compression) for simplicity and speed.
         * @param {Array} entries - Array of {name: string, data: Uint8Array}
         * @returns {Blob} - ZIP file blob
         */
        function createZipBlob(entries) {
            // CRC-32 lookup table
            const crcTable = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                crcTable[i] = c;
            }
            function crc32(data) {
                let crc = 0xFFFFFFFF;
                for (let i = 0; i < data.length; i++) crc = crcTable[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
                return (crc ^ 0xFFFFFFFF) >>> 0;
            }

            const encoder = new TextEncoder();
            const parts = [];
            const centralDir = [];
            let offset = 0;

            for (const entry of entries) {
                const nameBytes = encoder.encode(entry.name);
                const data = entry.data;
                const crc = crc32(data);

                // Local file header (30 bytes + name)
                const local = new Uint8Array(30 + nameBytes.length);
                const lv = new DataView(local.buffer);
                lv.setUint32(0, 0x04034b50, true);   // signature
                lv.setUint16(4, 20, true);            // version needed
                lv.setUint16(6, 0, true);             // flags
                lv.setUint16(8, 0, true);             // compression: STORE
                lv.setUint16(10, 0, true);            // mod time
                lv.setUint16(12, 0, true);            // mod date
                lv.setUint32(14, crc, true);          // crc-32
                lv.setUint32(18, data.length, true);  // compressed size
                lv.setUint32(22, data.length, true);  // uncompressed size
                lv.setUint16(26, nameBytes.length, true); // name length
                lv.setUint16(28, 0, true);            // extra length
                local.set(nameBytes, 30);

                parts.push(local, data);

                // Central directory entry (46 bytes + name)
                const cd = new Uint8Array(46 + nameBytes.length);
                const cv = new DataView(cd.buffer);
                cv.setUint32(0, 0x02014b50, true);    // signature
                cv.setUint16(4, 20, true);             // version made by
                cv.setUint16(6, 20, true);             // version needed
                cv.setUint16(8, 0, true);              // flags
                cv.setUint16(10, 0, true);             // compression: STORE
                cv.setUint16(12, 0, true);             // mod time
                cv.setUint16(14, 0, true);             // mod date
                cv.setUint32(16, crc, true);           // crc-32
                cv.setUint32(20, data.length, true);   // compressed size
                cv.setUint32(24, data.length, true);   // uncompressed size
                cv.setUint16(28, nameBytes.length, true); // name length
                cv.setUint16(30, 0, true);             // extra length
                cv.setUint16(32, 0, true);             // comment length
                cv.setUint16(34, 0, true);             // disk number
                cv.setUint16(36, 0, true);             // internal attrs
                cv.setUint32(38, 0, true);             // external attrs
                cv.setUint32(42, offset, true);        // local header offset
                cd.set(nameBytes, 46);
                centralDir.push(cd);

                offset += local.length + data.length;
            }

            // Central directory
            const cdStart = offset;
            let cdSize = 0;
            for (const cd of centralDir) { parts.push(cd); cdSize += cd.length; }

            // End of central directory (22 bytes)
            const eocd = new Uint8Array(22);
            const ev = new DataView(eocd.buffer);
            ev.setUint32(0, 0x06054b50, true);            // signature
            ev.setUint16(4, 0, true);                      // disk number
            ev.setUint16(6, 0, true);                      // cd disk number
            ev.setUint16(8, entries.length, true);          // entries on disk
            ev.setUint16(10, entries.length, true);         // total entries
            ev.setUint32(12, cdSize, true);                 // cd size
            ev.setUint32(16, cdStart, true);                // cd offset
            ev.setUint16(20, 0, true);                      // comment length
            parts.push(eocd);

            return new Blob(parts, { type: 'application/zip' });
        }

        /**
         * Trigger a single file download
         */
        function triggerDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            link.addEventListener('click', e => { e.stopPropagation(); e.stopImmediatePropagation(); }, true);
            document.body.appendChild(link);
            link.dispatchEvent(new MouseEvent('click', { bubbles: false, cancelable: true, view: window }));
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        /**
         * Download files to the user's computer
         * @param {Array} items - Array of {filename, base64, svgString?} objects
         * @param {string} format - 'svg' or 'png'
         */
        function downloadFiles(items, format) {
            const encoder = new TextEncoder();

            // Build file entries
            const fileEntries = items.map(item => {
                const filename = item.filename;
                const dotIndex = filename.lastIndexOf('.');
                const baseName = dotIndex > 0 ? filename.substring(0, dotIndex) : filename;
                const newExtension = format === 'png' ? '.png' : '.svg';
                const modifiedFilename = baseName + '_modified' + newExtension;

                let data;
                if (format === 'png') {
                    const byteCharacters = atob(item.base64);
                    const byteArray = new Uint8Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) byteArray[i] = byteCharacters.charCodeAt(i);
                    data = byteArray;
                } else {
                    data = encoder.encode(item.svgString);
                }
                return { name: modifiedFilename, data };
            });

            if (fileEntries.length >= 10) {
                // 10+ files  zip
                const zipBlob = createZipBlob(fileEntries);
                triggerDownload(zipBlob, 'elemental_svg_export.zip');
            } else {
                // Under 10  individual downloads
                for (const entry of fileEntries) {
                    const mimeType = format === 'png' ? 'image/png' : 'image/svg+xml';
                    triggerDownload(new Blob([entry.data], { type: mimeType }), entry.name);
                }
            }
        }

        // Keep old function name for backwards compatibility
        function downloadSVGs(items) {
            downloadFiles(items, 'svg');
        }

        function initExternalLinkHandler() {
            // In FileMaker mode, intercept all external link clicks and pass to FileMaker
            // so it can open them in the default browser via Open URL script step.
            if (!state.fileMakerMode) return;

            document.addEventListener('click', function(evt) {
                const link = evt.target.closest('a[href]');
                if (!link) return;
                const url = link.href;
                if (!url || url === 'javascript:void(0)' || url.startsWith('#')) return;
                if (url.startsWith('http://') || url.startsWith('https://')) {
                    evt.preventDefault();
                    callFileMaker('Open URL', JSON.stringify({ url: url }));
                }
            });
        }

        /**
         * Call a FileMaker script with a parameter
         * @param {string} scriptName - Name of the FileMaker script to call
         * @param {string} parameter - Parameter to pass to the script
         */
        function callFileMaker(scriptName, parameter) {
            // FileMaker Web Viewer script call
            if (typeof FileMaker !== 'undefined' && FileMaker.PerformScript) {
                FileMaker.PerformScript(scriptName, parameter);
            } else {
                // For testing outside FileMaker - use postMessage
                console.log('FileMaker.PerformScript("' + scriptName + '", "' + parameter.substring(0, 100) + '...")');
                console.log('Full base64 output:', parameter);

                // Send to parent window via postMessage (for test page)
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'FileMakerScript',
                        scriptName: scriptName,
                        parameter: parameter
                    }, '*');
                }
            }
        }

        // ============================================
        // SVG Transformations
        // ============================================

        function flipHorizontal() {
            pushToHistory();
            state.flipH = !state.flipH;
            renderPreview();
        }

        function flipVertical() {
            pushToHistory();
            state.flipV = !state.flipV;
            renderPreview();
        }

        function rotate(direction) {
            pushToHistory();
            state.rotation = (state.rotation + direction * state.rotationIncrement + 360) % 360;
            document.getElementById('rotation-value').textContent = state.rotation + '';
            renderPreview();
        }

        function setIncrement(value) {
            state.rotationIncrement = value;
            document.querySelectorAll('.increment-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent === value + '');
            });
        }

        function updateFillColor(color, commit = false) {
            if (!isValidColor(color)) return;
            if (commit) { if (sliderStateBeforeDrag) commitSliderState(); else pushToHistory(); }
            else if (!sliderStateBeforeDrag) pushToHistory();
            state.fillColor = color;
            document.getElementById('fill-color').value = color;
            document.getElementById('fill-hex').value = color;
            document.getElementById('fill-color').parentElement.style.background = color;
            colorPickerPopup.syncFromHex(color);
            renderPreview();
        }

        function updateStrokeColor(color, commit = false) {
            if (!isValidColor(color)) return;
            if (commit) { if (sliderStateBeforeDrag) commitSliderState(); else pushToHistory(); }
            else if (!sliderStateBeforeDrag) pushToHistory();
            state.strokeColor = color;
            document.getElementById('stroke-color').value = color;
            document.getElementById('stroke-hex').value = color;
            document.getElementById('stroke-color').parentElement.style.background = color;
            colorPickerPopup.syncFromHex(color);
            renderPreview();
        }

        function updateStrokeWidth(value, commit = false) {
            if (commit) commitSliderState();
            state.strokeWidth = parseFloat(value);
            document.getElementById('stroke-value').textContent = value;
            renderPreview();
        }

        // ============================================
        // Adjustment Functions
        // ============================================

        function updateOpacity(value, commit = false) {
            if (commit) commitSliderState();
            state.opacity = parseInt(value);
            document.getElementById('opacity-value').textContent = value + '%';
            renderPreview();
        }

        function updateScale(value, commit = false) {
            if (commit) commitSliderState();
            state.scale = parseInt(value);
            document.getElementById('scale-value').textContent = value + '%';
            renderPreview();
        }

        function updateOffsetX(value, commit = false) {
            if (commit) commitSliderState();
            state.offsetX = parseInt(value);
            document.getElementById('offset-x-value').textContent = value;
            renderPreview();
        }

        function updateOffsetY(value, commit = false) {
            if (commit) commitSliderState();
            state.offsetY = parseInt(value);
            document.getElementById('offset-y-value').textContent = value;
            renderPreview();
        }

        function invertColors() {
            pushToHistory();

            // Helper to invert a color
            function invertColor(color) {
                const c = color.toLowerCase();
                if (c === '#000000' || c === '#000' || c === 'black') {
                    return '#ffffff';
                } else if (c === '#ffffff' || c === '#fff' || c === 'white') {
                    return '#000000';
                } else {
                    // For other colors, invert the RGB values
                    const hex = color.replace('#', '');
                    const r = 255 - parseInt(hex.substr(0, 2), 16);
                    const g = 255 - parseInt(hex.substr(2, 2), 16);
                    const b = 255 - parseInt(hex.substr(4, 2), 16);
                    return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
                }
            }

            // Invert both fill and stroke colors (for mixed SVGs with both fill and stroke elements)
            state.fillColor = invertColor(state.fillColor);
            state.strokeColor = invertColor(state.strokeColor);

            // Update fill UI
            document.getElementById('fill-color').value = state.fillColor;
            document.getElementById('fill-hex').value = state.fillColor;
            document.getElementById('fill-color').parentElement.style.background = state.fillColor;

            // Update stroke UI
            document.getElementById('stroke-color').value = state.strokeColor;
            document.getElementById('stroke-hex').value = state.strokeColor;
            document.getElementById('stroke-color').parentElement.style.background = state.strokeColor;

            renderPreview();
        }

        function resetAdjustments() {
            pushToHistory();
            state.opacity = 100;
            state.scale = 100;
            state.offsetX = 0;
            state.offsetY = 0;
            // Update UI
            document.getElementById('opacity-slider').value = 100;
            document.getElementById('opacity-value').textContent = '100%';
            document.getElementById('scale-slider').value = 100;
            document.getElementById('scale-value').textContent = '100%';
            document.getElementById('offset-x-slider').value = 0;
            document.getElementById('offset-x-value').textContent = '0';
            document.getElementById('offset-y-slider').value = 0;
            document.getElementById('offset-y-value').textContent = '0';
            renderPreview();
        }

        function toggleBackground(enabled) {
            pushToHistory();
            state.bgEnabled = enabled;
            document.getElementById('bg-options').classList.toggle('visible', enabled);
            updateFMTargetVisibility();
            renderPreview();
        }

        function updateBgColor(color, commit = false) {
            if (!isValidColor(color)) return;
            if (commit) { if (sliderStateBeforeDrag) commitSliderState(); else pushToHistory(); }
            else if (!sliderStateBeforeDrag) pushToHistory();
            state.bgColor = color;
            document.getElementById('bg-color').value = color;
            document.getElementById('bg-hex').value = color;
            document.getElementById('bg-color-preview').style.background = color;
            colorPickerPopup.syncFromHex(color);
            renderPreview();
        }

        function getEdgesLabel(n) {
            const names = { 0: 'Circle', 3: 'Triangle', 4: 'Square', 5: 'Pentagon', 6: 'Hexagon', 7: 'Heptagon', 8: 'Octagon', 9: 'Nonagon', 10: 'Decagon' };
            return names[n] || (n + '-gon');
        }

        function setBgEdges(n) {
            n = parseInt(n);
            if (isNaN(n) || n < 0) n = 0;
            if (n === 1 || n === 2) n = 3;
            pushToHistory();
            state.bgEdges = n;
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === 'shape-edges-' + n);
            });
            document.getElementById('edges-value').textContent = n;
            document.getElementById('edges-label').textContent = getEdgesLabel(n);
            document.getElementById('corner-radius-control').style.display = (n === 0) ? 'none' : 'block';
            renderPreview();
        }

        function adjustBgEdges(delta) {
            let n = state.bgEdges + delta;
            // Smart skip: 0 (circle) <-> 3 (triangle), skip 1 and 2
            if (delta > 0 && state.bgEdges === 0) n = 3;
            if (delta < 0 && state.bgEdges === 3) n = 0;
            if (n < 0) n = 0;
            setBgEdges(n);
        }

        function generatePolygonPath(cx, cy, radius, edges, cornerRadius) {
            // Calculate vertices evenly spaced, starting at top (-PI/2)
            const vertices = [];
            for (let i = 0; i < edges; i++) {
                const angle = (2 * Math.PI * i / edges) - Math.PI / 2;
                vertices.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }

            if (cornerRadius <= 0) {
                // Straight polygon
                let d = `M ${vertices[0].x.toFixed(2)} ${vertices[0].y.toFixed(2)}`;
                for (let i = 1; i < edges; i++) {
                    d += ` L ${vertices[i].x.toFixed(2)} ${vertices[i].y.toFixed(2)}`;
                }
                d += ' Z';
                return d;
            }

            // Rounded polygon: offset inward along edges and connect with quadratic bezier
            const maxOffset = 0.5; // max fraction of edge length for rounding
            let d = '';
            for (let i = 0; i < edges; i++) {
                const prev = vertices[(i - 1 + edges) % edges];
                const curr = vertices[i];
                const next = vertices[(i + 1) % edges];

                // Edge vectors from current vertex
                const toPrev = { x: prev.x - curr.x, y: prev.y - curr.y };
                const toNext = { x: next.x - curr.x, y: next.y - curr.y };

                // Edge lengths
                const lenPrev = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);
                const lenNext = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);

                // Offset distance (fraction of shorter adjacent edge)
                const offset = Math.min(lenPrev, lenNext) * maxOffset * cornerRadius;

                // Points offset from vertex along each edge
                const p1 = {
                    x: curr.x + (toPrev.x / lenPrev) * offset,
                    y: curr.y + (toPrev.y / lenPrev) * offset
                };
                const p2 = {
                    x: curr.x + (toNext.x / lenNext) * offset,
                    y: curr.y + (toNext.y / lenNext) * offset
                };

                if (i === 0) {
                    d = `M ${p1.x.toFixed(2)} ${p1.y.toFixed(2)}`;
                } else {
                    d += ` L ${p1.x.toFixed(2)} ${p1.y.toFixed(2)}`;
                }
                d += ` Q ${curr.x.toFixed(2)} ${curr.y.toFixed(2)} ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
            }
            // Close: line back to first offset point
            const first = vertices[0];
            const last = vertices[edges - 1];
            const secondV = vertices[1];
            const toLastFromFirst = { x: last.x - first.x, y: last.y - first.y };
            const toSecondFromFirst = { x: secondV.x - first.x, y: secondV.y - first.y };
            const lenLast = Math.sqrt(toLastFromFirst.x * toLastFromFirst.x + toLastFromFirst.y * toLastFromFirst.y);
            const lenSecond = Math.sqrt(toSecondFromFirst.x * toSecondFromFirst.x + toSecondFromFirst.y * toSecondFromFirst.y);
            const offsetFirst = Math.min(lenLast, lenSecond) * maxOffset * cornerRadius;
            const closePoint = {
                x: first.x + (toLastFromFirst.x / lenLast) * offsetFirst,
                y: first.y + (toLastFromFirst.y / lenLast) * offsetFirst
            };
            d += ` L ${closePoint.x.toFixed(2)} ${closePoint.y.toFixed(2)} Z`;
            return d;
        }

        function updatePadding(value, commit = false) {
            if (commit) commitSliderState();
            state.iconPadding = parseInt(value);
            document.getElementById('padding-value').textContent = value + '%';
            renderPreview();
        }

        function updateCornerRadius(value, commit = false) {
            if (commit) commitSliderState();
            state.cornerRadius = parseInt(value);
            document.getElementById('radius-value').textContent = value + '%';
            renderPreview();
        }

        function toggleFMCompat(enabled) {
            state.fmCompatible = enabled;
            updateFMTargetVisibility();
            savePreferences();
        }

        function toggleFMDynamic(enabled) {
            state.fmDynamicFill = enabled;
            updateFMTargetVisibility();
            savePreferences();
        }

        function setFMTarget(target) {
            state.fmDynamicTarget = target;
            document.getElementById('target-icon').classList.toggle('active', target === 'icon');
            document.getElementById('target-background').classList.toggle('active', target === 'background');

            const hint = document.getElementById('fm-target-hint');
            if (target === 'icon') {
                hint.textContent = 'FileMaker will dynamically change the icon color. Background keeps its set color.';
            } else {
                hint.textContent = 'FileMaker will dynamically change the background color. Icon keeps its set color.';
            }
        }

        function updateFMTargetVisibility() {
            const section = document.getElementById('fm-target-section');
            // Show target selector only when: FM compatible ON, dynamic fill ON, and background enabled
            const shouldShow = state.fmCompatible && state.fmDynamicFill && state.bgEnabled;
            section.style.display = shouldShow ? 'block' : 'none';

            // Ensure the current target is visually highlighted when section becomes visible
            if (shouldShow) {
                document.getElementById('target-icon').classList.toggle('active', state.fmDynamicTarget === 'icon');
                document.getElementById('target-background').classList.toggle('active', state.fmDynamicTarget === 'background');
            }
        }

        // ============================================
        // Stroke to Fill Conversion
        // ============================================

        /**
         * Detect if any loaded SVGs are stroke-based (have strokes with no fill)
         * Updates state.hasStrokeSVGs and shows/hides the conversion option
         */
        function detectStrokeSVGs() {
            state.hasStrokeSVGs = false;

            for (const item of state.svgItems) {
                if (isStrokeBasedSVG(item.currentSVG)) {
                    state.hasStrokeSVGs = true;
                    break;
                }
            }

            updateStrokeConversionUI();
        }

        /**
         * Check if an SVG element is stroke-based (has strokes with fill="none")
         * @param {SVGElement} svg - The SVG element to check
         * @returns {boolean} - True if the SVG is stroke-based
         */
        function isStrokeBasedSVG(svg) {
            // Check root SVG for inherited stroke/fill (common in Heroicons, Tabler, Lucide)
            const rootStroke = svg.getAttribute('stroke') || getStyleProperty(svg, 'stroke');
            const rootFill = svg.getAttribute('fill') || getStyleProperty(svg, 'fill');
            const rootStrokeWidth = svg.getAttribute('stroke-width') || getStyleProperty(svg, 'stroke-width');

            // If root has stroke + fill="none", all children are stroke-based by inheritance
            if (rootStroke && rootStroke !== 'none' && rootFill === 'none') {
                return true;
            }

            // Check all shape elements
            const shapeElements = svg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');

            for (const el of shapeElements) {
                const stroke = el.getAttribute('stroke') || getStyleProperty(el, 'stroke') || rootStroke;
                const fill = el.getAttribute('fill') || getStyleProperty(el, 'fill') || rootFill;
                const strokeWidth = el.getAttribute('stroke-width') || getStyleProperty(el, 'stroke-width') || rootStrokeWidth;

                // Element has a stroke and either no fill or fill="none"
                if (stroke && stroke !== 'none') {
                    if (!fill || fill === 'none') {
                        return true;
                    }
                }

                // Also check for stroke-width without explicit stroke color (inherits currentColor)
                if (strokeWidth && parseFloat(strokeWidth) > 0) {
                    if (!fill || fill === 'none') {
                        return true;
                    }
                }
            }

            return false;
        }

        /**
         * Get a CSS property value from an element's style attribute
         * @param {Element} el - The element
         * @param {string} property - The CSS property name
         * @returns {string|null} - The property value or null
         */
        function getStyleProperty(el, property) {
            const style = el.getAttribute('style');
            if (!style) return null;

            const regex = new RegExp(property + '\\s*:\\s*([^;]+)', 'i');
            const match = style.match(regex);
            return match ? match[1].trim() : null;
        }

        /**
         * Toggle stroke to fill conversion
         * @param {boolean} enabled - Whether conversion is enabled
         */
        function toggleStrokeConversion(enabled) {
            state.convertStrokesToFills = enabled;
        }

        /**
         * Update the stroke conversion UI visibility
         */
        function updateStrokeConversionUI() {
            const section = document.getElementById('stroke-convert-section');
            if (section) {
                // Show only when: SVG format selected AND stroke SVGs detected
                const shouldShow = state.outputFormat === 'svg' && state.hasStrokeSVGs;
                section.style.display = shouldShow ? 'block' : 'none';

                // Update checkbox state
                const checkbox = document.getElementById('convert-strokes');
                if (checkbox) {
                    checkbox.checked = state.convertStrokesToFills;
                }
            }
        }

        /**
         * Convert a stroke-based SVG to filled paths using Potrace (bitmap tracing)
         * This approach renders the SVG to a high-res bitmap, then traces the outline
         * to create filled vector paths. Similar to outline-stroke.vercel.app
         * @param {string} svgString - The SVG string to convert
         * @returns {Promise<{svg: string, success: boolean, error: string|null}>} - The conversion result
         */
        async function convertStrokeToFill(svgString) {
            try {
                // Check if Potrace is available
                if (typeof Potrace === 'undefined') {
                    return { svg: svgString, success: false, error: 'Potrace not loaded' };
                }

                // Parse the SVG to get dimensions
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');

                if (!svg) {
                    return { svg: svgString, success: false, error: 'Invalid SVG' };
                }

                // Get dimensions from viewBox or width/height
                let width = 512, height = 512;
                let viewBoxMinX = 0, viewBoxMinY = 0;
                const viewBox = svg.getAttribute('viewBox');
                if (viewBox) {
                    const parts = viewBox.split(/[\s,]+/);
                    if (parts.length >= 4) {
                        viewBoxMinX = parseFloat(parts[0]) || 0;
                        viewBoxMinY = parseFloat(parts[1]) || 0;
                        width = parseFloat(parts[2]) || 512;
                        height = parseFloat(parts[3]) || 512;
                    }
                }

                // Use high resolution for better tracing quality
                // Potrace works better with larger images
                const scale = Math.max(2, 1024 / Math.max(width, height));
                const canvasWidth = Math.round(width * scale);
                const canvasHeight = Math.round(height * scale);

                // Render SVG to canvas
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');

                // Fill with white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Create image from SVG
                const img = new Image();

                const svgLoaded = new Promise((resolve, reject) => {
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Failed to load SVG as image'));

                    // Process SVG: replace ALL colors with black for maximum contrast during tracing
                    // This ensures Potrace can detect the icon regardless of what fill color the user selected
                    let processedSvg = svgString
                        .replace(/currentColor/gi, '#000000')
                        .replace(/fill\s*=\s*"(?!none)[^"]*"/gi, 'fill="#000000"')
                        .replace(/stroke\s*=\s*"(?!none)[^"]*"/gi, 'stroke="#000000"')
                        .replace(/fill\s*:\s*(?!none)[^;}"']+/gi, 'fill:#000000')
                        .replace(/stroke\s*:\s*(?!none)[^;}"']+/gi, 'stroke:#000000');

                    // Ensure SVG has proper dimensions
                    const tempDoc = parser.parseFromString(processedSvg, 'image/svg+xml');
                    const tempSvg = tempDoc.querySelector('svg');
                    if (tempSvg) {
                        tempSvg.setAttribute('width', canvasWidth);
                        tempSvg.setAttribute('height', canvasHeight);
                        processedSvg = new XMLSerializer().serializeToString(tempSvg);
                    }

                    const svgBlob = new Blob([processedSvg], { type: 'image/svg+xml;charset=utf-8' });
                    img.src = URL.createObjectURL(svgBlob);
                });

                await svgLoaded;

                // Draw SVG to canvas
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                URL.revokeObjectURL(img.src);

                // Use Potrace to trace the bitmap
                const tracedSvg = await new Promise((resolve, reject) => {
                    // Load the canvas data into Potrace
                    // Potrace works with a loaded image, so we convert canvas to data URL
                    const dataUrl = canvas.toDataURL('image/png');

                    Potrace.loadImageFromUrl(dataUrl);

                    // Set Potrace parameters for clean icon tracing
                    Potrace.setParameter({
                        turdsize: 2,        // Suppress small speckles
                        optcurve: true,     // Optimize curves
                        alphamax: 1,        // Corner threshold
                        opttolerance: 0.2   // Curve optimization tolerance
                    });

                    // Process the image
                    Potrace.process(function () {
                        try {
                            // Get SVG output at scale 1 (we'll adjust viewBox)
                            const result = Potrace.getSVG(1);
                            resolve(result);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });

                // Parse the traced SVG to extract paths
                const tracedDoc = parser.parseFromString(tracedSvg, 'image/svg+xml');
                const tracedSvgEl = tracedDoc.querySelector('svg');

                if (!tracedSvgEl) {
                    return { svg: svgString, success: false, error: 'Potrace produced invalid output' };
                }

                // Extract paths from traced SVG
                const paths = tracedSvgEl.querySelectorAll('path');
                if (paths.length === 0) {
                    return { svg: svgString, success: false, error: 'No paths traced' };
                }

                // Build output SVG with original dimensions
                // Scale the path coordinates back to original size
                let outputSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="${viewBoxMinX} ${viewBoxMinY} ${width} ${height}" version="1.1">\n`;

                for (const path of paths) {
                    let d = path.getAttribute('d');
                    if (d) {
                        // Scale path coordinates back to original dimensions
                        d = scalePathData(d, 1 / scale);
                        outputSvg += `    <path d="${d}" fill="inherit" stroke="none"/>\n`;
                    }
                }

                outputSvg += `</svg>`;

                return {
                    svg: outputSvg,
                    success: true,
                    error: null
                };
            } catch (error) {
                console.error('Stroke to fill conversion failed:', error);
                return {
                    svg: svgString,
                    success: false,
                    error: error.message
                };
            }
        }

        /**
         * Scale SVG path data by a factor
         * @param {string} pathData - The path d attribute
         * @param {number} scale - Scale factor
         * @returns {string} - Scaled path data
         */
        function scalePathData(pathData, scale) {
            // Match numbers (including decimals and negatives) in path data
            return pathData.replace(/-?\d+\.?\d*/g, (match) => {
                const num = parseFloat(match);
                return (num * scale).toFixed(2);
            });
        }

        /**
         * Check if a specific SVG item needs stroke conversion
         * @param {Object} item - The SVG item {filename, originalSVG, currentSVG}
         * @returns {boolean} - True if the item needs conversion
         */
        function needsStrokeConversion(item) {
            return state.convertStrokesToFills && isStrokeBasedSVG(item.currentSVG);
        }

        // ============================================
        // Export Format Functions
        // ============================================

        /**
         * Set the output format (SVG or PNG)
         */
        function setOutputFormat(format) {
            state.outputFormat = format;
            updateFormatUI();
            updateSaveButton();
        }

        /**
         * Set the output size for PNG export
         */
        function setOutputSize(size) {
            state.outputSize = size;
            updateFormatUI();
        }

        /**
         * Update the format UI to reflect current state
         */
        function updateFormatUI() {
            // Update format buttons
            document.getElementById('format-svg').classList.toggle('active', state.outputFormat === 'svg');
            document.getElementById('format-png').classList.toggle('active', state.outputFormat === 'png');

            // Show/hide PNG size options
            document.getElementById('png-size-section').style.display = state.outputFormat === 'png' ? 'block' : 'none';

            // Show/hide SVG-specific options
            document.getElementById('svg-options-section').style.display = state.outputFormat === 'svg' ? 'block' : 'none';

            // Update size buttons
            const sizes = [32, 64, 128, 256, 512, 1024];
            sizes.forEach(size => {
                const btn = document.getElementById('size-' + size);
                if (btn) {
                    btn.classList.toggle('active', state.outputSize === size);
                }
            });

            // Update stroke conversion UI visibility (depends on format)
            updateStrokeConversionUI();
        }

        /**
         * Convert an SVG element to a PNG data URL
         * @param {SVGElement} svgElement - The SVG to convert
         * @param {number} size - Output size (width and height)
         * @returns {Promise<string>} - Promise resolving to base64 PNG data
         */
        function svgToPng(svgElement, size) {
            return new Promise((resolve, reject) => {
                // Clone and prepare the SVG
                const svg = svgElement.cloneNode(true);
                svg.setAttribute('width', size);
                svg.setAttribute('height', size);

                // Serialize SVG to string
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svg);

                // Create a blob URL for the SVG
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                // Create an image and load the SVG
                const img = new Image();
                img.onload = function () {
                    // Create canvas and draw the image
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Draw with white background for transparency handling (optional)
                    // ctx.fillStyle = '#ffffff';
                    // ctx.fillRect(0, 0, size, size);

                    ctx.drawImage(img, 0, 0, size, size);

                    // Clean up the blob URL
                    URL.revokeObjectURL(url);

                    // Get PNG data URL and extract base64
                    const dataUrl = canvas.toDataURL('image/png');
                    const base64 = dataUrl.replace(/^data:image\/png;base64,/, '');
                    resolve(base64);
                };

                img.onerror = function () {
                    URL.revokeObjectURL(url);
                    reject(new Error('Failed to load SVG for PNG conversion'));
                };

                img.src = url;
            });
        }

        // ============================================
        // FileMaker Compatibility Processing
        // ============================================

        /**
         * Normalize SVG path commands to absolute coordinates
         * This ensures compatibility with FileMaker's SVG renderer
         */
        function normalizePath(pathData) {
            if (!pathData) return pathData;

            // Pre-process arc commands to fix flag notation
            // Arc flags (large-arc and sweep) are 0 or 1 and can be written without separators
            // e.g., "a15.92 15.92 0 01-11.31-4.69" should parse flags as 0 and 1
            function preprocessArcs(d) {
                // Match arc commands and their arguments
                return d.replace(/([Aa])\s*((?:[^MmLlHhVvCcSsQqTtAaZz])+)/g, (match, cmd, args) => {
                    // Process each set of 7 arc arguments
                    // We need to fix cases where flags run together: "01" -> "0 1", "00" -> "0 0", etc.
                    // Also cases like "01-5" -> "0 1 -5" or "10.5" after flags
                    let result = cmd;
                    let remaining = args.trim();

                    // Parse arc arguments - we expect sets of 7: rx ry rotation large-arc sweep x y
                    const numRe = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
                    let nums = [];
                    let m;

                    // First, extract all number-like tokens
                    while ((m = numRe.exec(remaining)) !== null) {
                        nums.push(m[0]);
                    }

                    // Now process in groups, fixing flag notation
                    let processed = [];
                    let i = 0;
                    while (i < nums.length) {
                        // rx
                        if (i < nums.length) processed.push(nums[i++]);
                        // ry
                        if (i < nums.length) processed.push(nums[i++]);
                        // rotation
                        if (i < nums.length) processed.push(nums[i++]);

                        // large-arc-flag and sweep-flag - these must be 0 or 1
                        // They might be combined like "01" or "10" or followed directly by coordinates
                        if (i < nums.length) {
                            let flagStr = nums[i++];
                            // Check if this contains both flags
                            if (flagStr.length >= 2 && /^[01][01]/.test(flagStr)) {
                                // Two flags combined, possibly with more digits
                                processed.push(flagStr[0]); // large-arc
                                // Rest is sweep flag possibly combined with x coordinate
                                let rest = flagStr.substring(1);
                                if (rest.length === 1) {
                                    processed.push(rest); // just sweep flag
                                } else if (/^[01]/.test(rest)) {
                                    processed.push(rest[0]); // sweep flag
                                    if (rest.length > 1) {
                                        // Remaining is start of x coordinate
                                        processed.push(rest.substring(1));
                                        // Skip x, get y
                                        if (i < nums.length) processed.push(nums[i++]);
                                        continue;
                                    }
                                } else {
                                    processed.push(rest);
                                }
                            } else {
                                processed.push(flagStr); // large-arc flag
                                // sweep-flag
                                if (i < nums.length) {
                                    let sweepStr = nums[i++];
                                    if (sweepStr.length > 1 && /^[01]/.test(sweepStr)) {
                                        processed.push(sweepStr[0]);
                                        processed.push(sweepStr.substring(1)); // x coordinate
                                        if (i < nums.length) processed.push(nums[i++]); // y
                                        continue;
                                    }
                                    processed.push(sweepStr);
                                }
                            }
                        }

                        // x
                        if (i < nums.length) processed.push(nums[i++]);
                        // y
                        if (i < nums.length) processed.push(nums[i++]);
                    }

                    return cmd + ' ' + processed.join(' ');
                });
            }

            // Tokenize path data properly - handles cases like "0-562.5" where minus starts new number
            function tokenize(d) {
                const tokens = [];
                const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
                let m;
                while ((m = re.exec(d)) !== null) {
                    tokens.push(m[0]);
                }
                return tokens;
            }

            // Pre-process arcs before tokenizing
            pathData = preprocessArcs(pathData);

            const tokens = tokenize(pathData);
            const commands = [];
            let i = 0;

            while (i < tokens.length) {
                const token = tokens[i];
                if (/[MmLlHhVvCcSsQqTtAaZz]/.test(token)) {
                    const cmd = token;
                    const args = [];
                    i++;
                    while (i < tokens.length && !/[MmLlHhVvCcSsQqTtAaZz]/.test(tokens[i])) {
                        args.push(parseFloat(tokens[i]));
                        i++;
                    }
                    commands.push({ cmd, args });
                } else {
                    i++;
                }
            }

            let x = 0, y = 0;      // Current position
            let startX = 0, startY = 0;  // Start of current subpath
            let lastCx = 0, lastCy = 0;  // Last control point (for S/T)
            let lastCmd = '';

            const result = [];

            for (const { cmd, args } of commands) {
                const isRelative = cmd === cmd.toLowerCase();
                const absCmd = cmd.toUpperCase();

                switch (absCmd) {
                    case 'M': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 2) {
                            const px = isRelative ? x + args[i] : args[i];
                            const py = isRelative ? y + args[i + 1] : args[i + 1];
                            if (i === 0) {
                                pts.push(`M${px} ${py}`);
                                startX = px;
                                startY = py;
                            } else {
                                pts.push(`L${px} ${py}`);
                            }
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'L': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 2) {
                            const px = isRelative ? x + args[i] : args[i];
                            const py = isRelative ? y + args[i + 1] : args[i + 1];
                            pts.push(`L${px} ${py}`);
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'H': {
                        const pts = [];
                        for (const arg of args) {
                            const px = isRelative ? x + arg : arg;
                            pts.push(`L${px} ${y}`);
                            x = px;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'V': {
                        const pts = [];
                        for (const arg of args) {
                            const py = isRelative ? y + arg : arg;
                            pts.push(`L${x} ${py}`);
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'C': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 6) {
                            const x1 = isRelative ? x + args[i] : args[i];
                            const y1 = isRelative ? y + args[i + 1] : args[i + 1];
                            const x2 = isRelative ? x + args[i + 2] : args[i + 2];
                            const y2 = isRelative ? y + args[i + 3] : args[i + 3];
                            const px = isRelative ? x + args[i + 4] : args[i + 4];
                            const py = isRelative ? y + args[i + 5] : args[i + 5];
                            pts.push(`C${x1} ${y1} ${x2} ${y2} ${px} ${py}`);
                            lastCx = x2;
                            lastCy = y2;
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'S': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 4) {
                            // Reflect last control point
                            let x1, y1;
                            if (lastCmd === 'C' || lastCmd === 'S') {
                                x1 = 2 * x - lastCx;
                                y1 = 2 * y - lastCy;
                            } else {
                                x1 = x;
                                y1 = y;
                            }
                            const x2 = isRelative ? x + args[i] : args[i];
                            const y2 = isRelative ? y + args[i + 1] : args[i + 1];
                            const px = isRelative ? x + args[i + 2] : args[i + 2];
                            const py = isRelative ? y + args[i + 3] : args[i + 3];
                            pts.push(`C${x1} ${y1} ${x2} ${y2} ${px} ${py}`);
                            lastCx = x2;
                            lastCy = y2;
                            x = px;
                            y = py;
                            lastCmd = 'S';
                        }
                        result.push(pts.join(' '));
                        continue;
                    }
                    case 'Q': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 4) {
                            const cx = isRelative ? x + args[i] : args[i];
                            const cy = isRelative ? y + args[i + 1] : args[i + 1];
                            const px = isRelative ? x + args[i + 2] : args[i + 2];
                            const py = isRelative ? y + args[i + 3] : args[i + 3];
                            pts.push(`Q${cx} ${cy} ${px} ${py}`);
                            lastCx = cx;
                            lastCy = cy;
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'T': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 2) {
                            let cx, cy;
                            if (lastCmd === 'Q' || lastCmd === 'T') {
                                cx = 2 * x - lastCx;
                                cy = 2 * y - lastCy;
                            } else {
                                cx = x;
                                cy = y;
                            }
                            const px = isRelative ? x + args[i] : args[i];
                            const py = isRelative ? y + args[i + 1] : args[i + 1];
                            pts.push(`Q${cx} ${cy} ${px} ${py}`);
                            lastCx = cx;
                            lastCy = cy;
                            x = px;
                            y = py;
                            lastCmd = 'T';
                        }
                        result.push(pts.join(' '));
                        continue;
                    }
                    case 'A': {
                        const pts = [];
                        for (let i = 0; i < args.length; i += 7) {
                            const rx = args[i];
                            const ry = args[i + 1];
                            const angle = args[i + 2];
                            const largeArc = args[i + 3];
                            const sweep = args[i + 4];
                            const px = isRelative ? x + args[i + 5] : args[i + 5];
                            const py = isRelative ? y + args[i + 6] : args[i + 6];
                            pts.push(`A${rx} ${ry} ${angle} ${largeArc} ${sweep} ${px} ${py}`);
                            x = px;
                            y = py;
                        }
                        result.push(pts.join(' '));
                        break;
                    }
                    case 'Z': {
                        result.push('Z');
                        x = startX;
                        y = startY;
                        break;
                    }
                }
                lastCmd = absCmd;
            }

            return result.join(' ');
        }

        /**
         * Resolve CSS <style> rules into presentation attributes on matching elements.
         * Many SVGs (especially from icon libraries) use <style> blocks with class selectors
         * instead of inline attributes. FileMaker and the editor's fill/stroke controls
         * only work with XML presentation attributes, so we need to inline these.
         */
        function resolveStyleRules(svg) {
            const styleElements = svg.querySelectorAll('style');
            if (styleElements.length === 0) return;

            styleElements.forEach(styleEl => {
                const cssText = styleEl.textContent;
                const ruleRegex = /([^{]+)\{([^}]+)\}/g;
                let match;
                while ((match = ruleRegex.exec(cssText)) !== null) {
                    const selector = match[1].trim();
                    const declarations = match[2].trim();
                    try {
                        const targets = svg.querySelectorAll(selector);
                        targets.forEach(el => {
                            declarations.split(';').forEach(decl => {
                                const colonIdx = decl.indexOf(':');
                                if (colonIdx === -1) return;
                                const prop = decl.substring(0, colonIdx).trim();
                                let value = decl.substring(colonIdx + 1).trim();
                                if (!prop || !value) return;
                                // CSS class rules override presentation attributes (higher specificity)
                                el.setAttribute(prop, value);
                            });
                        });
                    } catch (e) {
                        console.warn('Could not apply CSS rule:', selector, e);
                    }
                }
                // Remove the <style> element (and parent <defs> if now empty)
                const parent = styleEl.parentElement;
                styleEl.remove();
                if (parent && parent.tagName.toLowerCase() === 'defs' && parent.children.length === 0) {
                    parent.remove();
                }
            });
        }

        /**
         * Convert compound paths with fill-rule="evenodd" to use nonzero fill-rule
         * by correcting the winding direction of sub-paths.
         *
         * FileMaker's button bar SVG renderer doesn't properly support evenodd fill-rule,
         * causing letter cutouts in compound paths (like Adobe product icons) to disappear.
         *
         * With nonzero fill-rule, sub-paths winding in opposite directions create holes.
         * This function ensures:
         *   - Even nesting levels (outer shapes): wind in one direction (filled)
         *   - Odd nesting levels (cutout holes): wind in the opposite direction (not filled)
         *
         * Must be called AFTER normalizePath() since it expects absolute commands only.
         */
        function convertEvenOddToNonZero(svg) {
            const evenOddPaths = svg.querySelectorAll('path[fill-rule="evenodd"]');
            if (evenOddPaths.length === 0) return;

            // Tokenizer for normalized paths (absolute commands only)
            function tokenize(str) {
                const tokens = [];
                const re = /([MLCQAZ])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
                let m;
                while ((m = re.exec(str)) !== null) tokens.push(m[0]);
                return tokens;
            }

            // Compute the midpoint of an SVG arc using center parameterization.
            // Needed for polygon approximation  arcs with only 2 endpoints can be
            // collinear (e.g., circles drawn with 2 semicircular arcs), giving zero
            // area in the shoelace formula and breaking winding direction detection.
            function arcMidpoint(x1, y1, rx, ry, angle, largeArc, sweep, x2, y2) {
                if (rx === 0 || ry === 0) return null;
                const phi = angle * Math.PI / 180;
                const cosPhi = Math.cos(phi), sinPhi = Math.sin(phi);
                const dx2 = (x1 - x2) / 2, dy2 = (y1 - y2) / 2;
                const x1p = cosPhi * dx2 + sinPhi * dy2;
                const y1p = -sinPhi * dx2 + cosPhi * dy2;
                let rxSq = rx * rx, rySq = ry * ry;
                const x1pSq = x1p * x1p, y1pSq = y1p * y1p;
                const lambda = x1pSq / rxSq + y1pSq / rySq;
                if (lambda > 1) {
                    const s = Math.sqrt(lambda);
                    rx *= s; ry *= s; rxSq = rx * rx; rySq = ry * ry;
                }
                let sq = (rxSq * rySq - rxSq * y1pSq - rySq * x1pSq) / (rxSq * y1pSq + rySq * x1pSq);
                sq = Math.sqrt(Math.max(0, sq));
                if (largeArc === sweep) sq = -sq;
                const cxp = sq * rx * y1p / ry;
                const cyp = -sq * ry * x1p / rx;
                const cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;
                const cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;
                function vecAngle(ux, uy, vx, vy) {
                    const dot = ux * vx + uy * vy;
                    const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
                    let a = Math.acos(Math.max(-1, Math.min(1, dot / (len || 1))));
                    if (ux * vy - uy * vx < 0) a = -a;
                    return a;
                }
                const theta1 = vecAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
                let dtheta = vecAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry);
                if (!sweep && dtheta > 0) dtheta -= 2 * Math.PI;
                if (sweep && dtheta < 0) dtheta += 2 * Math.PI;
                const thetaMid = theta1 + dtheta / 2;
                const mx = cosPhi * rx * Math.cos(thetaMid) - sinPhi * ry * Math.sin(thetaMid) + cx;
                const my = sinPhi * rx * Math.cos(thetaMid) + cosPhi * ry * Math.sin(thetaMid) + cy;
                return [mx, my];
            }

            // Extract on-curve sample points from a sub-path for polygon approximation.
            // For straight segments (M, L): adds the endpoint.
            // For cubic curves (C): adds the on-curve midpoint at t=0.5 (de Casteljau) AND
            //   the endpoint. NOT control points  those create oversized polygons that break
            //   containment tests (Bug #1). Midpoints turn a 4-cubic circle from a diamond
            //   (4 points) into an octagon (8 points), critical for containment accuracy.
            // For arcs (A): adds the arc midpoint (center parameterization) AND the endpoint.
            //   Without midpoints, circles drawn with 2 arcs produce collinear endpoints with
            //   zero shoelace area (Bug #3).
            function extractEndpoints(subPath) {
                const points = [];
                const tokens = tokenize(subPath);
                let i = 0;
                let cx = 0, cy = 0; // track current point
                while (i < tokens.length) {
                    const cmd = tokens[i++];
                    switch (cmd) {
                        case 'M': case 'L':
                            cx = parseFloat(tokens[i]);
                            cy = parseFloat(tokens[i + 1]);
                            points.push([cx, cy]);
                            i += 2; break;
                        case 'C': {
                            // Sample on-curve midpoint at t=0.5 (de Casteljau), then endpoint
                            const cp1x = parseFloat(tokens[i]), cp1y = parseFloat(tokens[i + 1]);
                            const cp2x = parseFloat(tokens[i + 2]), cp2y = parseFloat(tokens[i + 3]);
                            const ex = parseFloat(tokens[i + 4]), ey = parseFloat(tokens[i + 5]);
                            points.push([
                                0.125 * cx + 0.375 * cp1x + 0.375 * cp2x + 0.125 * ex,
                                0.125 * cy + 0.375 * cp1y + 0.375 * cp2y + 0.125 * ey
                            ]);
                            cx = ex; cy = ey;
                            points.push([cx, cy]);
                            i += 6; break;
                        }
                        case 'Q': {
                            // Sample on-curve midpoint at t=0.5, then endpoint
                            const qcx = parseFloat(tokens[i]), qcy = parseFloat(tokens[i + 1]);
                            const qex = parseFloat(tokens[i + 2]), qey = parseFloat(tokens[i + 3]);
                            points.push([
                                0.25 * cx + 0.5 * qcx + 0.25 * qex,
                                0.25 * cy + 0.5 * qcy + 0.25 * qey
                            ]);
                            cx = qex; cy = qey;
                            points.push([cx, cy]);
                            i += 4; break;
                        }
                        case 'A': {
                            const arx = parseFloat(tokens[i]), ary = parseFloat(tokens[i + 1]);
                            const aAngle = parseFloat(tokens[i + 2]);
                            const aLarge = parseFloat(tokens[i + 3]);
                            const aSweep = parseFloat(tokens[i + 4]);
                            const ax = parseFloat(tokens[i + 5]), ay = parseFloat(tokens[i + 6]);
                            // Sample arc midpoint for proper polygon area
                            const mid = arcMidpoint(cx, cy, arx, ary, aAngle, aLarge, aSweep, ax, ay);
                            if (mid) points.push(mid);
                            cx = ax; cy = ay;
                            points.push([cx, cy]);
                            i += 7; break;
                        }
                        case 'Z': break;
                    }
                }
                return points;
            }

            // Shoelace formula for signed area
            // Positive = clockwise in SVG coords (Y-axis down)
            function signedArea(points) {
                let area = 0;
                const n = points.length;
                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += points[i][0] * points[j][1];
                    area -= points[j][0] * points[i][1];
                }
                return area / 2;
            }

            // Ray casting point-in-polygon test
            function isPointInside(point, polygon) {
                const [px, py] = point;
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const [xi, yi] = polygon[i];
                    const [xj, yj] = polygon[j];
                    if ((yi > py) !== (yj > py) &&
                        px < (xj - xi) * (py - yi) / (yj - yi) + xi) {
                        inside = !inside;
                    }
                }
                return inside;
            }

            // Parse segments from a sub-path (for reversal)
            function parseSegments(subPath) {
                const tokens = tokenize(subPath);
                const segments = [];
                let startPoint = null;
                let currentPoint = null;
                let i = 0;
                while (i < tokens.length) {
                    const cmd = tokens[i++];
                    switch (cmd) {
                        case 'M': {
                            const x = parseFloat(tokens[i]), y = parseFloat(tokens[i + 1]);
                            startPoint = [x, y];
                            currentPoint = [x, y];
                            i += 2; break;
                        }
                        case 'L': {
                            const x = parseFloat(tokens[i]), y = parseFloat(tokens[i + 1]);
                            segments.push({ cmd: 'L', from: [...currentPoint], to: [x, y] });
                            currentPoint = [x, y];
                            i += 2; break;
                        }
                        case 'C': {
                            const x1 = parseFloat(tokens[i]), y1 = parseFloat(tokens[i + 1]);
                            const x2 = parseFloat(tokens[i + 2]), y2 = parseFloat(tokens[i + 3]);
                            const x = parseFloat(tokens[i + 4]), y = parseFloat(tokens[i + 5]);
                            segments.push({ cmd: 'C', from: [...currentPoint], cp1: [x1, y1], cp2: [x2, y2], to: [x, y] });
                            currentPoint = [x, y];
                            i += 6; break;
                        }
                        case 'Q': {
                            const cx = parseFloat(tokens[i]), cy = parseFloat(tokens[i + 1]);
                            const x = parseFloat(tokens[i + 2]), y = parseFloat(tokens[i + 3]);
                            segments.push({ cmd: 'Q', from: [...currentPoint], cp: [cx, cy], to: [x, y] });
                            currentPoint = [x, y];
                            i += 4; break;
                        }
                        case 'A': {
                            const rx = parseFloat(tokens[i]), ry = parseFloat(tokens[i + 1]);
                            const angle = parseFloat(tokens[i + 2]);
                            const largeArc = parseFloat(tokens[i + 3]);
                            const sweep = parseFloat(tokens[i + 4]);
                            const x = parseFloat(tokens[i + 5]), y = parseFloat(tokens[i + 6]);
                            segments.push({ cmd: 'A', from: [...currentPoint], rx, ry, angle, largeArc, sweep, to: [x, y] });
                            currentPoint = [x, y];
                            i += 7; break;
                        }
                        case 'Z': break;
                    }
                }
                return { startPoint, segments };
            }

            // Reverse a sub-path's winding direction
            function reverseSubPath(subPath) {
                const { startPoint, segments } = parseSegments(subPath);
                if (segments.length === 0) return subPath;

                const lastPoint = segments[segments.length - 1].to;
                let result = `M${lastPoint[0]} ${lastPoint[1]}`;

                for (let i = segments.length - 1; i >= 0; i--) {
                    const seg = segments[i];
                    switch (seg.cmd) {
                        case 'L':
                            result += ` L${seg.from[0]} ${seg.from[1]}`;
                            break;
                        case 'C':
                            // Reverse cubic: swap control points
                            result += ` C${seg.cp2[0]} ${seg.cp2[1]} ${seg.cp1[0]} ${seg.cp1[1]} ${seg.from[0]} ${seg.from[1]}`;
                            break;
                        case 'Q':
                            // Reverse quadratic: control point stays the same
                            result += ` Q${seg.cp[0]} ${seg.cp[1]} ${seg.from[0]} ${seg.from[1]}`;
                            break;
                        case 'A':
                            // Reverse arc: flip sweep flag
                            result += ` A${seg.rx} ${seg.ry} ${seg.angle} ${seg.largeArc} ${1 - seg.sweep} ${seg.from[0]} ${seg.from[1]}`;
                            break;
                    }
                }
                result += ' Z';
                return result;
            }

            evenOddPaths.forEach(pathEl => {
                const d = pathEl.getAttribute('d');
                if (!d) return;

                // Split into sub-paths at each M command
                const rawSubPaths = d.split(/(?=M)/).map(s => s.trim()).filter(s => s.length > 0);
                if (rawSubPaths.length <= 1) return; // Single sub-path, no conversion needed

                // Analyze each sub-path
                const subPathData = rawSubPaths.map((sp, idx) => {
                    const points = extractEndpoints(sp);
                    // Compute centroid of unique points (exclude closing duplicate)
                    // Centroid is more reliably interior than startPoint, which can fall
                    // near polygon edges where the approximation is weakest (Bug #4).
                    const unique = points.filter((p, i) =>
                        i === 0 || p[0] !== points[i - 1][0] || p[1] !== points[i - 1][1]);
                    const n = unique.length || 1;
                    const centroid = [
                        unique.reduce((s, p) => s + p[0], 0) / n,
                        unique.reduce((s, p) => s + p[1], 0) / n
                    ];
                    return {
                        raw: sp,
                        points: points,
                        area: signedArea(points),
                        centroid: centroid,
                        origIdx: idx
                    };
                });

                // Determine nesting level using area-ranked containment.
                // The sub-path with the largest absolute area is the outermost (level 0).
                // For each sub-path, count how many LARGER sub-paths contain its centroid.
                // Uses centroid (not startPoint) because it's more reliably inside the shape,
                // and less likely to fall in corners cut off by polygon approximation.
                const byArea = [...subPathData].sort((a, b) => Math.abs(b.area) - Math.abs(a.area));
                byArea.forEach((sp, rank) => {
                    let level = 0;
                    for (let j = 0; j < rank; j++) { // Only check sub-paths with larger area
                        if (isPointInside(sp.centroid, byArea[j].points)) {
                            level++;
                        }
                    }
                    sp.nestingLevel = level;
                });

                // Reference direction from the outermost sub-path (largest area = rank 0)
                const outer = byArea[0];
                const outerSign = outer.area >= 0 ? 1 : -1;

                // Correct winding directions based on nesting level
                const correctedParts = subPathData.map(sp => {
                    const expectedSign = (sp.nestingLevel % 2 === 0) ? outerSign : -outerSign;
                    const currentSign = sp.area >= 0 ? 1 : -1;

                    if (currentSign !== expectedSign) {
                        return reverseSubPath(sp.raw);
                    }
                    return sp.raw;
                });

                // Update the path: corrected winding + nonzero fill-rule (default)
                pathEl.setAttribute('d', correctedParts.join(' '));
                pathEl.removeAttribute('fill-rule');
                pathEl.removeAttribute('clip-rule');
            });
        }

        /**
         * Process SVG for FileMaker compatibility
         * - Adds fm_fill class
         * - Removes hardcoded fills (except fill="none")
         * - Normalizes path commands
         * - Converts evenodd compound paths to nonzero fill-rule
         * - Ensures viewBox is present
         * - Strips units from width/height
         */
        function processSVGForFileMaker(svg) {
            // Resolve any remaining CSS <style> rules into presentation attributes
            resolveStyleRules(svg);

            // Add fm_fill class for FileMaker dynamic coloring
            const existingClass = svg.getAttribute('class') || '';
            if (!existingClass.includes('fm_fill')) {
                svg.setAttribute('class', (existingClass + ' fm_fill').trim());
            }

            // Detect if this is a stroke-based (outline) icon
            // These have fill="none" on root with stroke for drawing  must preserve fill="none"
            const isStrokeBased = isStrokeBasedSVG(svg);

            if (isStrokeBased) {
                // For stroke-based icons: keep fill="none" on root, set stroke="currentColor"
                // FM will control the stroke color via fm_fill class
                svg.setAttribute('fill', 'none');
                svg.setAttribute('stroke', 'currentColor');
            } else {
                // For fill-based icons: set fill on SVG element - FM will override, children inherit
                svg.setAttribute('fill', 'currentColor');
            }

            // Ensure viewBox
            let vbW = 24, vbH = 24;
            if (!svg.getAttribute('viewBox')) {
                vbW = parseFloat(svg.getAttribute('width')) || 24;
                vbH = parseFloat(svg.getAttribute('height')) || 24;
                svg.setAttribute('viewBox', `0 0 ${vbW} ${vbH}`);
            } else {
                // Parse viewBox to get dimensions
                const vb = svg.getAttribute('viewBox').split(/\s+/);
                if (vb.length >= 4) {
                    vbW = parseFloat(vb[2]) || 24;
                    vbH = parseFloat(vb[3]) || 24;
                }
            }

            // Ensure width and height are set (required by FileMaker)
            if (!svg.getAttribute('width')) {
                svg.setAttribute('width', vbW);
            } else {
                svg.setAttribute('width', parseFloat(svg.getAttribute('width')) || vbW);
            }
            if (!svg.getAttribute('height')) {
                svg.setAttribute('height', vbH);
            } else {
                svg.setAttribute('height', parseFloat(svg.getAttribute('height')) || vbH);
            }

            // Remove invisible elements that FileMaker would render as visible
            // (FM doesn't support opacity attribute, so opacity="0" elements appear solid)
            // Common in SF Symbols and other icon sets as invisible bounding boxes
            const allElements = svg.querySelectorAll('*');
            allElements.forEach(el => {
                const opacity = el.getAttribute('opacity');
                if (opacity !== null && parseFloat(opacity) === 0) {
                    el.remove();
                }
            });

            // Remove fill-opacity and stroke-opacity attributes (unsupported by FileMaker)
            // These can cause rendering issues; FM controls color via fm_fill class
            svg.querySelectorAll('[fill-opacity]').forEach(el => {
                el.removeAttribute('fill-opacity');
            });
            svg.querySelectorAll('[stroke-opacity]').forEach(el => {
                el.removeAttribute('stroke-opacity');
            });

            // Migrate fill/stroke CSS properties from inline style to XML attributes
            // FileMaker doesn't handle CSS style attributes - it needs XML attributes
            // Without this, inline style="fill:none" overrides fill="#000000" attribute (CSS specificity)
            // which makes stroke-based SVGs (e.g. Inkscape exports) invisible in FM
            const styledShapes = svg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');
            styledShapes.forEach(el => {
                const styleAttr = el.getAttribute('style');
                if (!styleAttr) return;

                const propsToMigrate = ['fill', 'stroke', 'stroke-width', 'stroke-linecap',
                    'stroke-linejoin', 'stroke-miterlimit', 'stroke-dasharray',
                    'stroke-opacity', 'fill-opacity'];
                const remaining = [];

                styleAttr.split(';').forEach(decl => {
                    const colonIdx = decl.indexOf(':');
                    if (colonIdx === -1) return;
                    const name = decl.substring(0, colonIdx).trim();
                    const value = decl.substring(colonIdx + 1).trim();

                    if (propsToMigrate.includes(name) && value) {
                        el.setAttribute(name, value);
                    } else if (decl.trim()) {
                        remaining.push(decl.trim());
                    }
                });

                if (remaining.length > 0) {
                    el.setAttribute('style', remaining.join(';'));
                } else {
                    el.removeAttribute('style');
                }
            });

            // Remove hardcoded fills (except fill="none") - only if dynamic fill is enabled
            if (state.fmDynamicFill) {
                const bgElement = svg.querySelector('.fm-background');
                const iconGroup = svg.querySelector('.fm-icon');

                if (bgElement && iconGroup) {
                    // We have both background and icon - apply based on target
                    if (state.fmDynamicTarget === 'icon') {
                        // Set icon fills to inherit for FM dynamic styling, keep background fill
                        // Preserve 'none', 'currentColor', and 'inherit'
                        const iconElements = iconGroup.querySelectorAll('*');
                        iconElements.forEach(el => {
                            const fill = el.getAttribute('fill');
                            if (fill && fill !== 'none' && fill !== 'currentColor' && fill !== 'inherit') {
                                el.setAttribute('fill', 'inherit');
                            }
                            if (el.style && el.style.fill && el.style.fill !== 'none') {
                                el.style.fill = 'inherit';
                            }
                        });
                        // Also check the icon group itself
                        if (iconGroup.getAttribute('fill') && iconGroup.getAttribute('fill') !== 'none') {
                            iconGroup.setAttribute('fill', 'inherit');
                        }
                    } else {
                        // Set background fill to inherit, keep icon fills
                        bgElement.setAttribute('fill', 'inherit');
                    }
                } else {
                    // No background/icon distinction - set fills to inherit for FM dynamic styling
                    // Preserve 'none', 'currentColor', and 'inherit'
                    const elements = svg.querySelectorAll('*');
                    elements.forEach(el => {
                        const fill = el.getAttribute('fill');
                        if (fill && fill !== 'none' && fill !== 'currentColor' && fill !== 'inherit') {
                            el.setAttribute('fill', 'inherit');
                        }
                        if (el.style && el.style.fill && el.style.fill !== 'none') {
                            el.style.fill = 'inherit';
                        }
                    });
                }
            }

            // Handle stroke attributes for FileMaker
            // For stroke-only elements (fill="none" with stroke), convert them to fill-based for FM
            // For other elements, add stroke="none" (required by FileMaker)
            const shapeElements = svg.querySelectorAll('path, circle, rect, ellipse, line, polyline, polygon');
            shapeElements.forEach(el => {
                const fill = el.getAttribute('fill');
                const stroke = el.getAttribute('stroke');

                if (fill === 'none' && stroke && stroke !== 'none') {
                    // This is a stroke-only element - for FM dynamic coloring to work,
                    // we need to set stroke to inherit so FM can control it
                    if (state.fmDynamicFill) {
                        el.setAttribute('stroke', 'inherit');
                    }
                } else if (!stroke || stroke === '') {
                    // No stroke defined - add stroke="none" (required by FileMaker)
                    el.setAttribute('stroke', 'none');
                }
            });

            // Always normalize paths for FileMaker - it requires absolute commands with proper spacing
            // The normalizePath function now handles arc flag notation correctly
            const paths = svg.querySelectorAll('path');
            console.log(`[processSVGForFileMaker] Found ${paths.length} path(s) to normalize`);
            let normalizedCount = 0;
            let failedCount = 0;
            paths.forEach((path, index) => {
                const d = path.getAttribute('d');
                if (d) {
                    const originalFirst50 = d.substring(0, 50);
                    try {
                        const normalized = normalizePath(d);
                        if (normalized && normalized.length > 0) {
                            path.setAttribute('d', normalized);
                            normalizedCount++;
                            // Check if it actually changed
                            if (normalized === d) {
                                console.warn(`Path ${index}: normalization returned identical string`);
                            }
                        } else {
                            console.warn(`Path ${index}: normalization returned empty, keeping original. First 50 chars: "${originalFirst50}"`);
                            failedCount++;
                        }
                    } catch (e) {
                        console.error(`Path ${index}: normalization failed:`, e, `First 50 chars: "${originalFirst50}"`);
                        failedCount++;
                        // Keep original path if normalization fails
                    }
                }
            });
            console.log(`[processSVGForFileMaker] Normalized: ${normalizedCount}, Failed: ${failedCount}`);

            // Convert evenodd compound paths to nonzero fill-rule
            // FileMaker button bars don't support evenodd, causing letter cutouts to disappear
            // (e.g. Adobe product icons where letters are "holes" in a filled background)
            convertEvenOddToNonZero(svg);

            // Ensure xmlns
            if (!svg.getAttribute('xmlns')) {
                svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            }

            // Remove version attribute
            svg.removeAttribute('version');

            return svg;
        }

        // ============================================
        // Zoom Controls
        // ============================================

        function adjustZoom(delta) {
            state.zoom = Math.max(0.25, Math.min(4, state.zoom + delta));
            updateZoomDisplay();
        }

        function resetZoom() {
            state.zoom = 1;
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
            const wrapper = document.getElementById('preview-wrapper');
            const container = document.getElementById('preview-svg');
            const grid = container.querySelector('.preview-grid');

            if (grid) {
                // Grid mode - adjust tile size instead of scaling wrapper
                wrapper.style.transform = 'scale(1)';
                const baseTileSize = 100;  // Base tile size in pixels
                const scaledSize = Math.round(baseTileSize * state.zoom);
                grid.style.setProperty('--tile-size', scaledSize + 'px');
            } else {
                // Single SVG mode - scale the wrapper
                wrapper.style.transform = `scale(${state.zoom})`;
            }
        }

        function autoZoom() {
            if (!hasLoadedSVGs()) return;

            // For multi-SVG mode with grid, reset to 1x zoom
            if (state.svgItems.length > 1) {
                state.zoom = 1;
                updateZoomDisplay();
                return;
            }

            // Single SVG mode - calculate optimal zoom
            const firstItem = state.svgItems[0];
            const viewBox = firstItem.currentSVG.getAttribute('viewBox');
            let svgWidth, svgHeight;

            if (viewBox) {
                const parts = viewBox.split(/\s+/).map(parseFloat);
                svgWidth = parts[2];
                svgHeight = parts[3];
            } else {
                svgWidth = parseFloat(firstItem.currentSVG.getAttribute('width')) || 200;
                svgHeight = parseFloat(firstItem.currentSVG.getAttribute('height')) || 200;
            }

            // Get preview container dimensions
            const container = document.querySelector('.preview-container');
            if (!container) return;

            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width - 48;  // Account for padding
            const containerHeight = containerRect.height - 48;

            // The SVG in preview is rendered at 200x200 base size
            const baseSize = 200;

            // Calculate zoom to fill ~50% of container
            const targetFill = 0.5;
            const scaleToFitWidth = (containerWidth * targetFill) / baseSize;
            const scaleToFitHeight = (containerHeight * targetFill) / baseSize;

            // Use the smaller scale to ensure it fits, and clamp between 0.5 and 4
            state.zoom = Math.min(Math.max(Math.min(scaleToFitWidth, scaleToFitHeight), 0.5), 4);
            updateZoomDisplay();
        }

        // ============================================
        // Reset Functions
        // ============================================

        /**
         * Reset transformation state (preserves svgItems array)
         */
        function resetState() {
            state.rotation = 0;
            state.flipH = false;
            state.flipV = false;
            state.fillColor = '#000000';
            state.strokeColor = '#000000';
            state.strokeWidth = 0;
            state.bgEnabled = false;
            state.bgColor = '#ffffff';
            state.bgEdges = 4;
            state.iconPadding = 10;
            state.cornerRadius = 10;
            state.zoom = 1;
            state.opacity = 100;
            state.scale = 100;
            state.offsetX = 0;
            state.offsetY = 0;

            // Update UI
            document.getElementById('rotation-value').textContent = '0';
            document.getElementById('fill-color').value = '#000000';
            document.getElementById('fill-hex').value = '#000000';
            document.getElementById('fill-color').parentElement.style.background = '#000000';
            document.getElementById('stroke-color').value = '#000000';
            document.getElementById('stroke-hex').value = '#000000';
            document.getElementById('stroke-color').parentElement.style.background = '#000000';
            document.getElementById('stroke-width').value = 0;
            document.getElementById('stroke-value').textContent = '0';
            document.getElementById('bg-enabled').checked = false;
            document.getElementById('bg-options').classList.remove('visible');
            document.getElementById('bg-color').value = '#ffffff';
            document.getElementById('bg-hex').value = '#ffffff';
            document.getElementById('bg-color-preview').style.background = '#ffffff';
            document.getElementById('icon-padding').value = 10;
            document.getElementById('padding-value').textContent = '10%';
            document.getElementById('corner-radius').value = 10;
            document.getElementById('radius-value').textContent = '10%';
            document.getElementById('opacity-slider').value = 100;
            document.getElementById('opacity-value').textContent = '100%';
            document.getElementById('scale-slider').value = 100;
            document.getElementById('scale-value').textContent = '100%';
            document.getElementById('offset-x-slider').value = 0;
            document.getElementById('offset-x-value').textContent = '0';
            document.getElementById('offset-y-slider').value = 0;
            document.getElementById('offset-y-value').textContent = '0';
            setBgEdges(4);
            updateZoomDisplay();
            // Reset FM target to icon and update visibility
            setFMTarget('icon');
            updateFMTargetVisibility();
        }

        function resetAll() {
            if (hasLoadedSVGs()) {
                // If there are undoable changes, prompt for confirmation
                if (hasUndoableChanges()) {
                    showConfirmModal({
                        title: 'Reset to Original?',
                        message: 'You have unsaved changes. Are you sure you want to reset all SVGs to their original state? This action cannot be undone.',
                        confirmText: 'Reset',
                        onConfirm: performReset
                    });
                    return;
                }

                performReset();
            }
        }

        /**
         * Actually perform the reset (called directly or after confirmation)
         */
        function performReset() {
            if (hasLoadedSVGs()) {
                // Re-parse all original SVGs
                const parser = new DOMParser();
                state.svgItems.forEach(item => {
                    const doc = parser.parseFromString(item.originalSVG, 'image/svg+xml');
                    item.currentSVG = doc.querySelector('svg').cloneNode(true);
                });
                resetState();
                clearHistory();
                renderPreview();
            }
        }

        // ============================================
        // Rendering
        // ============================================

        function renderPreview() {
            if (!hasLoadedSVGs()) return;

            const container = document.getElementById('preview-svg');
            const emptyState = document.getElementById('empty-state');
            const wrapper = document.getElementById('preview-wrapper');

            container.innerHTML = '';

            // Clean up single-mode hover buttons (may be stale from previous render)
            const dropZoneEl = document.getElementById('drop-zone');
            if (dropZoneEl) {
                const staleBtn = dropZoneEl.querySelector('.single-remove-btn');
                if (staleBtn) staleBtn.remove();
                const staleActions = dropZoneEl.querySelector('.single-actions');
                if (staleActions) staleActions.remove();
            }

            // If only one SVG, use single preview mode
            if (state.svgItems.length === 1) {
                container.classList.remove('grid-mode');

                const finalSVG = generateFinalSVG(state.svgItems[0]);

                // Set a reasonable preview size
                finalSVG.setAttribute('width', '200');
                finalSVG.setAttribute('height', '200');
                finalSVG.style.maxWidth = '100%';
                finalSVG.style.maxHeight = '100%';

                container.appendChild(finalSVG);

                // Add single-mode remove button
                const previewContainer = document.getElementById('drop-zone');
                // Remove any existing single remove btn
                const existingBtn = previewContainer.querySelector('.single-remove-btn');
                if (existingBtn) existingBtn.remove();

                const removeBtn = document.createElement('button');
                removeBtn.className = 'single-remove-btn';
                removeBtn.innerHTML = '&times;';
                removeBtn.title = 'Remove SVG';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeSVGItem(0);
                });
                previewContainer.appendChild(removeBtn);

                // Add single-mode action buttons (copy, view code) - top-left
                const actions = document.createElement('div');
                actions.className = 'single-actions';

                const copyBtn = document.createElement('button');
                copyBtn.className = 'single-action-btn';
                copyBtn.title = 'Copy SVG';
                copyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
                copyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    performCopySVG(0);
                });

                const codeBtn = document.createElement('button');
                codeBtn.className = 'single-action-btn';
                codeBtn.title = 'View Code';
                codeBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>';
                codeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    performCodeView(0);
                });

                actions.appendChild(copyBtn);
                actions.appendChild(codeBtn);
                previewContainer.appendChild(actions);

                // Apply zoom via wrapper scale for single SVG
                wrapper.style.transform = `scale(${state.zoom})`;
            } else {
                // Multiple SVGs - render as tile grid
                container.classList.add('grid-mode');

                const grid = document.createElement('div');
                grid.className = 'preview-grid';

                // Set initial tile size based on current zoom
                const baseTileSize = 100;
                const scaledSize = Math.round(baseTileSize * state.zoom);
                grid.style.setProperty('--tile-size', scaledSize + 'px');

                state.svgItems.forEach((item, index) => {
                    const tile = createPreviewTile(item, index);
                    grid.appendChild(tile);
                });

                container.appendChild(grid);

                // Reset wrapper scale for grid mode (tiles handle their own sizing)
                wrapper.style.transform = 'scale(1)';
            }

            // Hide empty state when SVGs are loaded
            if (emptyState) {
                emptyState.classList.add('hidden');
            }

            updateControlsPanelVisibility();
            updatePreviewFilename();
        }

        /**
         * Create a preview tile for a single SVG item
         * @param {Object} item - SVG item {filename, originalSVG, currentSVG}
         * @param {number} index - Index in the svgItems array
         * @returns {HTMLElement} - Tile element
         */
        function createPreviewTile(item, index) {
            const tile = document.createElement('div');
            tile.className = 'preview-tile';
            tile.dataset.index = index;

            // Drag reorder attributes
            tile.draggable = true;
            tile.addEventListener('dragstart', handleTileDragStart);
            tile.addEventListener('dragend', handleTileDragEnd);
            tile.addEventListener('dragover', handleTileDragOver);
            tile.addEventListener('dragleave', handleTileDragLeave);
            tile.addEventListener('drop', handleTileDrop);

            // Remove button (top-right)
            const removeBtn = document.createElement('button');
            removeBtn.className = 'tile-remove-btn';
            removeBtn.innerHTML = '&times;';
            removeBtn.title = 'Remove';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeSVGItem(index);
            });

            // Action buttons (top-left): copy, view code
            const actions = document.createElement('div');
            actions.className = 'tile-actions';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'tile-action-btn';
            copyBtn.title = 'Copy SVG';
            copyBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                performCopySVG(index);
            });

            const codeBtn = document.createElement('button');
            codeBtn.className = 'tile-action-btn';
            codeBtn.title = 'View Code';
            codeBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>';
            codeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                performCodeView(index);
            });

            actions.appendChild(copyBtn);
            actions.appendChild(codeBtn);

            // SVG container
            const svgContainer = document.createElement('div');
            svgContainer.className = 'tile-svg';

            const finalSVG = generateFinalSVG(item);
            if (finalSVG) {
                // Use 100% to fill the container (size controlled by CSS --tile-size)
                finalSVG.setAttribute('width', '100%');
                finalSVG.setAttribute('height', '100%');
                svgContainer.appendChild(finalSVG);
            }

            // Filename label
            const filenameLabel = document.createElement('div');
            filenameLabel.className = 'tile-filename';
            filenameLabel.textContent = item.filename;
            filenameLabel.title = item.filename; // Full name on hover

            tile.appendChild(removeBtn);
            tile.appendChild(actions);
            tile.appendChild(svgContainer);
            tile.appendChild(filenameLabel);

            return tile;
        }

        /**
         * Show the empty state (when no SVG is loaded)
         */
        function showEmptyState() {
            const container = document.getElementById('preview-svg');
            const emptyState = document.getElementById('empty-state');

            container.innerHTML = '';
            container.classList.remove('grid-mode');

            // Remove single-mode hover buttons if present
            const previewContainer = document.getElementById('drop-zone');
            if (previewContainer) {
                const existingBtn = previewContainer.querySelector('.single-remove-btn');
                if (existingBtn) existingBtn.remove();
                const existingActions = previewContainer.querySelector('.single-actions');
                if (existingActions) existingActions.remove();
            }

            if (emptyState) {
                emptyState.classList.remove('hidden');
            }

            updateControlsPanelVisibility();
            updateSaveButton();
            updatePreviewFilename();
        }

        /**
         * Generate the final SVG with all transformations applied
         * @param {Object} svgItem - Optional SVG item. If not provided, uses first item for preview.
         */
        function generateFinalSVG(svgItem) {
            // Use provided item or first item in array
            const item = svgItem || state.svgItems[0];
            if (!item) return null;

            // Clone the current SVG
            const svg = item.currentSVG.cloneNode(true);

            // Get viewBox or create one
            let viewBox = svg.getAttribute('viewBox');
            if (!viewBox) {
                const w = parseFloat(svg.getAttribute('width')) || 24;
                const h = parseFloat(svg.getAttribute('height')) || 24;
                viewBox = `0 0 ${w} ${h}`;
                svg.setAttribute('viewBox', viewBox);
            }

            const [vbX, vbY, vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
            const centerX = vbX + vbW / 2;
            const centerY = vbY + vbH / 2;

            // Apply fill color to all elements
            applyFillColor(svg, state.fillColor);

            // Apply stroke if enabled
            if (state.strokeWidth > 0) {
                applyStroke(svg, state.strokeColor, state.strokeWidth);
            }

            // Build transformation string
            const transforms = [];

            // Apply offset (translate)
            if (state.offsetX !== 0 || state.offsetY !== 0) {
                const offsetXPx = (state.offsetX / 100) * vbW;
                const offsetYPx = (state.offsetY / 100) * vbH;
                transforms.push(`translate(${offsetXPx} ${offsetYPx})`);
            }

            // Apply scale
            if (state.scale !== 100) {
                const scaleFactor = state.scale / 100;
                transforms.push(`translate(${centerX} ${centerY}) scale(${scaleFactor}) translate(${-centerX} ${-centerY})`);
            }

            // Apply rotation
            if (state.rotation !== 0) {
                transforms.push(`rotate(${state.rotation} ${centerX} ${centerY})`);
            }

            // Apply flips
            if (state.flipH || state.flipV) {
                const scaleX = state.flipH ? -1 : 1;
                const scaleY = state.flipV ? -1 : 1;
                transforms.push(`translate(${centerX} ${centerY}) scale(${scaleX} ${scaleY}) translate(${-centerX} ${-centerY})`);
            }

            // Check if we need a wrapper group (for transforms or opacity)
            const needsGroup = transforms.length > 0 || state.opacity !== 100;

            // Wrap content in a group with transforms and/or opacity
            if (needsGroup) {
                const content = Array.from(svg.childNodes);
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                if (transforms.length > 0) {
                    group.setAttribute('transform', transforms.join(' '));
                }
                if (state.opacity !== 100) {
                    group.setAttribute('opacity', state.opacity / 100);
                }
                content.forEach(node => group.appendChild(node.cloneNode(true)));
                svg.innerHTML = '';
                svg.appendChild(group);
            }

            // Add background if enabled
            if (state.bgEnabled) {
                return wrapWithBackground(svg, vbW, vbH);
            }

            return svg;
        }

        function applyFillColor(svg, color) {
            // Apply fill to elements that should be filled
            // For stroke-only elements (fill="none"), apply the color to their stroke instead
            const svgFill = svg.getAttribute('fill');
            const svgStroke = svg.getAttribute('stroke');
            const elements = svg.querySelectorAll('path, circle, rect, polygon, polyline, ellipse, line');
            elements.forEach(el => {
                const currentFill = el.getAttribute('fill');
                const currentStroke = el.getAttribute('stroke');
                // Resolve effective fill: element attribute, then inherited from parent SVG
                const effectiveFill = currentFill || svgFill || '';
                const effectiveStroke = currentStroke || svgStroke || '';

                if (effectiveFill === 'none') {
                    // This is a stroke-only element - apply color to stroke
                    if (effectiveStroke && effectiveStroke !== 'none') {
                        el.setAttribute('stroke', color);
                    }
                } else {
                    // Normal filled element - apply color to fill
                    el.setAttribute('fill', color);
                }

                // Also check style attribute
                if (el.style.fill && el.style.fill !== 'none') {
                    el.style.fill = color;
                }
                if (el.style.stroke && el.style.stroke !== 'none' && effectiveFill === 'none') {
                    el.style.stroke = color;
                }
            });

            // Handle groups that might have fill
            const groups = svg.querySelectorAll('g[fill]');
            groups.forEach(g => {
                if (g.getAttribute('fill') !== 'none') {
                    g.setAttribute('fill', color);
                }
            });
        }

        function applyStroke(svg, color, width) {
            const elements = svg.querySelectorAll('path, circle, rect, polygon, polyline, ellipse, line');
            elements.forEach(el => {
                el.setAttribute('stroke', color);
                el.setAttribute('stroke-width', width);
            });
        }

        function wrapWithBackground(iconSvg, origWidth, origHeight) {
            // Create new SVG with background
            const newSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            newSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

            // Calculate padding
            const padding = (state.iconPadding / 100) * Math.max(origWidth, origHeight);
            const totalSize = Math.max(origWidth, origHeight) + padding * 2;

            newSvg.setAttribute('viewBox', `0 0 ${totalSize} ${totalSize}`);
            newSvg.setAttribute('width', totalSize);
            newSvg.setAttribute('height', totalSize);

            // Create background shape
            let bgShape;
            if (state.bgEdges === 0) {
                // Circle
                bgShape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                bgShape.setAttribute('cx', totalSize / 2);
                bgShape.setAttribute('cy', totalSize / 2);
                bgShape.setAttribute('r', totalSize / 2);
            } else if (state.bgEdges === 4) {
                // Square: use rect for cleaner output
                bgShape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bgShape.setAttribute('x', 0);
                bgShape.setAttribute('y', 0);
                bgShape.setAttribute('width', totalSize);
                bgShape.setAttribute('height', totalSize);
                const radius = (state.cornerRadius / 100) * totalSize;
                if (radius > 0) {
                    bgShape.setAttribute('rx', radius);
                    bgShape.setAttribute('ry', radius);
                }
            } else {
                // Polygon (3, 5, 6, 7, ...)
                bgShape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const cornerRadiusFraction = state.cornerRadius / 100;
                const d = generatePolygonPath(totalSize / 2, totalSize / 2, totalSize / 2, state.bgEdges, cornerRadiusFraction);
                bgShape.setAttribute('d', d);
            }
            bgShape.setAttribute('fill', state.bgColor);
            bgShape.setAttribute('class', 'fm-background');
            newSvg.appendChild(bgShape);

            // Create group for the icon
            const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            iconGroup.setAttribute('class', 'fm-icon');

            // Calculate scale and position to center the icon
            const iconScale = (totalSize - padding * 2) / Math.max(origWidth, origHeight);
            const offsetX = (totalSize - origWidth * iconScale) / 2;
            const offsetY = (totalSize - origHeight * iconScale) / 2;

            iconGroup.setAttribute('transform', `translate(${offsetX} ${offsetY}) scale(${iconScale})`);

            // Copy all children from icon SVG
            Array.from(iconSvg.childNodes).forEach(node => {
                iconGroup.appendChild(node.cloneNode(true));
            });

            newSvg.appendChild(iconGroup);

            return newSvg;
        }

        // ============================================
        // Utility Functions
        // ============================================

        function normalizeHex(value) {
            const v = value.trim();
            if (/^[0-9a-fA-F]{3,8}$/.test(v)) return '#' + v;
            return v;
        }

        function isValidColor(color) {
            const s = new Option().style;
            s.color = color;
            return s.color !== '';
        }

        function hexToHSV(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min;
            let h = 0, s = max === 0 ? 0 : d / max, v = max;
            if (d !== 0) {
                if (max === r) h = ((g - b) / d + 6) % 6;
                else if (max === g) h = (b - r) / d + 2;
                else h = (r - g) / d + 4;
                h *= 60;
            }
            return { h, s, v };
        }

        function hsvToHex(h, s, v) {
            let c = v * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = v - c;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            const toHex = n => Math.round((n + m) * 255).toString(16).padStart(2, '0');
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }

        function updateSizeInfo() {
            const dimEl = document.getElementById('svg-dimensions');
            const sizeEl = document.getElementById('svg-size');
            if (!hasLoadedSVGs()) {
                dimEl.style.display = 'none';
                sizeEl.style.display = 'none';
                return;
            }
            dimEl.style.display = '';
            sizeEl.style.display = '';

            const count = state.svgItems.length;

            if (count === 1) {
                // Single SVG - show dimensions and size
                const item = state.svgItems[0];
                const viewBox = item.currentSVG.getAttribute('viewBox');
                let w, h;

                if (viewBox) {
                    const parts = viewBox.split(/\s+/);
                    w = parts[2];
                    h = parts[3];
                } else {
                    w = item.currentSVG.getAttribute('width') || '?';
                    h = item.currentSVG.getAttribute('height') || '?';
                }

                document.getElementById('svg-dimensions').textContent = `Dimensions: ${w}  ${h}`;

                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(item.currentSVG);
                const bytes = new Blob([svgString]).size;
                document.getElementById('svg-size').textContent = `Size: ${formatBytes(bytes)}`;
            } else {
                // Multiple SVGs - show count and total size
                document.getElementById('svg-dimensions').textContent = `Files: ${count} SVGs`;

                const serializer = new XMLSerializer();
                let totalBytes = 0;
                state.svgItems.forEach(item => {
                    const svgString = serializer.serializeToString(item.currentSVG);
                    totalBytes += new Blob([svgString]).size;
                });
                document.getElementById('svg-size').textContent = `Total size: ${formatBytes(totalBytes)}`;
            }
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ============================================
        // Keyboard Shortcuts
        // ============================================

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function (e) {
                // Skip if in library mode (it has its own keyboard handler)
                if (ibIsLibraryMode()) return;

                // Skip if focus is in an input, textarea, or select
                const tag = document.activeElement.tagName.toLowerCase();
                if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const modKey = isMac ? e.metaKey : e.ctrlKey;

                // Escape - close code view modal
                if (e.key === 'Escape') {
                    const codeViewModal = document.getElementById('code-view-modal');
                    if (codeViewModal && codeViewModal.classList.contains('visible')) {
                        hideCodeView();
                        return;
                    }
                    const selectionModal = document.getElementById('svg-selection-modal');
                    if (selectionModal && selectionModal.classList.contains('visible')) {
                        hideSVGSelectionModal();
                        return;
                    }
                }

                // Ctrl/Cmd+Z = Undo
                if (modKey && !e.shiftKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                    return;
                }

                // Ctrl/Cmd+Shift+Z or Ctrl/Cmd+Y = Redo
                if ((modKey && e.shiftKey && e.key === 'z') || (modKey && e.key === 'y')) {
                    e.preventDefault();
                    redo();
                    return;
                }

            });

            // Listen for paste event (handles both text and file pastes)
            document.addEventListener('paste', function (e) {
                // Skip if focus is in an input/textarea/select
                const tag = (e.target.tagName || '').toLowerCase();
                if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

                // Check for SVG files on the clipboard first
                const files = e.clipboardData && e.clipboardData.files;
                if (files && files.length > 0) {
                    const svgFiles = Array.from(files).filter(f =>
                        f.type === 'image/svg+xml' || (f.name && f.name.toLowerCase().endsWith('.svg'))
                    );
                    if (svgFiles.length > 0) {
                        e.preventDefault();
                        handlePastedFiles(svgFiles);
                        return;
                    }
                }

                // Check for SVG text on the clipboard
                const text = e.clipboardData && e.clipboardData.getData('text/plain');
                if (text && text.includes('<svg')) {
                    e.preventDefault();
                    processPastedSVGText(text);
                }
            });
        }

        // ============================================
        // Paste SVG from Clipboard
        // ============================================

        /**
         * Handle paste button click (for FileMaker where Cmd+V is intercepted)
         * Uses Clipboard API to read both files and text
         */
        /**
         * Handle paste button click.
         * Uses execCommand('paste') via hidden textarea to avoid Safari/WebKit
         * clipboard permission popup. Falls back to Clipboard API if needed.
         * Note: File paste from OS clipboard only works via Cmd+V in browsers,
         * not via button click (browser security restriction).
         */
        function handlePasteButton() {
            // Primary: use hidden textarea + execCommand to avoid permission popup
            const textarea = document.createElement('textarea');
            textarea.style.cssText = 'position:fixed;left:-9999px;top:0;opacity:0;';
            document.body.appendChild(textarea);
            textarea.focus();

            const pasted = document.execCommand('paste');

            // Short delay to ensure paste completes
            setTimeout(() => {
                const text = textarea.value;
                document.body.removeChild(textarea);

                if (text && text.trim()) {
                    processPastedSVGText(text);
                } else if (!pasted && navigator.clipboard && navigator.clipboard.readText) {
                    // execCommand failed entirely, try Clipboard API as fallback
                    navigator.clipboard.readText().then(t => {
                        if (t && t.trim()) {
                            processPastedSVGText(t);
                        } else {
                            showPreviewToast('No SVG found on clipboard');
                        }
                    }).catch(() => {
                        showPreviewToast('Could not read clipboard');
                    });
                } else {
                    showPreviewToast('No SVG found on clipboard');
                }
            }, 50);
        }

        /**
         * Handle SVG files pasted via paste event
         * @param {File[]} files - Array of SVG files from clipboardData.files
         */
        function handlePastedFiles(files) {
            // If there are existing SVGs with unsaved changes, confirm
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                showConfirmModal({
                    title: 'Load Pasted SVGs?',
                    message: 'You have unsaved changes. Loading pasted SVGs will discard these changes.',
                    confirmText: 'Load',
                    onConfirm: () => loadFilesAsSVG(files)
                });
                return;
            }

            loadFilesAsSVG(files);
            showPreviewToast(files.length === 1 ? 'SVG pasted' : files.length + ' SVGs pasted');
        }

        /**
         * Process pasted text that may contain SVG markup
         * @param {string} text - Text from clipboard
         */
        function processPastedSVGText(text) {
            if (!text || !text.trim()) {
                showPreviewToast('No SVG found on clipboard');
                return;
            }

            const trimmed = text.trim();

            // Extract all SVG elements from the text
            const svgRegex = /<svg[\s\S]*?<\/svg>/gi;
            const matches = trimmed.match(svgRegex);

            if (!matches || matches.length === 0) {
                showPreviewToast('No SVG found on clipboard');
                return;
            }

            // Validate each match
            const parser = new DOMParser();
            const validSVGs = [];
            for (const svgString of matches) {
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                if (!doc.querySelector('parsererror') && doc.querySelector('svg')) {
                    validSVGs.push(svgString);
                }
            }

            if (validSVGs.length === 0) {
                showPreviewToast('Invalid SVG on clipboard');
                return;
            }

            loadPastedSVGs(validSVGs);
        }

        /**
         * Load one or more validated SVG strings as pasted items
         * @param {string[]} svgStrings - Array of valid SVG markup strings
         */
        function loadPastedSVGs(svgStrings) {
            // If there are existing SVGs with unsaved changes, confirm
            if (hasLoadedSVGs() && hasUndoableChanges()) {
                showConfirmModal({
                    title: svgStrings.length === 1 ? 'Load Pasted SVG?' : 'Load ' + svgStrings.length + ' Pasted SVGs?',
                    message: 'You have unsaved changes. Loading pasted SVGs will discard these changes.',
                    confirmText: 'Load',
                    onConfirm: () => performLoadPastedSVGs(svgStrings)
                });
                return;
            }

            performLoadPastedSVGs(svgStrings);
        }

        /**
         * Actually load pasted SVG strings into the editor
         */
        function performLoadPastedSVGs(svgStrings) {
            state.svgItems = [];
            resetState();
            clearHistory();

            svgStrings.forEach((svgString, i) => {
                const name = svgStrings.length === 1 ? 'pasted.svg' : 'pasted-' + (i + 1) + '.svg';
                addSVGItem(name, svgString);
            });

            renderPreview();
            updateSizeInfo();
            updateSaveButton();
            detectStrokeSVGs();
            setTimeout(autoZoom, 50);

            const count = state.svgItems.length;
            showPreviewToast(count === 1 ? 'SVG pasted' : count + ' SVGs pasted');
        }

        /**
         * Extract SVG markup from a string, returns null if invalid
         */
        function extractSVG(text) {
            if (!text) return null;
            const match = text.trim().match(/<svg[\s\S]*<\/svg>/i);
            if (!match) return null;
            const parser = new DOMParser();
            const doc = parser.parseFromString(match[0], 'image/svg+xml');
            if (doc.querySelector('parsererror') || !doc.querySelector('svg')) return null;
            return match[0];
        }

        // ============================================
        // Collapsible Control Sections
        // ============================================

        function setupCollapsibleSections() {
            const sections = document.querySelectorAll('.controls-panel .control-section');
            sections.forEach(section => {
                const h3 = section.querySelector('h3');
                if (!h3) return;

                // Add chevron indicator
                const chevron = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                chevron.setAttribute('viewBox', '0 0 24 24');
                chevron.setAttribute('fill', 'none');
                chevron.setAttribute('stroke', 'currentColor');
                chevron.setAttribute('stroke-width', '2');
                chevron.classList.add('chevron');
                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', '6 9 12 15 18 9');
                chevron.appendChild(polyline);
                h3.appendChild(chevron);

                // Wrap content below h3 in a container div
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'control-section-content';
                const children = Array.from(section.children).filter(child => child !== h3);
                children.forEach(child => contentWrapper.appendChild(child));
                section.appendChild(contentWrapper);

                // Toggle on click
                h3.addEventListener('click', () => {
                    section.classList.toggle('collapsed');
                });
            });
        }

        // ============================================
        // Preview Background Toggle
        // ============================================

        function togglePreviewBgDropdown(event) {
            event.stopPropagation();
            const container = document.getElementById('preview-bg-container');
            container.classList.toggle('open');
        }

        function updateControlsPanelVisibility() {
            const panel = document.querySelector('.controls-panel');
            if (panel) {
                // Always show controls panel in library mode (sidebar needs to be visible)
                panel.classList.toggle('hidden', !ibIsLibraryMode() && !hasLoadedSVGs());
            }
        }

        function getContrastColor(hexColor) {
            const hex = hexColor.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            return luminance > 128 ? '#000000' : '#ffffff';
        }

        function updatePreviewTextColor(mode) {
            const previewContainer = document.getElementById('preview-svg');
            if (!previewContainer) return;

            if (mode === 'checkerboard') {
                previewContainer.classList.remove('colored-bg-active');
                previewContainer.style.removeProperty('--preview-text-color');
            } else {
                previewContainer.classList.add('colored-bg-active');
                let textColor;
                if (mode === 'white') {
                    textColor = '#000000';
                } else if (mode === 'black') {
                    textColor = '#ffffff';
                } else if (mode === 'custom') {
                    textColor = getContrastColor(state.previewBgCustomColor || '#ffffff');
                }
                previewContainer.style.setProperty('--preview-text-color', textColor);
            }
        }

        function setPreviewBg(mode) {
            state.previewBg = mode;
            const bgEl = document.querySelector('.preview-bg');
            bgEl.classList.remove('bg-white', 'bg-black', 'bg-custom');
            // Always clear inline backgroundColor so it doesn't bleed into other modes
            bgEl.style.backgroundColor = '';

            if (mode === 'white') {
                bgEl.classList.add('bg-white');
            } else if (mode === 'black') {
                bgEl.classList.add('bg-black');
            } else if (mode === 'custom') {
                bgEl.classList.add('bg-custom');
                bgEl.style.backgroundColor = state.previewBgCustomColor;
            }
            // 'checkerboard' = default (no extra class, no inline bg color)

            // Update active state
            document.querySelectorAll('.preview-bg-option').forEach(opt => {
                opt.classList.toggle('active', opt.dataset.bg === mode);
            });

            // Show/hide custom color picker
            const customPicker = document.getElementById('preview-bg-custom-picker');
            if (customPicker) {
                customPicker.style.display = mode === 'custom' ? 'flex' : 'none';
            }

            // Close dropdown (but keep open for custom so user can pick color)
            if (mode !== 'custom') {
                document.getElementById('preview-bg-container').classList.remove('open');
            }
            updatePreviewTextColor(mode);
            savePreferences();
        }

        function updatePreviewBgCustomColor(color) {
            state.previewBgCustomColor = color;
            const bgEl = document.querySelector('.preview-bg');
            if (state.previewBg === 'custom') {
                bgEl.style.backgroundColor = color;
                updatePreviewTextColor('custom');
            }
            // Update swatch
            const swatch = document.getElementById('preview-bg-custom-swatch');
            if (swatch) swatch.style.background = color;
            savePreferences();
        }

        // Close preview bg dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const container = document.getElementById('preview-bg-container');
            if (container && !container.contains(event.target)) {
                container.classList.remove('open');
            }
        });

        // ============================================
        // Remove Individual SVGs
        // ============================================

        function removeSVGItem(index) {
            if (index < 0 || index >= state.svgItems.length) return;

            // If this is the last SVG, clear everything
            if (state.svgItems.length === 1) {
                pushToHistory();
                clearAllSVGs();
                return;
            }

            pushToHistory();
            state.svgItems.splice(index, 1);
            renderPreview();
            updateSaveButton();
            updateSizeInfo();
            detectStrokeSVGs();
        }

        // ============================================
        // Copy SVG to Clipboard
        // ============================================

        function copySVGToClipboard() {
            if (!hasLoadedSVGs()) return;

            if (state.svgItems.length === 1) {
                performCopySVG(0);
            } else {
                showSVGSelectionModal('copy');
            }
        }

        function performCopySVG(index) {
            const item = state.svgItems[index];
            if (!item) return;

            // Generate final SVG through the same pipeline as save
            let finalSVG = generateFinalSVG(item);
            const serializer = new XMLSerializer();
            let svgString = serializer.serializeToString(finalSVG);

            // Apply FM processing if enabled
            if (state.fmCompatible) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');
                if (svg) {
                    processSVGForFileMaker(svg);
                    svgString = serializer.serializeToString(svg);
                }
            }

            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(svgString).then(() => {
                    showCopyFeedback();
                }).catch(() => {
                    fallbackCopy(svgString);
                });
            } else {
                fallbackCopy(svgString);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showCopyFeedback();
            } catch (e) {
                console.error('Copy failed:', e);
            }
            document.body.removeChild(textarea);
        }

        function showCopyFeedback() {
            // Show toast in the preview area
            showPreviewToast('Copied!');

            // Also update the Copy button if visible
            const btn = document.getElementById('copy-btn');
            const btnText = document.getElementById('copy-btn-text');
            if (btn && btnText) {
                const originalText = btnText.textContent;
                btnText.textContent = 'Copied!';
                btn.style.background = 'var(--success)';
                btn.style.borderColor = 'var(--success)';
                setTimeout(() => {
                    btnText.textContent = originalText;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                }, 1500);
            }
        }

        let toastTimeout = null;

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const icon = document.getElementById('toast-icon');
            const text = document.getElementById('toast-text');

            text.textContent = message;
            toast.className = 'toast ' + type;

            if (type === 'success') {
                icon.innerHTML = '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>';
                icon.style.color = 'var(--success)';
            }

            clearTimeout(toastTimeout);
            requestAnimationFrame(() => {
                toast.classList.add('visible');
            });

            toastTimeout = setTimeout(() => {
                toast.classList.remove('visible');
            }, 3000);
        }

        let previewToastTimer = null;

        function showPreviewToast(message) {
            const previewContainer = document.getElementById('drop-zone');
            if (!previewContainer) return;

            // Reuse existing toast or create new one
            let toast = previewContainer.querySelector('.preview-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.className = 'preview-toast';
                previewContainer.appendChild(toast);
            }

            toast.textContent = message;

            // Clear any pending hide
            if (previewToastTimer) clearTimeout(previewToastTimer);

            // Show
            requestAnimationFrame(() => {
                toast.classList.add('visible');
            });

            // Auto-hide after delay
            previewToastTimer = setTimeout(() => {
                toast.classList.remove('visible');
            }, 1200);
        }

        // ============================================
        // SVG Code View
        // ============================================

        function showCodeView() {
            if (!hasLoadedSVGs()) return;

            if (state.svgItems.length === 1) {
                performCodeView(0);
            } else {
                showSVGSelectionModal('codeview');
            }
        }

        function performCodeView(index) {
            const item = state.svgItems[index];
            if (!item) return;

            // Generate final SVG through same pipeline
            let finalSVG = generateFinalSVG(item);
            const serializer = new XMLSerializer();
            let svgString = serializer.serializeToString(finalSVG);

            // Apply FM processing if enabled
            if (state.fmCompatible) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');
                if (svg) {
                    processSVGForFileMaker(svg);
                    svgString = serializer.serializeToString(svg);
                }
            }

            // Pretty-print the XML
            const formatted = formatXML(svgString);

            // Show in modal
            const modal = document.getElementById('code-view-modal');
            const content = document.getElementById('code-view-content');
            const title = document.getElementById('code-view-title');

            title.textContent = item.filename + ' - SVG Code';
            content.textContent = formatted;

            modal.classList.add('visible');

            // Close on overlay click
            modal.addEventListener('click', handleCodeViewOverlayClick);
        }

        function hideCodeView() {
            const modal = document.getElementById('code-view-modal');
            modal.classList.remove('visible');
            modal.removeEventListener('click', handleCodeViewOverlayClick);
        }

        function handleCodeViewOverlayClick(e) {
            if (e.target.id === 'code-view-modal') {
                hideCodeView();
            }
        }

        function copyCodeViewContent() {
            const content = document.getElementById('code-view-content');
            if (!content) return;

            const text = content.textContent;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showCodeViewCopyFeedback();
                }).catch(() => {
                    fallbackCopy(text);
                    showCodeViewCopyFeedback();
                });
            } else {
                fallbackCopy(text);
                showCodeViewCopyFeedback();
            }
        }

        function showCodeViewCopyFeedback() {
            const btn = document.getElementById('code-view-copy-btn');
            if (!btn) return;
            const original = btn.innerHTML;
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><polyline points="20 6 9 17 4 12" /></svg> Copied!';
            btn.style.background = 'var(--success)';
            btn.style.borderColor = 'var(--success)';
            btn.style.color = 'white';
            setTimeout(() => {
                btn.innerHTML = original;
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.style.color = '';
            }, 1500);
        }

        /**
         * Simple XML pretty-printer
         */
        function formatXML(xml) {
            let formatted = '';
            let indent = '';
            const tab = '  ';

            // Normalize the XML first
            xml = xml.replace(/>\s*</g, '><');

            xml.split(/(<[^>]+>)/g).forEach(node => {
                if (!node.trim()) return;

                if (node.match(/^<\/\w/)) {
                    // Closing tag - decrease indent
                    indent = indent.substring(tab.length);
                    formatted += indent + node + '\n';
                } else if (node.match(/^<\w[^>]*[^\/]>$/)) {
                    // Opening tag - add then increase indent
                    formatted += indent + node + '\n';
                    indent += tab;
                } else {
                    // Self-closing tag or text
                    formatted += indent + node + '\n';
                }
            });

            return formatted.trim();
        }

        // ============================================
        // SVG Selection Modal (shared for Copy & Code View)
        // ============================================

        let svgSelectionAction = null;

        function showSVGSelectionModal(action) {
            svgSelectionAction = action;
            const modal = document.getElementById('svg-selection-modal');
            const title = document.getElementById('svg-selection-title');
            const message = document.getElementById('svg-selection-message');
            const list = document.getElementById('svg-selection-list');

            title.textContent = action === 'copy' ? 'Copy SVG' : 'View SVG Code';
            message.textContent = action === 'copy' ? 'Select an SVG to copy:' : 'Select an SVG to view:';

            // Build list
            list.innerHTML = '';
            state.svgItems.forEach((item, index) => {
                const li = document.createElement('li');
                const btn = document.createElement('button');
                btn.className = 'svg-selection-item';
                btn.innerHTML = `<span class="item-index">${index + 1}</span> ${escapeHTML(item.filename)}`;
                btn.addEventListener('click', () => {
                    hideSVGSelectionModal();
                    handleSVGSelection(index, action);
                });
                li.appendChild(btn);
                list.appendChild(li);
            });

            modal.classList.add('visible');

            // Close on overlay click
            modal.addEventListener('click', handleSelectionOverlayClick);
            document.addEventListener('keydown', handleSelectionEscape);
        }

        function hideSVGSelectionModal() {
            const modal = document.getElementById('svg-selection-modal');
            modal.classList.remove('visible');
            svgSelectionAction = null;
            modal.removeEventListener('click', handleSelectionOverlayClick);
            document.removeEventListener('keydown', handleSelectionEscape);
        }

        function handleSVGSelection(index, action) {
            if (action === 'copy') {
                performCopySVG(index);
            } else if (action === 'codeview') {
                performCodeView(index);
            }
        }

        function handleSelectionOverlayClick(e) {
            if (e.target.id === 'svg-selection-modal') {
                hideSVGSelectionModal();
            }
        }

        function handleSelectionEscape(e) {
            if (e.key === 'Escape') {
                hideSVGSelectionModal();
            }
        }

        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // ============================================
        // Drag to Reorder SVGs
        // ============================================

        let dragSourceIndex = null;

        function handleTileDragStart(e) {
            const tile = e.currentTarget;
            dragSourceIndex = parseInt(tile.dataset.index);
            tile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', dragSourceIndex.toString());
        }

        function handleTileDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            // Clean up all drag-over states
            document.querySelectorAll('.preview-tile.drag-over-tile').forEach(t => {
                t.classList.remove('drag-over-tile');
            });
            dragSourceIndex = null;
        }

        function handleTileDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const tile = e.currentTarget;
            const targetIndex = parseInt(tile.dataset.index);
            if (targetIndex !== dragSourceIndex) {
                tile.classList.add('drag-over-tile');
            }
        }

        function handleTileDragLeave(e) {
            e.currentTarget.classList.remove('drag-over-tile');
        }

        function handleTileDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            const tile = e.currentTarget;
            tile.classList.remove('drag-over-tile');

            const targetIndex = parseInt(tile.dataset.index);
            if (dragSourceIndex === null || dragSourceIndex === targetIndex) return;

            // Save state for undo
            pushToHistory();

            // Reorder the array
            const [moved] = state.svgItems.splice(dragSourceIndex, 1);
            state.svgItems.splice(targetIndex, 0, moved);

            // Re-render
            renderPreview();
        }

        // ============================================
        // Persistent Preferences (localStorage)
        // ============================================

        const PREFS_KEY = 'elemental-svg-editor-prefs';

        function savePreferences() {
            try {
                const prefs = {
                    theme: state.theme,
                    accentColor: state.accentColor,
                    fmCompatible: state.fmCompatible,
                    fmDynamicFill: state.fmDynamicFill,
                    previewBg: state.previewBg,
                    previewBgCustomColor: state.previewBgCustomColor,
                    autoConvert: state.autoConvert
                };
                localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
            } catch (e) {
                // localStorage may be unavailable (e.g., in some iframe contexts)
            }
        }

        function loadPreferences() {
            try {
                const stored = localStorage.getItem(PREFS_KEY);
                if (!stored) return null;
                return JSON.parse(stored);
            } catch (e) {
                return null;
            }
        }

        function toggleAutoConvert(enabled) {
            state.autoConvert = enabled;
            savePreferences();
        }

        // ============================================
        // Preview Filename Display
        // ============================================

        function updatePreviewFilename() {
            const el = document.getElementById('preview-filename');
            if (!el) return;

            if (state.svgItems.length === 1) {
                el.textContent = ' \u2014 ' + state.svgItems[0].filename;
                el.title = state.svgItems[0].filename;
            } else {
                el.textContent = '';
                el.title = '';
            }
        }

        // ============================================
        // Icon Browser (Integrated Mode)
        // ============================================

        const IB_PREFS_KEY = 'elemental-svg-icon-browser-prefs';
        const IB_MANIFEST_KEY = 'elemental-svg-icon-manifest';

        const ibState = {
            manifest: null,         // { icons: [...], categories: [...], libraries: [...] }
            filtered: [],           // filtered icon list (indices into manifest.icons)
            selected: new Set(),    // set of icon ids (e.g. "lucide/arrow-left")
            lastClickIdx: -1,       // for shift-click range select
            search: '',
            categories: {},         // { arrows: true, navigation: true, ... } multi-select
            libraries: {},          // { lucide: true, ... }
            types: {},              // { outline: true, filled: true, solid: true }
            sortAsc: true,
            zoom: 1.5,              // 0.5 to 3, default larger
            svgCache: new Map(),    // id -> svg string
            batchQueue: new Set(),  // ids awaiting fetch
            batchTimer: null,
            scrollRaf: false,
            exportFormat: 'svg',
            exportSize: 512,
            manifestLoading: false,
            initialized: false,
            prefetching: false,
        };

        // -- Mode Toggle --

        function ibSetMode(mode) {
            document.body.dataset.mode = mode;
            document.getElementById('ib-mode-editor').classList.toggle('active', mode === 'editor');
            document.getElementById('ib-mode-library').classList.toggle('active', mode === 'library');
            if (mode === 'library') {
                if (!ibState.manifest && !ibState.manifestLoading) {
                    ibLoadManifest();
                } else if (ibState.manifest) {
                    if (!ibState.initialized) ibInit();
                    else ibRecalculateGrid();
                }
                ibUpdateZoomDisplay();
                ibUpdateSizeInfo();
                ibUpdateSearchPlaceholder();
            } else {
                // Restore editor zoom display and size info
                updateZoomDisplay();
                updateSizeInfo();
            }
            updateControlsPanelVisibility();
            ibSavePrefs();
        }

        function ibIsLibraryMode() {
            return document.body.dataset.mode === 'library';
        }

        // -- Zoom button handler (shared +/- buttons) --

        function ibHandleZoomBtn(dir) {
            if (ibIsLibraryMode()) {
                ibZoom(dir);
            } else {
                adjustZoom(dir > 0 ? 0.25 : -0.25);
            }
        }

        function ibUpdateZoomDisplay() {
            const pct = Math.round(ibState.zoom * 100);
            document.getElementById('zoom-level').textContent = pct + '%';
        }

        // -- Preferences persistence --

        function ibSavePrefs() {
            try {
                localStorage.setItem(IB_PREFS_KEY, JSON.stringify({
                    mode: document.body.dataset.mode || 'editor',
                    search: ibState.search,
                    categories: ibState.categories,
                    libraries: ibState.libraries,
                    types: ibState.types,
                    sortAsc: ibState.sortAsc,
                    zoom: ibState.zoom,
                    exportFormat: ibState.exportFormat,
                    exportSize: ibState.exportSize,
                    exportFm: document.getElementById('ib-export-fm')?.checked ?? true,
                    exportDynamic: document.getElementById('ib-export-dynamic')?.checked ?? true,
                    categoryNarrowing: true,
                }));
            } catch (e) { }
        }

        function ibLoadPrefs() {
            try {
                const s = localStorage.getItem(IB_PREFS_KEY);
                return s ? JSON.parse(s) : null;
            } catch (e) { return null; }
        }

        // -- Export format/size controls --

        function ibSetExportFormat(fmt) {
            ibState.exportFormat = fmt;
            document.getElementById('ib-format-svg').classList.toggle('active', fmt === 'svg');
            document.getElementById('ib-format-png').classList.toggle('active', fmt === 'png');
            document.getElementById('ib-png-size-section').style.display = fmt === 'png' ? '' : 'none';
            // Update button label  respect FM mode
            const dlText = document.getElementById('ib-download-text');
            if (dlText) {
                const isFM = state.fileMakerMode;
                const count = ibState.selected.size;
                const suffix = count > 0 ? ` (${count})` : '';
                if (isFM) {
                    dlText.textContent = 'Save to FileMaker' + suffix;
                } else {
                    dlText.textContent = (fmt === 'png' ? 'Download PNG' : 'Download') + suffix;
                }
            }
            const dlIcon = document.getElementById('ib-download-icon');
            if (dlIcon) dlIcon.style.display = state.fileMakerMode ? '' : 'none';
            ibSavePrefs();
            ibUpdateStrokeToggle();
        }

        function ibSetExportSize(size) {
            ibState.exportSize = size;
            [32, 64, 128, 256, 512, 1024].forEach(s => {
                const btn = document.getElementById('ib-size-' + s);
                if (btn) btn.classList.toggle('active', s === size);
            });
            ibSavePrefs();
        }

        // -- Stroke detection for icon library --

        function ibUpdateStrokeToggle() {
            const section = document.getElementById('ib-stroke-convert-section');
            if (!section) return;
            // Only show for SVG format when stroke icons are detected in selection
            let hasStrokes = false;
            if (ibState.exportFormat === 'svg' && ibState.selected.size > 0) {
                for (const id of ibState.selected) {
                    const svg = ibState.svgCache.get(id);
                    if (!svg) continue;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svg, 'image/svg+xml');
                    const svgEl = doc.querySelector('svg');
                    if (svgEl && isStrokeBasedSVG(svgEl)) {
                        hasStrokes = true;
                        break;
                    }
                }
            }
            section.style.display = hasStrokes ? 'block' : 'none';
        }

        // -- Manifest loading --

        async function ibLoadManifest() {
            ibState.manifestLoading = true;
            document.getElementById('ib-loading').style.display = '';
            document.getElementById('ib-scroll-container').style.display = 'none';
            document.getElementById('ib-empty').style.display = 'none';

            // Try localStorage cache, but always check for newer version
            let cachedData = null;
            try {
                const cached = localStorage.getItem(IB_MANIFEST_KEY);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (parsed.ts && (Date.now() - parsed.ts) < 86400000) {
                        cachedData = parsed.data;
                    }
                }
            } catch (e) { }

            try {
                const resp = await fetch(_proxyBase + '/icons/manifest');
                if (!resp.ok) throw new Error('Manifest fetch failed');
                const data = await resp.json();
                ibState.manifest = data;
                try {
                    localStorage.setItem(IB_MANIFEST_KEY, JSON.stringify({ ts: Date.now(), data }));
                } catch (e) { }
                // Clear icon cache if manifest version changed
                if (cachedData && cachedData.version !== data.version) {
                    ibState.svgCache.clear();
                    try { const req = indexedDB.open('elemental-icons', 1); req.onsuccess = (e) => { try { e.target.result.transaction('svgs', 'readwrite').objectStore('svgs').clear(); } catch (ex) { } }; } catch (ex) { }
                }
            } catch (e) {
                // Fall back to cached manifest if available
                if (cachedData) {
                    ibState.manifest = cachedData;
                } else {
                    document.getElementById('ib-loading').innerHTML =
                        '<div style="color:var(--text-secondary);font-size:13px;">Failed to load icon library.<br><button class="btn btn-secondary" style="margin-top:12px;" onclick="ibLoadManifest()">Retry</button></div>';
                    ibState.manifestLoading = false;
                    return;
                }
            }
            ibState.manifestLoading = false;
            ibInit();
        }

        // -- Initialization (after manifest loaded) --

        async function ibInit() {
            if (!ibState.manifest) return;
            ibState.initialized = true;

            // Load cached SVGs from IndexedDB (instant on return visits)
            await ibLoadCacheFromDB();

            const prefs = ibLoadPrefs();
            const m = ibState.manifest;

            // Build library map from manifest (libraries are objects with id, name, iconCount)
            const libs = {};
            (m.libraries || []).forEach(lib => {
                const id = typeof lib === 'object' ? lib.id : lib;
                libs[id] = true;
            });

            // Build categories map  all false by default (unchecked = show all; checking narrows)
            const cats = {};
            (m.categories || []).forEach(cat => {
                const id = typeof cat === 'object' ? cat.id : cat;
                cats[id] = false;
            });

            // Build types map from manifest icons  all false by default (narrowing: check to filter)
            const types = {};
            m.icons.forEach(ic => { if (ic.type) types[ic.type] = false; });

            // Override with saved prefs if they exist
            if (prefs) {
                if (prefs.libraries) {
                    Object.keys(libs).forEach(k => {
                        libs[k] = prefs.libraries[k] !== undefined ? prefs.libraries[k] : true;
                    });
                }
                // Only restore category prefs from v2 (narrowing) format
                // Old prefs had categories=true by default, which breaks narrowing logic
                if (prefs.categories && prefs.categoryNarrowing) {
                    Object.keys(cats).forEach(k => {
                        cats[k] = prefs.categories[k] !== undefined ? prefs.categories[k] : false;
                    });
                }
                if (prefs.types) {
                    Object.keys(types).forEach(k => {
                        types[k] = prefs.types[k] !== undefined ? prefs.types[k] : false;
                    });
                }
                ibState.search = prefs.search || '';
                ibState.sortAsc = prefs.sortAsc !== false;
                ibState.zoom = prefs.zoom || 1.5;
                ibState.exportFormat = prefs.exportFormat || 'svg';
                ibState.exportSize = prefs.exportSize || 512;
            }

            ibState.libraries = libs;
            ibState.categories = cats;
            ibState.types = types;

            // Restore search input
            document.getElementById('ib-search').value = ibState.search;

            // Restore export settings
            ibSetExportFormat(ibState.exportFormat);
            ibSetExportSize(ibState.exportSize);
            if (prefs) {
                const fm = document.getElementById('ib-export-fm');
                if (fm && prefs.exportFm !== undefined) fm.checked = prefs.exportFm;
                const dyn = document.getElementById('ib-export-dynamic');
                if (dyn && prefs.exportDynamic !== undefined) dyn.checked = prefs.exportDynamic;
            }

            // Build sidebar filters
            ibBuildSidebar();

            // Apply filters & render
            ibApplyFilters();
            ibUpdateSortBtn();

            // Set up scroll handler
            const sc = document.getElementById('ib-scroll-container');
            sc.addEventListener('scroll', ibOnScroll, { passive: true });

            // Set up search debounce
            const searchInput = document.getElementById('ib-search');
            let searchTimer = null;
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimer);
                searchTimer = setTimeout(() => {
                    ibState.search = searchInput.value.trim().toLowerCase();
                    ibApplyFilters();
                    ibSavePrefs();
                }, 150);
            });
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    ibState.search = '';
                    ibApplyFilters();
                    ibSavePrefs();
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Set up resize handler
            window.addEventListener('resize', ibOnResize);

            // Set up keyboard handler
            document.addEventListener('keydown', ibHandleKeydown);

            // Set up tile click delegation + rubber-band
            ibSetupInteraction();

            // Set up mousewheel zoom for library mode
            ibSetupWheelZoom();

            // Hide loading, show grid
            document.getElementById('ib-loading').style.display = 'none';

            // Update zoom display for library mode
            if (ibIsLibraryMode()) ibUpdateZoomDisplay();

            // Fetch all remaining icons in background (cached in IndexedDB for future visits)
            ibFetchAllIcons();
        }

        // -- Sidebar Filters --

        function ibBuildSidebar() {
            const m = ibState.manifest;
            const container = document.getElementById('ib-filter-content');
            let html = '';

            // Library section
            if (m.libraries && m.libraries.length > 0) {
                html += '<div style="margin-bottom:12px;"><div style="font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-secondary);margin-bottom:6px;">Icon Set</div>';
                m.libraries.forEach(lib => {
                    const id = typeof lib === 'object' ? lib.id : lib;
                    const name = typeof lib === 'object' ? lib.name : lib;
                    const count = typeof lib === 'object' ? lib.iconCount : m.icons.filter(ic => ic.library === id).length;
                    const checked = ibState.libraries[id] !== false ? 'checked' : '';
                    html += `<label class="ib-sidebar-item"><input type="checkbox" data-lib="${id}" ${checked}><span>${name}</span><span class="ib-sidebar-count" data-lib-count="${id}" data-lib-total="${count}">${count.toLocaleString()}</span></label>`;
                });
                html += '</div>';
            }

            // Type section (outline/filled/solid)
            const typeNames = { outline: 'Outline', filled: 'Filled', solid: 'Solid', bold: 'Bold' };
            const typeEntries = Object.keys(ibState.types);
            if (typeEntries.length > 1) {
                html += '<div style="margin-bottom:12px;"><div style="font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-secondary);margin-bottom:6px;">Style</div>';
                typeEntries.forEach(t => {
                    const count = m.icons.filter(ic => ic.type === t).length;
                    const checked = ibState.types[t] ? 'checked' : '';
                    html += `<label class="ib-sidebar-item"><input type="checkbox" data-type="${t}" ${checked}><span>${typeNames[t] || t}</span><span class="ib-sidebar-count" data-type-count="${t}">${count.toLocaleString()}</span></label>`;
                });
                html += '</div>';
            }

            // Category section (checkboxes, multi-select, sorted alphabetically)
            const categories = [...(m.categories || [])].sort((a, b) => {
                const la = (typeof a === 'object' ? a.label : a).toLowerCase();
                const lb = (typeof b === 'object' ? b.label : b).toLowerCase();
                return la.localeCompare(lb);
            });
            if (categories.length > 0) {
                html += '<div><div style="font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-secondary);margin-bottom:6px;">Categories</div>';
                categories.forEach(cat => {
                    const id = typeof cat === 'object' ? cat.id : cat;
                    const label = typeof cat === 'object' ? cat.label : cat;
                    const count = typeof cat === 'object' ? cat.count : m.icons.filter(ic => ic.category === id).length;
                    const checked = ibState.categories[id] !== false ? 'checked' : '';
                    html += `<label class="ib-sidebar-item"><input type="checkbox" data-cat="${id}" ${checked}><span>${label}</span><span class="ib-sidebar-count" data-cat-count="${id}">${count.toLocaleString()}</span></label>`;
                });
                html += '</div>';
            }

            container.innerHTML = html;

            // Event listeners
            container.querySelectorAll('input[data-lib]').forEach(cb => {
                cb.addEventListener('change', () => {
                    ibState.libraries[cb.dataset.lib] = cb.checked;
                    ibApplyFilters();
                    ibSavePrefs();
                });
            });
            container.querySelectorAll('input[data-type]').forEach(cb => {
                cb.addEventListener('change', () => {
                    ibState.types[cb.dataset.type] = cb.checked;
                    ibApplyFilters();
                    ibSavePrefs();
                });
            });
            container.querySelectorAll('input[data-cat]').forEach(cb => {
                cb.addEventListener('change', () => {
                    ibState.categories[cb.dataset.cat] = cb.checked;
                    ibApplyFilters();
                    ibSavePrefs();
                });
            });
        }

        // Update style/category counts based on all active filters (cross-filter faceted counts)
        function ibUpdateSidebarCounts() {
            const m = ibState.manifest;
            if (!m) return;
            const search = ibState.search;
            const anyCatSelected = Object.values(ibState.categories).some(v => v);
            const anyTypeSelected = Object.values(ibState.types).some(v => v);
            const typeCounts = {};
            const catCounts = {};
            const libCounts = {};
            for (let i = 0; i < m.icons.length; i++) {
                const ic = m.icons[i];
                if (search) {
                    const name = ic.name.toLowerCase();
                    const tags = (ic.tags || []).join(' ').toLowerCase();
                    if (!name.includes(search) && !tags.includes(search)) continue;
                }
                // Library counts always reflect search matches, regardless of library checkbox
                libCounts[ic.library] = (libCounts[ic.library] || 0) + 1;
                // Type/category counts respect the library filter
                if (ibState.libraries[ic.library] === false) continue;
                if (!anyCatSelected || ibState.categories[ic.category]) {
                    typeCounts[ic.type] = (typeCounts[ic.type] || 0) + 1;
                }
                if (!anyTypeSelected || ibState.types[ic.type]) {
                    catCounts[ic.category] = (catCounts[ic.category] || 0) + 1;
                }
            }
            document.querySelectorAll('[data-type-count]').forEach(el => {
                el.textContent = (typeCounts[el.dataset.typeCount] || 0).toLocaleString();
            });
            document.querySelectorAll('[data-cat-count]').forEach(el => {
                el.textContent = (catCounts[el.dataset.catCount] || 0).toLocaleString();
            });
            // Library counts: show filtered count when searching, original total otherwise
            document.querySelectorAll('[data-lib-count]').forEach(el => {
                if (search) {
                    el.textContent = (libCounts[el.dataset.libCount] || 0).toLocaleString();
                } else {
                    el.textContent = parseInt(el.dataset.libTotal).toLocaleString();
                }
            });
        }

        // -- Filtering & Sorting --

        function ibApplyFilters() {
            const m = ibState.manifest;
            if (!m) return;
            // Clear selection when filters/search change  hidden icons shouldn't stay selected
            if (ibState.selected.size > 0) {
                ibState.selected.clear();
                ibState.lastClickIdx = -1;
                ibUpdateSelectionCount();
            }
            const search = ibState.search;
            // Narrowing: if any checked, filter to only those; if none checked, show all
            const anyCatSelected = Object.values(ibState.categories).some(v => v);
            const anyTypeSelected = Object.values(ibState.types).some(v => v);

            let result = [];
            for (let i = 0; i < m.icons.length; i++) {
                const ic = m.icons[i];
                // Library filter (checked = show, unchecked = hide)
                if (ibState.libraries[ic.library] === false) continue;
                // Type filter (narrowing: only filter when types are checked)
                if (anyTypeSelected && !ibState.types[ic.type]) continue;
                // Category filter (narrowing: only filter when categories are checked)
                if (anyCatSelected && !ibState.categories[ic.category]) continue;
                // Search filter
                if (search) {
                    const name = ic.name.toLowerCase();
                    const tags = (ic.tags || []).join(' ').toLowerCase();
                    if (!name.includes(search) && !tags.includes(search)) continue;
                }
                result.push(i);
            }

            // Sort
            result.sort((a, b) => {
                const na = m.icons[a].name.toLowerCase();
                const nb = m.icons[b].name.toLowerCase();
                return ibState.sortAsc ? na.localeCompare(nb) : nb.localeCompare(na);
            });

            ibState.filtered = result;
            ibState.lastClickIdx = -1;

            ibUpdateSidebarCounts();
            ibRecalculateGrid();
        }

        function ibToggleSort() {
            ibState.sortAsc = !ibState.sortAsc;
            ibUpdateSortBtn();
            ibApplyFilters();
            ibSavePrefs();
        }

        function ibUpdateSortBtn() {
            const btn = document.getElementById('ib-sort-btn');
            if (btn) {
                btn.innerHTML = ibState.sortAsc
                    ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><path d="M11 5h10"/><path d="M11 9h7"/><path d="M11 13h4"/><path d="M3 17l3 3 3-3"/><path d="M6 18V4"/></svg>'
                    : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><path d="M11 5h4"/><path d="M11 9h7"/><path d="M11 13h10"/><path d="M3 17l3 3 3-3"/><path d="M6 18V4"/></svg>';
            }
        }

        // -- Virtual Scroll Grid --

        let ibGridCols = 0;
        let ibTileH = 0;
        let ibTileW = 0;
        let ibVisibleStart = 0;
        let ibVisibleEnd = 0;

        function ibGetTileSize() {
            const base = 88;
            return Math.round(base * ibState.zoom);
        }

        function ibGetIconSize() {
            return Math.round(32 * ibState.zoom);
        }

        function ibRecalculateGrid() {
            const sc = document.getElementById('ib-scroll-container');
            const emptyEl = document.getElementById('ib-empty');
            const count = ibState.filtered.length;

            if (count === 0) {
                sc.style.display = 'none';
                emptyEl.style.display = '';
                ibUpdateSelectionCount();
                return;
            }

            emptyEl.style.display = 'none';
            sc.style.display = '';

            const tileSize = ibGetTileSize();
            const iconSize = ibGetIconSize();
            const gap = 4;
            const padX = 16;
            const padY = 8;
            const areaW = sc.clientWidth - padX * 2;
            ibGridCols = Math.max(1, Math.floor((areaW + gap) / (tileSize + gap)));
            ibTileW = tileSize;
            ibTileH = iconSize + 38; // icon height + name(~18px) + padding(16px) + border(4px)
            const rows = Math.ceil(count / ibGridCols);
            const rowH = ibTileH + gap;
            const totalH = rows * rowH - gap + padY * 2;

            // Set CSS custom props
            const tw = document.getElementById('ib-tile-window');
            tw.style.setProperty('--ib-tile-size', tileSize + 'px');
            tw.style.setProperty('--ib-icon-size', iconSize + 'px');
            tw.style.setProperty('--ib-grid-cols', ibGridCols);

            // Spacer for scrollbar height
            document.getElementById('ib-scroll-spacer').style.height = totalH + 'px';

            ibRenderVisibleTiles();
            ibUpdateSelectionCount();
        }

        function ibRenderVisibleTiles() {
            const sc = document.getElementById('ib-scroll-container');
            const tw = document.getElementById('ib-tile-window');
            const count = ibState.filtered.length;
            if (count === 0) return;

            const gap = 4;
            const padY = 8;
            const scrollTop = sc.scrollTop;
            const viewH = sc.clientHeight;
            const rowH = ibTileH + gap;

            const startRow = Math.max(0, Math.floor((scrollTop - padY) / rowH) - 3);
            const endRow = Math.min(Math.ceil(count / ibGridCols), Math.ceil((scrollTop + viewH - padY) / rowH) + 3);

            const startIdx = startRow * ibGridCols;
            const endIdx = Math.min(count, endRow * ibGridCols);

            ibVisibleStart = startIdx;
            ibVisibleEnd = endIdx;

            // Position tile window
            const offsetY = padY + startRow * rowH;
            tw.style.transform = `translateY(${offsetY}px)`;

            // Build tiles
            const m = ibState.manifest;
            const frag = document.createDocumentFragment();
            const batchIds = [];

            for (let i = startIdx; i < endIdx; i++) {
                const iconIdx = ibState.filtered[i];
                const ic = m.icons[iconIdx];
                const id = ic.id;

                const tile = document.createElement('div');
                tile.className = 'ib-tile' + (ibState.selected.has(id) ? ' ib-selected' : '');
                tile.dataset.idx = i;
                tile.dataset.id = id;

                const iconDiv = document.createElement('div');
                iconDiv.className = 'ib-tile-icon';

                if (ibState.svgCache.has(id)) {
                    iconDiv.innerHTML = ibState.svgCache.get(id);
                } else {
                    iconDiv.innerHTML = '<div class="ib-tile-placeholder"></div>';
                    batchIds.push(id);
                }

                const nameDiv = document.createElement('div');
                nameDiv.className = 'ib-tile-name';
                nameDiv.textContent = ic.name;
                nameDiv.title = ic.name;

                tile.appendChild(iconDiv);
                tile.appendChild(nameDiv);
                frag.appendChild(tile);
            }

            tw.innerHTML = '';
            tw.appendChild(frag);

            // Queue batch fetch for any uncached visible tiles
            if (batchIds.length > 0) {
                batchIds.forEach(id => ibState.batchQueue.add(id));
                ibScheduleBatchFetch();
            }
        }

        function ibOnScroll() {
            if (!ibState.scrollRaf) {
                ibState.scrollRaf = true;
                requestAnimationFrame(() => {
                    ibState.scrollRaf = false;
                    ibRenderVisibleTiles();
                });
            }
        }

        function ibOnResize() {
            if (ibIsLibraryMode() && ibState.manifest) {
                ibRecalculateGrid();
                // Re-render after layout settles to fill any new viewport space
                requestAnimationFrame(() => ibRenderVisibleTiles());
            }
        }

        // -- Zoom --

        function ibSetupWheelZoom() {
            const zoomLevel = document.getElementById('zoom-level');
            const sc = document.getElementById('ib-scroll-container');

            function handleLibraryWheel(e) {
                if (!ibIsLibraryMode()) return;
                e.preventDefault();
                ibZoom(e.deltaY < 0 ? 1 : -1);
            }

            // Wheel on zoom % text always zooms in library mode
            if (zoomLevel) {
                zoomLevel.addEventListener('wheel', handleLibraryWheel, { passive: false });
            }

            // Wheel on scroll container zooms only with Cmd/Ctrl held
            if (sc) {
                sc.addEventListener('wheel', function (e) {
                    if (!ibIsLibraryMode()) return;
                    if (!(e.metaKey || e.ctrlKey)) return;
                    e.preventDefault();
                    ibZoom(e.deltaY < 0 ? 1 : -1);
                }, { passive: false });
            }
        }

        function ibZoom(dir) {
            const steps = [0.5, 0.75, 1, 1.25, 1.5, 2, 2.5, 3];
            let idx = steps.indexOf(ibState.zoom);
            if (idx === -1) {
                // Find nearest
                idx = steps.findIndex(s => s >= ibState.zoom);
                if (idx === -1) idx = steps.length - 1;
            }
            idx += dir;
            if (idx < 0 || idx >= steps.length) return;
            ibState.zoom = steps[idx];
            ibRecalculateGrid();
            ibUpdateZoomDisplay();
            ibSavePrefs();
        }

        // -- SVG Loading (IndexedDB cache + fetch all) --

        const IB_DB_NAME = 'elemental-svg-icons';
        const IB_DB_VERSION = 1;
        const IB_STORE_NAME = 'svgs';

        function ibOpenDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(IB_DB_NAME, IB_DB_VERSION);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains(IB_STORE_NAME)) {
                        db.createObjectStore(IB_STORE_NAME);
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function ibLoadCacheFromDB() {
            try {
                const db = await ibOpenDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(IB_STORE_NAME, 'readonly');
                    const store = tx.objectStore(IB_STORE_NAME);
                    const req = store.getAll();
                    const keyReq = store.getAllKeys();
                    let keys, values;
                    keyReq.onsuccess = () => { keys = keyReq.result; };
                    req.onsuccess = () => { values = req.result; };
                    tx.oncomplete = () => {
                        if (keys && values) {
                            for (let i = 0; i < keys.length; i++) {
                                ibState.svgCache.set(keys[i], values[i]);
                            }
                        }
                        resolve(ibState.svgCache.size);
                    };
                    tx.onerror = () => resolve(0);
                });
            } catch (e) { return 0; }
        }

        async function ibSaveToDB(icons) {
            try {
                const db = await ibOpenDB();
                const tx = db.transaction(IB_STORE_NAME, 'readwrite');
                const store = tx.objectStore(IB_STORE_NAME);
                Object.entries(icons).forEach(([id, svg]) => {
                    store.put(svg, id);
                });
            } catch (e) { }
        }

        // Fetch all icons for the current manifest, in batches of 500
        async function ibFetchAllIcons() {
            if (!ibState.manifest || ibState.prefetching) return;
            ibState.prefetching = true;

            const m = ibState.manifest;
            const allIds = m.icons.map(ic => ic.id).filter(id => !ibState.svgCache.has(id));

            if (allIds.length === 0) {
                ibState.prefetching = false;
                return;
            }

            for (let i = 0; i < allIds.length; i += 500) {
                const batch = allIds.slice(i, i + 500);
                try {
                    const resp = await fetch(_proxyBase + '/icons/batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ids: batch })
                    });
                    if (resp.ok) {
                        const data = await resp.json();
                        if (data.icons) {
                            Object.entries(data.icons).forEach(([id, svg]) => {
                                ibState.svgCache.set(id, svg);
                                ibInjectSVG(id, svg);
                            });
                            ibSaveToDB(data.icons);
                        }
                    }
                } catch (e) { }
            }

            ibState.prefetching = false;
        }

        function ibScheduleBatchFetch() {
            clearTimeout(ibState.batchTimer);
            ibState.batchTimer = setTimeout(ibFlushBatchQueue, 16);
        }

        async function ibFlushBatchQueue() {
            if (ibState.batchQueue.size === 0) return;
            const ids = [...ibState.batchQueue].slice(0, 500);
            ibState.batchQueue.clear();

            try {
                const resp = await fetch(_proxyBase + '/icons/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ids })
                });
                if (!resp.ok) return;
                const data = await resp.json();
                if (data.icons) {
                    Object.entries(data.icons).forEach(([id, svg]) => {
                        ibState.svgCache.set(id, svg);
                        ibInjectSVG(id, svg);
                    });
                    ibSaveToDB(data.icons);
                }
            } catch (e) { }

            if (ibState.batchQueue.size > 0) ibScheduleBatchFetch();
        }

        function ibInjectSVG(id, svg) {
            const tw = document.getElementById('ib-tile-window');
            if (!tw) return;
            const tile = tw.querySelector(`[data-id="${CSS.escape(id)}"] .ib-tile-icon`);
            if (tile) tile.innerHTML = svg;
        }

        // -- Selection --

        function ibSetupInteraction() {
            const tw = document.getElementById('ib-tile-window');
            const sc = document.getElementById('ib-scroll-container');
            const DRAG_THRESHOLD = 5;

            // Unified pointer tracking  handles both tile clicks and drag-to-select
            let rbActive = false;
            let rbPending = false;
            let rbStartX = 0, rbStartY = 0;
            let rbStartScroll = 0;
            let rbPointerId = null;
            let rbStartTile = null;  // tile element if drag started on a tile
            let rbDragged = false;   // true once movement exceeds threshold

            sc.addEventListener('pointerdown', (e) => {
                if (e.button !== 0) return;

                rbPending = true;
                rbActive = false;
                rbDragged = false;
                rbStartX = e.clientX;
                rbStartY = e.clientY;
                rbStartScroll = sc.scrollTop;
                rbPointerId = e.pointerId;
                rbStartTile = e.target.closest('.ib-tile');
            });

            sc.addEventListener('pointermove', (e) => {
                if (!rbPending && !rbActive) return;

                if (rbPending && !rbActive) {
                    // Check if this is a scrollbar drag (scrollTop changed)
                    if (sc.scrollTop !== rbStartScroll) {
                        rbPending = false;
                        return;
                    }
                    const dx = Math.abs(e.clientX - rbStartX);
                    const dy = Math.abs(e.clientY - rbStartY);
                    if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) return;

                    // Movement exceeds threshold  start rubber-band drag-select
                    rbDragged = true;
                    rbActive = true;
                    rbPending = false;
                    try { sc.setPointerCapture(rbPointerId); } catch (err) { }
                }

                if (!rbActive) return;

                const scrollDelta = sc.scrollTop - rbStartScroll;
                const adjustedStartY = rbStartY - scrollDelta;

                const rb = document.getElementById('ib-rubber-band');
                rb.style.display = 'block';
                const x = Math.min(rbStartX, e.clientX);
                const y = Math.min(adjustedStartY, e.clientY);
                rb.style.left = x + 'px';
                rb.style.top = y + 'px';
                rb.style.width = (Math.abs(e.clientX - rbStartX)) + 'px';
                rb.style.height = (Math.abs(e.clientY - adjustedStartY)) + 'px';
            });

            const finishRubberBand = (e) => {
                const wasPending = rbPending;
                const wasDragged = rbDragged;
                const startTile = rbStartTile;
                rbPending = false;
                rbStartTile = null;

                if (!rbActive) {
                    // No drag happened  treat as a click if it was on a tile
                    if (wasPending && !wasDragged && startTile) {
                        handleTileClick(startTile, e);
                    }
                    return;
                }
                rbActive = false;
                rbDragged = false;
                const rb = document.getElementById('ib-rubber-band');
                const wasVisible = rb.style.display === 'block';
                rb.style.display = 'none';

                if (!wasVisible) return;

                // Convert rubber-band from viewport coords to scroll-content coords
                const scRect = sc.getBoundingClientRect();
                const scrollDelta = sc.scrollTop - rbStartScroll;
                const adjustedStartY = rbStartY - scrollDelta;

                const gap = 4, padX = 16, padY = 8;
                const rowH = ibTileH + gap;
                const colW = ibTileW + gap;

                // Rubber-band in scroll-content space
                const selLeft = Math.min(rbStartX, e.clientX) - scRect.left - padX + sc.scrollLeft;
                const selRight = Math.max(rbStartX, e.clientX) - scRect.left - padX + sc.scrollLeft;
                // For Y: use the original start position adjusted for scroll
                const startYContent = (rbStartY - scRect.top) + rbStartScroll - padY;
                const endYContent = (e.clientY - scRect.top) + sc.scrollTop - padY;
                const selTop = Math.min(startYContent, endYContent);
                const selBottom = Math.max(startYContent, endYContent);

                // Calculate row/col ranges that overlap the rubber-band
                const startCol = Math.max(0, Math.floor(selLeft / colW));
                const endCol = Math.min(ibGridCols - 1, Math.floor(selRight / colW));
                const startRow = Math.max(0, Math.floor(selTop / rowH));
                const endRow = Math.floor(selBottom / rowH);

                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const modKey = isMac ? e.metaKey : e.ctrlKey;
                if (!modKey) ibState.selected.clear();

                const m = ibState.manifest;
                const count = ibState.filtered.length;
                for (let row = startRow; row <= endRow; row++) {
                    for (let col = startCol; col <= endCol; col++) {
                        const i = row * ibGridCols + col;
                        if (i >= count) break;
                        // Check tile bounds precisely against selection rect
                        const tileLeft = col * colW;
                        const tileRight = tileLeft + ibTileW;
                        const tileTop = row * rowH;
                        const tileBottom = tileTop + ibTileH;
                        if (tileRight > selLeft && tileLeft < selRight &&
                            tileBottom > selTop && tileTop < selBottom) {
                            ibState.selected.add(m.icons[ibState.filtered[i]].id);
                        }
                    }
                }

                ibUpdateSelectionUI();
            };

            sc.addEventListener('pointerup', finishRubberBand);
            sc.addEventListener('pointercancel', finishRubberBand);

            // Prevent default click on tiles  selection is handled via pointerup above
            tw.addEventListener('click', (e) => {
                // Only suppress if it's on a tile (drag-select handles tile interaction now)
                if (e.target.closest('.ib-tile')) e.stopPropagation();
            });

            // Handle tile click (called from finishRubberBand when no drag occurred)
            function handleTileClick(tile, e) {
                const id = tile.dataset.id;
                const idx = parseInt(tile.dataset.idx, 10);
                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const modKey = isMac ? e.metaKey : e.ctrlKey;

                if (e.shiftKey && ibState.lastClickIdx >= 0) {
                    const start = Math.min(ibState.lastClickIdx, idx);
                    const end = Math.max(ibState.lastClickIdx, idx);
                    if (!modKey) ibState.selected.clear();
                    for (let i = start; i <= end; i++) {
                        const ic = ibState.manifest.icons[ibState.filtered[i]];
                        ibState.selected.add(ic.id);
                    }
                } else if (modKey) {
                    if (ibState.selected.has(id)) ibState.selected.delete(id);
                    else ibState.selected.add(id);
                } else {
                    ibState.selected.clear();
                    ibState.selected.add(id);
                }

                ibState.lastClickIdx = idx;
                ibUpdateSelectionUI();
            }
        }

        function ibSelectAllVisible() {
            const m = ibState.manifest;
            ibState.filtered.forEach(i => ibState.selected.add(m.icons[i].id));
            ibUpdateSelectionUI();
        }

        function ibSelectNone() {
            ibState.selected.clear();
            ibUpdateSelectionUI();
        }

        function ibUpdateSelectionUI() {
            const tw = document.getElementById('ib-tile-window');
            tw.querySelectorAll('.ib-tile').forEach(tile => {
                tile.classList.toggle('ib-selected', ibState.selected.has(tile.dataset.id));
            });
            ibUpdateSelectionCount();
        }

        function ibUpdateSelectionCount() {
            const count = ibState.selected.size;
            const el = document.getElementById('ib-selection-count');
            if (el) el.textContent = count + ' selected';
            // Update download button text and disabled state
            const dlBtn = document.getElementById('ib-download-btn');
            const dlText = document.getElementById('ib-download-text');
            if (dlBtn) dlBtn.disabled = count === 0;
            if (dlText) {
                const isFM = state.fileMakerMode;
                const fmt = ibState.exportFormat === 'png' ? 'PNG' : '';
                const baseLabel = isFM ? 'Save to FileMaker' : `Download${fmt ? ' ' + fmt : ''}`;
                dlText.textContent = count > 0 ? `${baseLabel} (${count})` : baseLabel;
            }
            // Show/hide Claris icon on download button (FM mode only)
            const dlIcon = document.getElementById('ib-download-icon');
            if (dlIcon) dlIcon.style.display = state.fileMakerMode ? '' : 'none';
            // Show/hide Button Bar button (FM mode only)
            const bbBtn = document.getElementById('ib-buttonbar-btn');
            if (bbBtn) {
                bbBtn.style.display = (state.fileMakerMode && count > 0) ? '' : 'none';
                const bbText = document.getElementById('ib-buttonbar-text');
                if (bbText) bbText.textContent = count > 0 ? `Copy as Button Bar (${count})` : 'Copy as Button Bar';
            }
            // Show/hide Edit Selected button + update label
            const editBtn = document.getElementById('ib-edit-btn');
            if (editBtn) {
                editBtn.style.display = count > 0 ? '' : 'none';
                const editLabelEl = document.getElementById('ib-edit-btn-label');
                if (editLabelEl) editLabelEl.textContent = hasLoadedSVGs() ? 'Add to Editor' : 'Open in Editor\u2026';
            }
            const editSep = document.getElementById('ib-edit-separator');
            if (editSep) editSep.style.display = count > 0 ? '' : 'none';
            // Update Select All/None toggle label
            const toggleBtn = document.getElementById('ib-select-toggle');
            if (toggleBtn) {
                const anySelected = ibState.selected.size > 0;
                toggleBtn.textContent = anySelected ? 'Select None' : 'Select All';
                toggleBtn.title = anySelected ? 'Deselect all' : 'Select all';
            }
            // Update library size info bar
            if (ibIsLibraryMode()) ibUpdateSizeInfo();
            ibUpdateSearchPlaceholder();
            ibUpdateStrokeToggle();
        }

        function ibToggleSelectAll() {
            const m = ibState.manifest;
            if (!m) return;
            if (ibState.selected.size > 0) {
                ibSelectNone();
            } else {
                ibSelectAllVisible();
            }
        }

        function ibResetZoom() {
            ibState.zoom = 1.5;
            ibRecalculateGrid();
            ibUpdateZoomDisplay();
            ibSavePrefs();
        }

        function ibUpdateSizeInfo() {
            const dimEl = document.getElementById('svg-dimensions');
            const sizeEl = document.getElementById('svg-size');
            if (!dimEl || !sizeEl) return;
            if (!ibState.manifest) {
                dimEl.style.display = 'none';
                sizeEl.style.display = 'none';
                return;
            }
            // Bottom-left: only show selection count, hide when nothing selected
            const selected = ibState.selected.size;
            dimEl.style.display = 'none';
            sizeEl.style.display = selected > 0 ? '' : 'none';
            sizeEl.textContent = selected > 0 ? `${selected.toLocaleString()} selected` : '';
        }

        function ibUpdateSearchPlaceholder() {
            const searchInput = document.getElementById('ib-search');
            if (!searchInput || !ibState.manifest) return;
            const count = ibState.filtered.length;
            searchInput.placeholder = `Search ${count.toLocaleString()} icons\u2026`;
            // Show found count to the right of the search box when searching
            const countEl = document.getElementById('ib-search-count');
            if (countEl) {
                if (ibState.search) {
                    countEl.textContent = `${count.toLocaleString()} found`;
                    countEl.style.display = '';
                } else {
                    countEl.style.display = 'none';
                }
            }
        }

        function ibUpdateEditorBadge() {
            const badge = document.getElementById('ib-editor-badge');
            if (!badge) return;
            const count = state.svgItems.length;
            badge.style.display = count > 0 ? '' : 'none';
            badge.textContent = count;
        }

        // -- Keyboard shortcuts --

        function ibHandleKeydown(e) {
            if (!ibIsLibraryMode()) return;

            // Let search input handle its own keys (Escape handled by search's own keydown)
            if (document.activeElement === document.getElementById('ib-search')) {
                return;
            }

            if (e.key === 'Escape') {
                if (ibState.selected.size > 0) {
                    ibSelectNone();
                    e.preventDefault();
                }
                return;
            }

            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const modKey = isMac ? e.metaKey : e.ctrlKey;

            if (modKey && e.key === 'a') {
                e.preventDefault();
                ibSelectAllVisible();
                return;
            }

            if (e.key === '/' || (e.key === 'f' && modKey)) {
                e.preventDefault();
                document.getElementById('ib-search').focus();
                return;
            }
        }

        // -- Export --

        async function ibDoExport() {
            if (ibState.selected.size === 0) {
                showToast('Select icons to export');
                return;
            }

            const format = ibState.exportFormat;
            const size = ibState.exportSize;
            const fmCompat = document.getElementById('ib-export-fm').checked;
            const dynamicFill = document.getElementById('ib-export-dynamic').checked;

            // Ensure all selected SVGs are cached
            const needed = [];
            ibState.selected.forEach(id => {
                if (!ibState.svgCache.has(id)) needed.push(id);
            });

            if (needed.length > 0) {
                showToast('Fetching icon data...');
                for (let i = 0; i < needed.length; i += 100) {
                    const batch = needed.slice(i, i + 100);
                    try {
                        const resp = await fetch(_proxyBase + '/icons/batch', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ ids: batch })
                        });
                        if (resp.ok) {
                            const data = await resp.json();
                            if (data.icons) {
                                Object.entries(data.icons).forEach(([id, svg]) => {
                                    ibState.svgCache.set(id, svg);
                                });
                            }
                        }
                    } catch (e) { }
                }
            }

            const ibConvertStrokes = format === 'svg' && (document.getElementById('ib-convert-strokes')?.checked ?? false);

            // Check if conversion work is needed for loading state
            let hasStrokeWork = false;
            if (ibConvertStrokes) {
                for (const id of ibState.selected) {
                    const svg = ibState.svgCache.get(id);
                    if (!svg) continue;
                    const p = new DOMParser();
                    const d = p.parseFromString(svg, 'image/svg+xml');
                    const s = d.querySelector('svg');
                    if (s && isStrokeBasedSVG(s)) { hasStrokeWork = true; break; }
                }
            }

            const dlBtn = document.getElementById('ib-download-btn');
            const dlBtnText = document.getElementById('ib-download-text');
            const origDlText = dlBtnText ? dlBtnText.textContent : '';
            const dlTotal = ibState.selected.size;
            const dlShowProgress = hasStrokeWork && dlTotal >= 100;

            if (hasStrokeWork && dlBtn && dlBtnText) {
                dlBtn.disabled = true;
                dlBtnText.textContent = 'Converting...';
            }
            if (dlShowProgress) showProgressModal('Converting Icons...', dlTotal);

            const items = [];
            let dlProcessed = 0;
            let dlCancelled = false;
            try {
                for (const id of ibState.selected) {
                    if (dlShowProgress && isProgressCancelled()) { dlCancelled = true; break; }

                    const svg = ibState.svgCache.get(id);
                    if (!svg) continue;
                    const name = id.split('/').pop();

                    let parser = new DOMParser();
                    let doc = parser.parseFromString(svg, 'image/svg+xml');
                    let svgEl = doc.querySelector('svg');
                    if (!svgEl) continue;

                    // Convert strokes to fills if enabled and needed
                    if (ibConvertStrokes && isStrokeBasedSVG(svgEl)) {
                        const result = await convertStrokeToFill(svg);
                        if (isProgressCancelled()) { dlCancelled = true; break; }
                        if (result.success) {
                            parser = new DOMParser();
                            doc = parser.parseFromString(result.svg, 'image/svg+xml');
                            svgEl = doc.querySelector('svg');
                            if (!svgEl) continue;
                        }
                    }

                    if (fmCompat && format !== 'png') {
                        const origDynamic = state.fmDynamicFill;
                        state.fmDynamicFill = dynamicFill;
                        processSVGForFileMaker(svgEl);
                        state.fmDynamicFill = origDynamic;
                    }

                    const serializer = new XMLSerializer();
                    let svgString = serializer.serializeToString(svgEl);

                    // Resolve currentColor to black  required for PNG rendering via
                    // <img>/canvas where currentColor has no inherited context
                    if (format === 'png') {
                        svgString = svgString.replace(/currentColor/gi, '#000000');
                    }

                    items.push({ filename: name + '.svg', svgString });

                    dlProcessed++;
                    if (dlShowProgress) updateProgressModal(dlProcessed, dlTotal);
                }
            } finally {
                if (dlShowProgress) hideProgressModal();
                if (dlBtn && dlBtnText) {
                    dlBtn.disabled = false;
                    dlBtnText.textContent = origDlText;
                }
            }

            if (dlCancelled) {
                showToast('Export cancelled');
                return;
            }

            if (items.length === 0) {
                showToast('No icons to export');
                return;
            }

            // For PNG, parse the cleaned svgString back to an element for canvas rendering
            function ibParseSvgEl(svgString) {
                const doc = new DOMParser().parseFromString(svgString, 'image/svg+xml');
                return doc.querySelector('svg');
            }

            if (state.fileMakerMode) {
                if (format === 'png') {
                    const pngResults = [];
                    for (const item of items) {
                        try {
                            const b64 = await svgToPng(ibParseSvgEl(item.svgString), size);
                            pngResults.push({ filename: item.filename.replace('.svg', '.png'), base64: b64 });
                        } catch (e) { }
                    }
                    if (pngResults.length > 0) {
                        const jsonOutput = JSON.stringify({
                            format: 'png',
                            icons: pngResults
                        });
                        callFileMaker('Save Icons', jsonOutput);
                        showToast(`Sent ${pngResults.length} PNG icon(s) to FileMaker`);
                    }
                } else {
                    const svgResults = items.map(item => ({
                        filename: item.filename,
                        base64: btoa(unescape(encodeURIComponent(item.svgString)))
                    }));
                    const jsonOutput = JSON.stringify({
                        format: 'svg',
                        icons: svgResults
                    });
                    callFileMaker('Save Icons', jsonOutput);
                    showToast(`Sent ${svgResults.length} SVG icon(s) to FileMaker`);
                }
            } else {
                // Browser mode  zip multiple files, direct download for single
                const encoder = new TextEncoder();
                if (format === 'png') {
                    const pngEntries = [];
                    for (const item of items) {
                        try {
                            const b64 = await svgToPng(ibParseSvgEl(item.svgString), size);
                            const bin = atob(b64);
                            const data = new Uint8Array(bin.length);
                            for (let i = 0; i < bin.length; i++) data[i] = bin.charCodeAt(i);
                            pngEntries.push({ name: item.filename.replace('.svg', '.png'), data });
                        } catch (e) { }
                    }
                    if (pngEntries.length >= 10) {
                        triggerDownload(createZipBlob(pngEntries), 'icons_export.zip');
                    } else {
                        for (const e of pngEntries) triggerDownload(new Blob([e.data], { type: 'image/png' }), e.name);
                    }
                    showToast(`Exported ${pngEntries.length} PNG icon(s)`);
                } else {
                    const svgEntries = items.map(item => ({
                        name: item.filename,
                        data: encoder.encode(item.svgString)
                    }));
                    if (svgEntries.length >= 10) {
                        triggerDownload(createZipBlob(svgEntries), 'icons_export.zip');
                    } else {
                        for (const e of svgEntries) triggerDownload(new Blob([e.data], { type: 'image/svg+xml' }), e.name);
                    }
                    showToast(`Exported ${items.length} SVG icon(s)`);
                }
            }
        }

        // Generate FileMaker Button Bar XML from selected icons
        function checkButtonBarPlugin() {
            if (!state.fileMakerMode || !state.pluginMissing) return true;
            // Re-check with FileMaker in case user installed the plugin since launch
            callFileMaker('Plugin Missing Check', '');
            // If still missing after a brief moment, show error
            // (The FM script can call back to clear pluginMissing if installed)
            if (state.pluginMissing) {
                showConfirmModal({
                    title: 'Plugin Required',
                    icon: '<svg viewBox="0 0 24 24" fill="#ef4444" stroke="none"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>',
                    messageHtml: 'The <strong>BaseElements Plugin</strong> from Goya is required to copy Button Bars to the FileMaker clipboard.<br><br>Please <a href="https://github.com/GoyaPtyLtd/BaseElements-Plugin/blob/main/docs/Downloads.md" target="_blank" rel="noopener noreferrer" style="color:var(--accent-color);">download and install the Plugin</a>, then restart FileMaker.',
                    confirmText: 'OK',
                    hideCancel: true
                });
                return false;
            }
            return true;
        }

        // Called from FileMaker to update plugin status
        function setPluginStatus(jsonString) {
            try {
                const data = typeof jsonString === 'string' ? JSON.parse(jsonString) : jsonString;
                state.pluginMissing = (data.plugin_missing === 1);
            } catch (e) {}
        }

        async function ibExportButtonBar(evt) {
            if (!checkButtonBarPlugin()) return;
            if (ibState.selected.size === 0) {
                showToast('Select icons to export');
                return;
            }

            // Hold Alt/Option to bypass the 400-icon limit
            const bypassLimit = evt && (evt.altKey || evt.metaKey);
            if (!bypassLimit && ibState.selected.size > 400) {
                showToast('Too many icons selected (max 400 for button bar)');
                return;
            }

            const dynamicFill = document.getElementById('ib-export-dynamic').checked;

            // Ensure all selected SVGs are cached
            const needed = [];
            ibState.selected.forEach(id => {
                if (!ibState.svgCache.has(id)) needed.push(id);
            });
            if (needed.length > 0) {
                showToast('Fetching icon data...');
                for (let i = 0; i < needed.length; i += 100) {
                    const batch = needed.slice(i, i + 100);
                    try {
                        const resp = await fetch(_proxyBase + '/icons/batch', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ ids: batch })
                        });
                        if (resp.ok) {
                            const data = await resp.json();
                            if (data.icons) {
                                Object.entries(data.icons).forEach(([id, svg]) => {
                                    ibState.svgCache.set(id, svg);
                                });
                            }
                        }
                    } catch (e) { }
                }
            }

            // Check if any selected icons need stroke conversion
            let bbNeedsConversion = false;
            for (const id of ibState.selected) {
                const svg = ibState.svgCache.get(id);
                if (!svg) continue;
                const p = new DOMParser();
                const d = p.parseFromString(svg, 'image/svg+xml');
                const s = d.querySelector('svg');
                if (s && isStrokeBasedSVG(s)) { bbNeedsConversion = true; break; }
            }

            const bbBtn = document.getElementById('ib-buttonbar-btn');
            const bbBtnText = document.getElementById('ib-buttonbar-text');
            const bbOrigText = bbBtnText ? bbBtnText.textContent : '';
            const bbTotal = ibState.selected.size;
            const bbShowProgress = bbTotal > 10;

            if (bbShowProgress && bbBtn && bbBtnText) {
                bbBtn.disabled = true;
                bbBtnText.textContent = 'Processing...';
            }
            if (bbShowProgress) showProgressModal('Processing Icons...', bbTotal);

            // Process SVGs for FileMaker (always convert strokes  they don't work in FM button bars)
            const segments = [];
            let bbProcessed = 0;
            let bbCancelled = false;
            try {
                for (const id of ibState.selected) {
                    if (bbShowProgress && isProgressCancelled()) { bbCancelled = true; break; }

                    const svg = ibState.svgCache.get(id);
                    if (!svg) continue;
                    const name = id.split('/').pop();
                    let parser = new DOMParser();
                    let doc = parser.parseFromString(svg, 'image/svg+xml');
                    let svgEl = doc.querySelector('svg');
                    if (!svgEl) continue;

                    // Always convert stroke-based icons for button bars
                    if (isStrokeBasedSVG(svgEl)) {
                        const result = await convertStrokeToFill(svg);
                        if (isProgressCancelled()) { bbCancelled = true; break; }
                        if (result.success) {
                            parser = new DOMParser();
                            doc = parser.parseFromString(result.svg, 'image/svg+xml');
                            svgEl = doc.querySelector('svg');
                            if (!svgEl) continue;
                        }
                    }

                    const origDynamic = state.fmDynamicFill;
                    state.fmDynamicFill = dynamicFill;
                    processSVGForFileMaker(svgEl);
                    state.fmDynamicFill = origDynamic;

                    const serializer = new XMLSerializer();
                    const svgString = serializer.serializeToString(svgEl);
                    segments.push({ name: name + '.svg', svgString });

                    bbProcessed++;
                    if (bbShowProgress) updateProgressModal(bbProcessed, bbTotal);
                }
            } finally {
                if (bbShowProgress) hideProgressModal();
                if (bbBtn && bbBtnText) {
                    bbBtn.disabled = false;
                    bbBtnText.textContent = bbOrigText;
                }
            }

            if (bbCancelled) {
                showToast('Export cancelled');
                return;
            }

            if (segments.length === 0) {
                showToast('No icons to export');
                return;
            }

            const xml = ibBuildButtonBarXML(segments);
            callFileMaker('Build Button Bar', JSON.stringify({ buttonBarXml: xml }));
            const numBars = Math.ceil(segments.length / 50);
            const barLabel = numBars > 1 ? `${numBars} button bars` : 'button bar';
            showToast(`${segments.length} icon(s) as ${barLabel} sent to FileMaker`);
        }

        // Export editor SVGs as a FileMaker button bar (same as icon library version but for editor)
        async function editorExportButtonBar(evt) {
            if (!checkButtonBarPlugin()) return;
            if (!hasLoadedSVGs()) {
                showToast('Load icons to export');
                return;
            }

            const dynamicFill = document.getElementById('fm-dynamic-fill')?.checked ?? state.fmDynamicFill;

            const btn = document.getElementById('editor-buttonbar-btn');
            const btnText = document.getElementById('editor-buttonbar-text');
            const origText = btnText ? btnText.textContent : '';
            const total = state.svgItems.length;
            const showProgress = total > 10;

            if (showProgress && btn && btnText) {
                btn.disabled = true;
                btnText.textContent = 'Processing...';
            }
            if (showProgress) showProgressModal('Processing Icons...', total);

            const segments = [];
            let processed = 0;
            let cancelled = false;
            try {
                for (const item of state.svgItems) {
                    if (showProgress && isProgressCancelled()) { cancelled = true; break; }

                    const serializer = new XMLSerializer();

                    // Convert strokes first (before generateFinalSVG) so background rect
                    // doesn't interfere with Potrace tracing
                    let savedCurrentSVG = null;
                    if (isStrokeBasedSVG(item.currentSVG)) {
                        const rawStr = serializer.serializeToString(item.currentSVG);
                        const result = await convertStrokeToFill(rawStr);
                        if (showProgress && isProgressCancelled()) { cancelled = true; break; }
                        if (result.success) {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(result.svg, 'image/svg+xml');
                            const convertedSvg = doc.querySelector('svg');
                            if (convertedSvg) {
                                savedCurrentSVG = item.currentSVG;
                                item.currentSVG = convertedSvg;
                            }
                        }
                    }

                    // Generate final SVG with all editor transformations applied
                    let svgEl = generateFinalSVG(item);

                    // Restore original currentSVG if we swapped it for conversion
                    if (savedCurrentSVG) {
                        item.currentSVG = savedCurrentSVG;
                    }

                    if (!svgEl) continue;

                    const origDynamic = state.fmDynamicFill;
                    state.fmDynamicFill = dynamicFill;
                    processSVGForFileMaker(svgEl);
                    state.fmDynamicFill = origDynamic;

                    const finalStr = new XMLSerializer().serializeToString(svgEl);
                    const name = item.filename.replace(/\.svg$/i, '') + '.svg';
                    segments.push({ name, svgString: finalStr });

                    processed++;
                    if (showProgress) updateProgressModal(processed, total);
                }
            } finally {
                if (showProgress) hideProgressModal();
                if (btn && btnText) {
                    btn.disabled = false;
                    btnText.textContent = origText;
                }
            }

            if (cancelled) { showToast('Export cancelled'); return; }
            if (segments.length === 0) { showToast('No icons to export'); return; }

            const xml = ibBuildButtonBarXML(segments);
            callFileMaker('Build Button Bar', JSON.stringify({ buttonBarXml: xml }));
            const numBars = Math.ceil(segments.length / 50);
            const barLabel = numBars > 1 ? `${numBars} button bars` : 'button bar';
            showToast(`${segments.length} icon(s) as ${barLabel} sent to FileMaker`);
        }

        // Encode a string to hex (each byte  2 hex chars)
        function ibStrToHex(str) {
            let hex = '';
            for (let i = 0; i < str.length; i++) {
                hex += str.charCodeAt(i).toString(16).padStart(2, '0').toUpperCase();
            }
            return hex;
        }

        // Encode a filename for FNAM stream (XOR 0x5A per byte)
        function ibEncodeFNAM(filename) {
            const type = 'image';
            const typeBytes = [];
            for (let i = 0; i < type.length; i++) typeBytes.push((type.charCodeAt(i) ^ 0x5A).toString(16).padStart(2, '0').toUpperCase());
            const nameBytes = [];
            for (let i = 0; i < filename.length; i++) nameBytes.push((filename.charCodeAt(i) ^ 0x5A).toString(16).padStart(2, '0').toUpperCase());
            // Header: 00000001, type length, encoded type, 00, name length, encoded name
            const typeLen = type.length.toString(16).padStart(2, '0').toUpperCase();
            const nameLen = filename.length.toString(16).padStart(2, '0').toUpperCase();
            return '00000001' + typeLen + typeBytes.join('') + '00' + nameLen + nameBytes.join('');
        }

        // Build FileMaker button bar XML snippet
        // Build FileMaker button bar XML snippet  template from newbuttonbar.xml (custom theme)
        // Splits into multiple button bars if segments exceed 50 (FM limit per bar)
        function ibBuildButtonBarXML(segments) {
            const MAX_PER_BAR = 50;
            const segW = 60; // width per segment in points
            const barH = 60; // outer bar height
            const barGap = 16; // vertical gap between bars
            const barSpacing = barH + barGap; // 76pt between bar tops

            const barCSS = 'self:normal .self&#10;{&#10;&#09;border-top-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-right-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-bottom-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-left-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-top-style: solid;&#10;&#09;border-right-style: solid;&#10;&#09;border-bottom-style: solid;&#10;&#09;border-left-style: solid;&#10;&#09;border-top-width: 1pt;&#10;&#09;border-right-width: 1pt;&#10;&#09;border-bottom-width: 1pt;&#10;&#09;border-left-width: 1pt;&#10;&#09;border-top-right-radius: 5pt 5pt;&#10;&#09;border-bottom-right-radius: 5pt 5pt;&#10;&#09;border-bottom-left-radius: 5pt 5pt;&#10;&#09;border-top-left-radius: 5pt 5pt;&#10;&#09;box-shadow: none;&#10;&#09;box-sizing: content-box;&#10;}&#10;self:normal .button_bar_divider&#10;{&#10;&#09;border-top-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-right-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-bottom-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-left-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;border-top-style: solid;&#10;&#09;border-right-style: solid;&#10;&#09;border-bottom-style: solid;&#10;&#09;border-left-style: solid;&#10;&#09;border-top-width: 1pt;&#10;&#09;border-right-width: 1pt;&#10;&#09;border-bottom-width: 1pt;&#10;&#09;border-left-width: 1pt;&#10;&#09;border-top-right-radius: 0pt 0pt;&#10;&#09;border-bottom-right-radius: 0pt 0pt;&#10;&#09;border-bottom-left-radius: 0pt 0pt;&#10;&#09;border-top-left-radius: 0pt 0pt;&#10;&#09;box-shadow: none;&#10;&#09;box-sizing: content-box;&#10;}&#10;';

            const segCSS = 'self:normal .self&#10;{&#10;&#09;background-image: none;&#10;&#09;background-position: 0% 0%;&#10;&#09;background-size: auto;&#10;&#09;background-repeat: repeat repeat;&#10;&#09;background-origin: padding-box;&#10;&#09;background-clip: border-box;&#10;&#09;background-color: rgba(100%,100%,100%,0);&#10;&#09;border-top-color: rgba(0%,0%,0%,0);&#10;&#09;border-right-color: rgba(0%,0%,0%,0);&#10;&#09;border-bottom-color: rgba(0%,0%,0%,0);&#10;&#09;border-left-color: rgba(0%,0%,0%,0);&#10;&#09;border-top-style: none;&#10;&#09;border-right-style: none;&#10;&#09;border-bottom-style: none;&#10;&#09;border-left-style: none;&#10;&#09;border-top-width: 0pt;&#10;&#09;border-right-width: 0pt;&#10;&#09;border-bottom-width: 0pt;&#10;&#09;border-left-width: 0pt;&#10;&#09;border-top-right-radius: 0pt 0pt;&#10;&#09;border-bottom-right-radius: 0pt 0pt;&#10;&#09;border-bottom-left-radius: 0pt 0pt;&#10;&#09;border-top-left-radius: 0pt 0pt;&#10;&#09;border-image-source: none;&#10;&#09;border-image-slice: 100% 100% 100% 100% fill;&#10;&#09;border-image-width: 1 1 1 1;&#10;&#09;border-image-outset: 0 0 0 0;&#10;&#09;border-image-repeat: stretch stretch;&#10;&#09;outline-width: 0pt;&#10;&#09;outline-style: none;&#10;&#09;outline-color: invert;&#10;&#09;outline-offset: 0pt;&#10;&#09;font-family: -fm-font-family(Helvetica Neue,HelveticaNeue);&#10;&#09;font-weight: normal;&#10;&#09;font-stretch: normal;&#10;&#09;font-style: normal;&#10;&#09;font-variant: normal;&#10;&#09;font-size: 16pt;&#10;&#09;color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;direction: ltr;&#10;&#09;line-height: 1line;&#10;&#09;block-progression: tb;&#10;&#09;text-align: center;&#10;&#09;text-transform: none;&#10;&#09;text-indent: 0pt;&#10;&#09;box-shadow: none;&#10;&#09;box-sizing: content-box;&#10;&#09;vertical-align: baseline;&#10;&#09;-fm-digit-set: roman;&#10;&#09;-fm-space-before: 0line;&#10;&#09;-fm-space-after: 0line;&#10;&#09;-fm-tab-stops: ;&#10;&#09;-fm-strikethrough: false;&#10;&#09;-fm-underline: none;&#10;&#09;-fm-glyph-variant: ;&#10;&#09;-fm-paragraph-margin-left: 0pt;&#10;&#09;-fm-paragraph-margin-right: 0pt;&#10;&#09;-fm-character-direction: ;&#10;&#09;-fm-use-default-appearance: false;&#10;&#09;-fm-override-with-classic: false;&#10;&#09;-fm-baseline-shift: 0pt;&#10;&#09;-fm-fill-effect: 0;&#10;&#09;-fm-highlight-color: rgba(0%,0%,0%,0);&#10;&#09;-fm-text-vertical-align: center;&#10;&#09;-fm-tategaki: false;&#10;&#09;-fm-rotation: 0;&#10;&#09;-fm-borders-between-reps: false;&#10;&#09;-fm-borders-baseline: false;&#10;&#09;-fm-texty-field: false;&#10;&#09;-fm-box-shadow-persist: none;&#10;}&#10;self:hover .self&#10;{&#10;&#09;background-image: none;&#10;&#09;background-color: rgba(100%,100%,100%,1);&#10;&#09;border-image-source: none;&#10;&#09;color: rgba(100%,100%,100%,1);&#10;}&#10;self:pressed .self&#10;{&#10;&#09;background-image: none;&#10;&#09;background-color: rgba(100%,100%,100%,1);&#10;&#09;border-image-source: none;&#10;&#09;color: rgba(100%,100%,100%,1);&#10;}&#10;self:focus .self&#10;{&#10;&#09;background-image: none;&#10;&#09;background-color: rgba(100%,100%,100%,1);&#10;&#09;border-image-source: none;&#10;&#09;color: rgba(100%,100%,100%,1);&#10;}&#10;self:checked .self&#10;{&#10;&#09;background-image: none;&#10;&#09;background-color: rgba(100%,100%,100%,1);&#10;&#09;border-image-source: none;&#10;&#09;color: rgba(100%,100%,100%,1);&#10;}&#10;self:normal .inner_border&#10;{&#10;&#09;border-top-color: rgba(0%,0%,0%,0);&#10;&#09;border-right-color: rgba(0%,0%,0%,0);&#10;&#09;border-bottom-color: rgba(0%,0%,0%,0);&#10;&#09;border-left-color: rgba(0%,0%,0%,0);&#10;&#09;border-top-style: none;&#10;&#09;border-right-style: none;&#10;&#09;border-bottom-style: none;&#10;&#09;border-left-style: none;&#10;&#09;border-top-width: 0pt;&#10;&#09;border-right-width: 0pt;&#10;&#09;border-bottom-width: 0pt;&#10;&#09;border-left-width: 0pt;&#10;&#09;border-top-right-radius: 0pt 0pt;&#10;&#09;border-bottom-right-radius: 0pt 0pt;&#10;&#09;border-bottom-left-radius: 0pt 0pt;&#10;&#09;border-top-left-radius: 0pt 0pt;&#10;&#09;padding-top: 0em;&#10;&#09;padding-right: 0.2em;&#10;&#09;padding-bottom: 0em;&#10;&#09;padding-left: 0.2em;&#10;&#09;margin-top: 0pt;&#10;&#09;margin-right: 0pt;&#10;&#09;margin-bottom: 0pt;&#10;&#09;margin-left: 0pt;&#10;&#09;width: auto;&#10;&#09;height: auto;&#10;&#09;top: auto;&#10;&#09;right: auto;&#10;&#09;bottom: auto;&#10;&#09;left: auto;&#10;&#09;position: static;&#10;&#09;box-shadow: none;&#10;&#09;box-sizing: content-box;&#10;}&#10;self:focus .inner_border&#10;{&#10;&#09;box-shadow: none;&#10;}&#10;self:normal .text&#10;{&#10;&#09;width: 100%;&#10;&#09;height: 100%;&#10;&#09;box-sizing: border-box;&#10;}&#10;self:normal .icon&#10;{&#10;&#09;-fm-icon-color: rgba(0%,56.8627%,80.7843%,1);&#10;&#09;-fm-icon-padding: 0.5em;&#10;}&#10;self:hover .icon&#10;{&#10;&#09;-fm-icon-color: rgba(40%,69.4118%,19.6078%,1);&#10;}&#10;self:pressed .icon&#10;{&#10;&#09;-fm-icon-color: rgba(99.2157%,60.3922%,0%,1);&#10;}&#10;self:focus .icon&#10;{&#10;&#09;-fm-icon-color: rgba(100%,15.2941%,7.05882%,1);&#10;}&#10;self:checked .icon&#10;{&#10;&#09;-fm-icon-color: rgba(0%,56.8627%,80.7843%,1);&#10;}&#10;self:normal .baseline&#10;{&#10;&#09;border-top-color: rgba(0%,0%,0%,0);&#10;&#09;border-right-color: rgba(0%,0%,0%,0);&#10;&#09;border-bottom-color: rgba(0%,0%,0%,0);&#10;&#09;border-left-color: rgba(0%,0%,0%,0);&#10;&#09;border-top-style: none;&#10;&#09;border-right-style: none;&#10;&#09;border-bottom-style: none;&#10;&#09;border-left-style: none;&#10;&#09;border-top-width: 0pt;&#10;&#09;border-right-width: 0pt;&#10;&#09;border-bottom-width: 0pt;&#10;&#09;border-left-width: 0pt;&#10;}&#10;';

            // Split segments into chunks of MAX_PER_BAR
            const chunks = [];
            for (let i = 0; i < segments.length; i += MAX_PER_BAR) {
                chunks.push(segments.slice(i, i + MAX_PER_BAR));
            }

            // Find widest bar for enclosing rect
            const maxChunkLen = Math.max(...chunks.map(c => c.length));
            const maxBarW = maxChunkLen * segW + 2;
            const numBars = chunks.length;
            const totalH = numBars * barH + (numBars - 1) * barGap;

            // Build segment XML for a single button bar segment
            function buildSegmentXML(seg, localIndex, globalKey) {
                const left = (localIndex * segW + 1).toFixed(7);
                const right = ((localIndex + 1) * segW + 1).toFixed(7);

                const fnameHex = ibEncodeFNAM(seg.name);
                const fnameSize = fnameHex.length / 2;
                const svgHex = ibStrToHex(seg.svgString);
                const svgSize = seg.svgString.length;

                return `<Object type="Button" key="${globalKey}" LabelKey="0" flags="65544" rotation="0">
<Bounds top="1.0000000" left="${left}" bottom="59.0000000" right="${right}"/>
<TextObj flags="2">
<ExtendedAttributes fontHeight="10" graphicFormat="5">
<NumFormat flags="2304" charStyle="0" negativeStyle="0" currencySymbol="$" thousandsSep="44" decimalPoint="46" negativeColor="#DD000000" decimalDigits="2" trueString="Yes" falseString="No"/>
<DateFormat format="0" charStyle="0" monthStyle="1" dayStyle="1" separator="47">
<DateElement>3</DateElement>
<DateElement>1</DateElement>
<DateElement>6</DateElement>
<DateElement>8</DateElement>
<DateElementSep index="0"></DateElementSep>
<DateElementSep index="1">, </DateElementSep>
<DateElementSep index="2"> </DateElementSep>
<DateElementSep index="3"> </DateElementSep>
<DateElementSep index="4"></DateElementSep>
</DateFormat>
<TimeFormat flags="143" charStyle="0" hourStyle="0" minsecStyle="1" separator="58" amString=" AM" pmString=" PM" ampmString=""/>
<CharacterStyle mask="32695">
<Font-family codeSet="Other" fontId="0" postScript="HelveticaNeue">Helvetica Neue</Font-family>
<Font-size>16</Font-size>
<Face>0</Face>
<Color>#0091CE</Color>
</CharacterStyle>
</ExtendedAttributes>
<Styles>
<FullCSS>
${segCSS}</FullCSS>
<ThemeName>com.filemaker.theme.custom.E0B203E2_6455_4488_8FAB_92CFB662EFD6</ThemeName></Styles>
<CharacterStyleVector>
<Style>
<Data></Data>
<CharacterStyle mask="32695">
<Font-family codeSet="Other" fontId="0" postScript="HelveticaNeue">Helvetica Neue</Font-family>
<Font-size>16</Font-size>
<Face>0</Face>
<Color>#0091CE</Color>
</CharacterStyle>
</Style>
</CharacterStyleVector>
<ParagraphStyleVector>
<Style>
<Data></Data>
<ParagraphStyle mask="0">
</ParagraphStyle>
</Style>
</ParagraphStyleVector>
</TextObj>
<ButtonObj buttonFlags="0" iconSize="48" displayType="1">
<Step enable="True" id="103" name="Exit Script"></Step>
<Stream size="${fnameSize}">
<Type>FNAM</Type>
<HexData>${fnameHex}</HexData>
</Stream>
<Stream size="1">
<Type>GLPH</Type>
<HexData>01</HexData>
</Stream>
<Stream size="${svgSize}">
<Type>SVG </Type>
<HexData>${svgHex}</HexData>
</Stream>
</ButtonObj>
</Object>
`;
            }

            // Build each button bar
            let nextKey = 1; // globally unique key counter
            let barsXML = '';
            chunks.forEach((chunk, barIndex) => {
                const barTop = barIndex * barSpacing;
                const barBottom = barTop + barH;
                const thisBarW = chunk.length * segW + 2;
                const barKey = nextKey++;

                let segsXML = '';
                chunk.forEach((seg, localIndex) => {
                    segsXML += buildSegmentXML(seg, localIndex, nextKey++);
                });

                barsXML += `<Object type="ButtonBar" key="${barKey}" LabelKey="0" flags="0" rotation="0">
<Bounds top="${barTop}.0000000" left="0.0000000" bottom="${barBottom}.0000000" right="${thisBarW}.0000000"/>
<Styles>
<FullCSS>
${barCSS}</FullCSS>
<ThemeName>com.filemaker.theme.custom.E0B203E2_6455_4488_8FAB_92CFB662EFD6</ThemeName></Styles>
<ButtonBarObj flags="0" segmentKey="0">
${segsXML}</ButtonBarObj>
</Object>
`;
            });

            return `<?xml version="1.0" encoding="UTF-8"?>
<fmxmlsnippet type="LayoutObjectList">
<Layout enclosingRectTop="0.0000000" enclosingRectLeft="0.0000000" enclosingRectBottom="${totalH}.0000000" enclosingRectRight="${maxBarW}.0000000">
${barsXML}</Layout></fmxmlsnippet>`;
        }



        // -- Edit in Editor --

        async function ibEditInEditor() {
            if (ibState.selected.size === 0) {
                showToast('Select icons to edit');
                return;
            }

            // Ensure all selected SVGs are cached
            const needed = [];
            ibState.selected.forEach(id => {
                if (!ibState.svgCache.has(id)) needed.push(id);
            });

            if (needed.length > 0) {
                for (let i = 0; i < needed.length; i += 100) {
                    const batch = needed.slice(i, i + 100);
                    try {
                        const resp = await fetch(_proxyBase + '/icons/batch', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ ids: batch })
                        });
                        if (resp.ok) {
                            const data = await resp.json();
                            if (data.icons) {
                                Object.entries(data.icons).forEach(([id, svg]) => {
                                    ibState.svgCache.set(id, svg);
                                });
                            }
                        }
                    } catch (e) { }
                }
            }

            const items = [];
            ibState.selected.forEach(id => {
                const svg = ibState.svgCache.get(id);
                if (!svg) return;
                const name = id.split('/').pop();
                items.push({
                    filename: name + '.svg',
                    base64: btoa(unescape(encodeURIComponent(svg)))
                });
            });

            if (items.length === 0) return;

            const editorHasContent = hasLoadedSVGs();

            if (editorHasContent) {
                // Add to existing editor content  skip duplicates by filename
                const existing = new Set(state.svgItems.map(i => i.filename));
                let added = 0;
                let skipped = 0;
                items.forEach(item => {
                    if (existing.has(item.filename)) {
                        skipped++;
                        return;
                    }
                    const svgString = atob(item.base64);
                    if (addSVGItem(item.filename, svgString, true)) {
                        added++;
                    }
                });
                if (added > 0) {
                    renderPreview();
                    updateSizeInfo();
                    updateSaveButton();
                    detectStrokeSVGs();
                    setTimeout(autoZoom, 50);
                }
                const msg = added > 0 ? `Added ${added} icon(s) to editor` : 'Icons already in editor';
                if (skipped > 0 && added > 0) {
                    showToast(`Added ${added}, skipped ${skipped} duplicate(s)`);
                } else {
                    showToast(msg);
                }
            } else {
                // Editor empty  load fresh
                ibSetMode('editor');
                loadSVGItems(JSON.stringify(items), { skipResolve: true });
                showToast(`Loaded ${items.length} icon(s) into editor`);
            }
        }

        // -- Restore on page load --

        function ibRestoreOnLoad() {
            const prefs = ibLoadPrefs();
            if (prefs && prefs.mode === 'library') {
                ibSetMode('library');
            }
        }

        // ============================================
        // Global API
        // ============================================

        // Expose functions globally for external access
        window.initEditor = initEditor;
        window.loadSVG = loadSVG;
        window.loadSVGFromString = loadSVGFromString;
        window.loadSVGItems = loadSVGItems;
        window.saveSVG = saveSVG;
        window.setTheme = setTheme;
        window.toggleTheme = toggleTheme;
        window.getState = () => state;
        window.undo = undo;
        window.redo = redo;
        window.triggerFileLoad = triggerFileLoad;
        window.handleFileSelect = handleFileSelect;
        window.hasLoadedSVGs = hasLoadedSVGs;
        window.clearAllSVGs = clearAllSVGs;
        window.downloadSVGs = downloadSVGs;
        window.downloadFiles = downloadFiles;
        window.updateSaveButton = updateSaveButton;
        window.setOutputFormat = setOutputFormat;
        window.setOutputSize = setOutputSize;
        window.svgToPng = svgToPng;
        window.copySVGToClipboard = copySVGToClipboard;
        window.showCodeView = showCodeView;
        window.hideCodeView = hideCodeView;
        window.removeSVGItem = removeSVGItem;
        window.setPreviewBg = setPreviewBg;
        window.togglePreviewBgDropdown = togglePreviewBgDropdown;
        window.updatePreviewBgCustomColor = updatePreviewBgCustomColor;
        window.copyCodeViewContent = copyCodeViewContent;
        window.hideSVGSelectionModal = hideSVGSelectionModal;
        window.handlePasteButton = handlePasteButton;
        window.restoreFromReport = restoreFromReport;
        window.showIssueReport = showIssueReport;
        window.hideIssueReport = hideIssueReport;
        window.submitIssueReport = submitIssueReport;

        // Auto-initialize with defaults when DOM is ready
        var _usageTracked = false;
        function sendUsageTracking() {
            if (_usageTracked) return;
            _usageTracked = true;

            try {
                var last = localStorage.getItem('elemental_tracked');
                if (last && (Date.now() - parseInt(last, 10)) < 1800000) return; // once per 30min
            } catch (e) { /* storage blocked in iframe context  continue, variable guard still prevents double-fire within page load */ }

            const ua = navigator.userAgent;
            let browserName = 'Unknown', browserVersion = '';
            if (ua.match(/edg\//i)) { browserName = 'Edge'; browserVersion = (ua.match(/edg\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/opr\//i) || ua.match(/opera/i)) { browserName = 'Opera'; browserVersion = (ua.match(/(?:opr|opera)\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/chrome/i) && !ua.match(/edg/i)) { browserName = 'Chrome'; browserVersion = (ua.match(/chrome\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/safari/i) && !ua.match(/chrome/i)) { browserName = 'Safari'; browserVersion = (ua.match(/version\/([\d.]+)/i) || [])[1]; }
            else if (ua.match(/firefox/i)) { browserName = 'Firefox'; browserVersion = (ua.match(/firefox\/([\d.]+)/i) || [])[1]; }

            const payload = {
                product_id: PRODUCT_ID,
                timestamp: new Date().toISOString(),
                userAgent: ua,
                browser: browserName + (browserVersion ? ' ' + browserVersion : ''),
                platform: navigator.platform || '',
                language: navigator.language || '',
                screenWidth: screen.width,
                screenHeight: screen.height,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || '',
                referrer: document.referrer || '',
                colorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light',
                touchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
                connectionType: (navigator.connection && navigator.connection.effectiveType) || ''
            };

            fetch(_proxyBase + '/usage', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(() => {
                try { localStorage.setItem('elemental_tracked', '' + Date.now()); } catch (e) { }
            }).catch(() => { });
        }

        function adjustEditorHeight() {
            const container = document.getElementById('editor-container');
            const rect = container.getBoundingClientRect();
            const topOffset = rect.top + window.scrollY;
            if (topOffset > 0) {
                container.style.height = 'calc(100dvh - ' + topOffset + 'px)';
            }
        }

        // ============================================
        // Custom Color Picker Popup
        // ============================================
        var colorPickerPopup = (function () {
            var popup, satCanvas, satCtx, hueCanvas, hueCtx;
            var hsv = { h: 0, s: 0, v: 0 };
            var currentBinding = null;
            var dragging = null; // 'sat' | 'hue' | null

            function init() {
                popup = document.createElement('div');
                popup.className = 'cp-popup';
                var presetColors = [
                    // Row 1: grayscale
                    '#000000', '#515151', '#7b7b7b', '#a5a5a5', '#d2d2d2', '#ffffff',
                    // Row 2: saturated
                    '#ff2600', '#ff9300', '#fffb00', '#00f900', '#00fdff', '#0432ff', '#9b00ff', '#ff40ff',
                    // Row 3: warm tones
                    '#ff7e79', '#ffd479', '#fffc79', '#d4fb79', '#73fcd6', '#73fdff', '#76d6ff', '#7a81ff',
                    // Row 4: cool/pastel tones
                    '#ff48b0', '#d783ff', '#c0c0c0', '#808080', '#404040', '#1a1a1a', '#592800', '#7b4000'
                ];
                var swatchHtml = '<div class="cp-swatches">';
                for (var i = 0; i < presetColors.length; i++) {
                    swatchHtml += '<button class="cp-swatch" data-color="' + presetColors[i] + '" style="background:' + presetColors[i] + '"></button>';
                }
                swatchHtml += '</div>';

                popup.innerHTML =
                    '<canvas class="cp-sat-canvas" width="200" height="150"></canvas>' +
                    '<canvas class="cp-hue-canvas" width="200" height="14"></canvas>' +
                    swatchHtml;
                document.body.appendChild(popup);

                popup.querySelector('.cp-swatches').addEventListener('click', function (e) {
                    var btn = e.target.closest('.cp-swatch');
                    if (!btn) return;
                    var hex = btn.dataset.color;
                    hsv = hexToHSV(hex);
                    applyColor(true);
                    currentBinding = null;
                    popup.classList.remove('open');
                });

                satCanvas = popup.querySelector('.cp-sat-canvas');
                hueCanvas = popup.querySelector('.cp-hue-canvas');
                satCtx = satCanvas.getContext('2d');
                hueCtx = hueCanvas.getContext('2d');

                satCanvas.addEventListener('pointerdown', function (e) {
                    dragging = 'sat';
                    satCanvas.setPointerCapture(e.pointerId);
                    pickSat(e);
                });
                satCanvas.addEventListener('pointermove', function (e) {
                    if (dragging === 'sat') pickSat(e);
                });
                satCanvas.addEventListener('pointerup', function () {
                    if (dragging === 'sat') { dragging = null; applyColor(true); }
                });

                hueCanvas.addEventListener('pointerdown', function (e) {
                    dragging = 'hue';
                    hueCanvas.setPointerCapture(e.pointerId);
                    pickHue(e);
                });
                hueCanvas.addEventListener('pointermove', function (e) {
                    if (dragging === 'hue') pickHue(e);
                });
                hueCanvas.addEventListener('pointerup', function () {
                    if (dragging === 'hue') { dragging = null; applyColor(true); }
                });

                document.addEventListener('keydown', function (e) {
                    if (e.key === 'Escape' && popup.classList.contains('open')) {
                        e.stopPropagation();
                        close();
                    }
                });

                document.addEventListener('pointerdown', function (e) {
                    if (!popup.classList.contains('open')) return;
                    if (popup.contains(e.target)) return;
                    // Allow click on the swatch that opened us to act as toggle
                    if (currentBinding) {
                        var swatch = document.getElementById(currentBinding.colorId).parentElement;
                        if (swatch.contains(e.target)) return;
                    }
                    close();
                });
            }

            function open(binding, anchorEl) {
                if (currentBinding === binding && popup.classList.contains('open')) {
                    close();
                    return;
                }
                currentBinding = binding;
                saveSliderState();

                var hex = document.getElementById(binding.hexId).value;
                if (!isValidColor(hex)) hex = '#000000';
                hex = normalizeHex(hex);
                // Ensure full 7-char hex
                if (hex.length === 4) {
                    hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                hsv = hexToHSV(hex);

                // Show off-screen to measure, then position
                popup.style.left = '-9999px';
                popup.style.top = '-9999px';
                popup.classList.add('open');

                var popupH = popup.offsetHeight;
                var rect = anchorEl.getBoundingClientRect();
                var left = Math.max(0, Math.min(rect.left, window.innerWidth - 230));
                var spaceBelow = window.innerHeight - rect.bottom - 6;
                var spaceAbove = rect.top - 6;

                var top;
                if (spaceBelow >= popupH) {
                    top = rect.bottom + 6;
                } else if (spaceAbove >= popupH) {
                    top = rect.top - popupH - 6;
                } else {
                    // Neither fits fully  pick whichever side has more room
                    top = spaceBelow >= spaceAbove ? rect.bottom + 6 : rect.top - popupH - 6;
                }

                popup.style.left = left + 'px';
                popup.style.top = top + 'px';
                drawSatPanel();
                drawHueBar();
            }

            function close() {
                if (!popup.classList.contains('open')) return;
                popup.classList.remove('open');
                if (dragging) {
                    dragging = null;
                    applyColor(true);
                } else {
                    commitColor();
                }
                currentBinding = null;
            }

            function pickSat(e) {
                var r = satCanvas.getBoundingClientRect();
                var x = Math.max(0, Math.min(e.clientX - r.left, r.width));
                var y = Math.max(0, Math.min(e.clientY - r.top, r.height));
                hsv.s = x / r.width;
                hsv.v = 1 - y / r.height;
                drawSatPanel();
                applyColor(false);
            }

            function pickHue(e) {
                var r = hueCanvas.getBoundingClientRect();
                var x = Math.max(0, Math.min(e.clientX - r.left, r.width));
                hsv.h = (x / r.width) * 360;
                drawSatPanel();
                drawHueBar();
                applyColor(false);
            }

            function applyColor(commit) {
                var hex = hsvToHex(hsv.h, hsv.s, hsv.v);
                if (currentBinding) {
                    currentBinding.updateFn(hex, commit);
                }
            }

            function commitColor() {
                if (currentBinding) {
                    var hex = hsvToHex(hsv.h, hsv.s, hsv.v);
                    currentBinding.updateFn(hex, true);
                }
            }

            function drawSatPanel() {
                var w = satCanvas.width, h = satCanvas.height;
                // Base hue color
                var hueColor = hsvToHex(hsv.h, 1, 1);

                // White-to-hue gradient (left to right)
                var gradH = satCtx.createLinearGradient(0, 0, w, 0);
                gradH.addColorStop(0, '#ffffff');
                gradH.addColorStop(1, hueColor);
                satCtx.fillStyle = gradH;
                satCtx.fillRect(0, 0, w, h);

                // Black gradient (top to bottom)
                var gradV = satCtx.createLinearGradient(0, 0, 0, h);
                gradV.addColorStop(0, 'rgba(0,0,0,0)');
                gradV.addColorStop(1, 'rgba(0,0,0,1)');
                satCtx.fillStyle = gradV;
                satCtx.fillRect(0, 0, w, h);

                // Thumb
                var tx = hsv.s * w, ty = (1 - hsv.v) * h;
                satCtx.beginPath();
                satCtx.arc(tx, ty, 6, 0, Math.PI * 2);
                satCtx.strokeStyle = '#ffffff';
                satCtx.lineWidth = 2;
                satCtx.stroke();
                satCtx.beginPath();
                satCtx.arc(tx, ty, 5, 0, Math.PI * 2);
                satCtx.strokeStyle = '#000000';
                satCtx.lineWidth = 1;
                satCtx.stroke();
            }

            function drawHueBar() {
                var w = hueCanvas.width, h = hueCanvas.height;
                var grad = hueCtx.createLinearGradient(0, 0, w, 0);
                for (var i = 0; i <= 6; i++) {
                    grad.addColorStop(i / 6, hsvToHex(i * 60, 1, 1));
                }
                hueCtx.fillStyle = grad;
                hueCtx.fillRect(0, 0, w, h);

                // Thumb
                var tx = (hsv.h / 360) * w;
                hueCtx.beginPath();
                hueCtx.rect(tx - 3, 0, 6, h);
                hueCtx.strokeStyle = '#ffffff';
                hueCtx.lineWidth = 2;
                hueCtx.stroke();
                hueCtx.beginPath();
                hueCtx.rect(tx - 2, 1, 4, h - 2);
                hueCtx.strokeStyle = '#000000';
                hueCtx.lineWidth = 1;
                hueCtx.stroke();
            }

            function syncFromHex(hex) {
                if (!popup.classList.contains('open')) return;
                if (!isValidColor(hex)) return;
                hex = normalizeHex(hex);
                if (hex.length === 4) {
                    hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                hsv = hexToHSV(hex);
                drawSatPanel();
                drawHueBar();
            }

            function isOpenFor(binding) {
                return popup.classList.contains('open') && currentBinding === binding;
            }

            return { init: init, open: open, close: close, syncFromHex: syncFromHex, isOpenFor: isOpenFor };
        })();

        // ===== Version Utilities =====

        function isNewerVersion(remote, local) {
            const r = remote.split('.').map(Number);
            const l = local.split('.').map(Number);
            for (let i = 0; i < 3; i++) {
                if ((r[i] || 0) > (l[i] || 0)) return true;
                if ((r[i] || 0) < (l[i] || 0)) return false;
            }
            return false;
        }

        // ===== Version Check =====

        async function checkForUpdate() {
            try {
                const resp = await fetch('https://api.github.com/repos/weetbicks/elemental-svg/releases/latest');
                if (!resp.ok) { showVersionLabel(); return; }
                const release = await resp.json();
                const remoteVersion = (release.tag_name || '').replace(/^v/, '');
                if (remoteVersion && isNewerVersion(remoteVersion, EDITOR_VERSION)) {
                    const asset = release.assets && release.assets.find(a => a.name === 'elemental_svg.html');
                    showUpdateNotification({
                        currentVersion: remoteVersion,
                        downloadUrl: asset ? asset.browser_download_url : '',
                        releaseNotes: release.body || ''
                    });
                } else {
                    showVersionLabel();
                }
            } catch (e) {
                showVersionLabel();
            }
        }

        function showVersionLabel() {
            const area = document.getElementById('version-area');
            if (!area) return;
            area.innerHTML = `<span class="update-indicator"><span style="color: var(--text-secondary);">v${EDITOR_VERSION}</span><span class="release-notes-link" onclick="showReleaseNotes()">Release Notes</span></span>`;
        }

        function showUpdateNotification(versionInfo) {
            const area = document.getElementById('version-area');
            if (!area) return;
            area.innerHTML = '';

            const isFileMaker = typeof FileMaker !== 'undefined' && FileMaker.PerformScript;
            const indicator = document.createElement('span');
            indicator.className = 'update-indicator';
            indicator.innerHTML = `
                <span class="update-indicator-label">Update available: v${versionInfo.currentVersion}</span>
                ${isFileMaker ? '<span class="update-indicator-link">Click to update</span>' : ''}
                <span class="release-notes-link" onclick="showReleaseNotes()">Release Notes</span>
            `;

            if (isFileMaker) {
                indicator.querySelector('.update-indicator-link').addEventListener('click', () => {
                    const payload = JSON.stringify({
                        version: versionInfo.currentVersion,
                        downloadUrl: versionInfo.downloadUrl || '',
                        releaseNotes: versionInfo.releaseNotes || ''
                    });
                    FileMaker.PerformScript('Update Version', payload);
                });
            }

            area.appendChild(indicator);
        }

        function updateVersionResult(jsonStr) {
            try {
                const data = JSON.parse(jsonStr);
                const success = data.result === 'success';

                const banner = document.createElement('div');
                banner.className = 'update-banner';
                banner.style.borderColor = success ? 'var(--success)' : 'var(--danger)';
                banner.style.cursor = 'default';
                banner.innerHTML = `
                    <button class="update-banner-dismiss" title="Dismiss">&times;</button>
                    <div class="update-banner-title" style="color: ${success ? 'var(--success)' : 'var(--danger)'}">
                        ${success ? 'Updated to v' + EDITOR_VERSION : 'Update failed'}
                    </div>
                    <div class="update-banner-body">
                        ${success ? 'Editor has been updated successfully.' : 'Something went wrong. Please try again later.'}
                    </div>
                `;

                banner.querySelector('.update-banner-dismiss').addEventListener('click', () => {
                    banner.remove();
                });

                const existing = document.querySelector('.update-banner');
                if (existing) existing.remove();

                document.body.appendChild(banner);

                setTimeout(() => { if (banner.parentNode) banner.remove(); }, 5000);
            } catch (e) {
                console.error('updateVersionResult: invalid JSON', e);
            }
        }
        window.updateVersionResult = updateVersionResult;

        // --- About Modal ---
        let _productsCache = null;

        function showAboutModal() {
            document.getElementById('about-modal').classList.add('visible');
            document.addEventListener('keydown', handleAboutEscape);
            loadAboutProducts();
        }

        function hideAboutModal() {
            document.getElementById('about-modal').classList.remove('visible');
            document.removeEventListener('keydown', handleAboutEscape);
        }

        function handleAboutEscape(e) {
            if (e.key === 'Escape') hideAboutModal();
        }

        function computeYearsAt(startDate) {
            const now = new Date();
            let years = now.getFullYear() - startDate.getFullYear();
            if (now < new Date(now.getFullYear(), startDate.getMonth(), startDate.getDate())) years--;
            return years;
        }

        async function loadAboutProducts() {
            const container = document.getElementById('about-products');
            if (!container) return;

            if (_productsCache) {
                renderAboutData(_productsCache);
                return;
            }

            try {
                const cached = localStorage.getItem('elemental-products');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (parsed.ts && (Date.now() - parsed.ts) < 86400000) {
                        _productsCache = parsed.data;
                        renderAboutData(_productsCache);
                        return;
                    }
                }
            } catch (e) { }

            container.innerHTML = '<div style="text-align:center;padding:16px;color:var(--text-secondary);font-size:12px;">Loading...</div>';
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);
                const resp = await fetch(_proxyBase + '/products', { signal: controller.signal });
                clearTimeout(timeout);
                if (!resp.ok) throw new Error('Failed');
                const data = await resp.json();
                _productsCache = data;
                localStorage.setItem('elemental-products', JSON.stringify({ ts: Date.now(), data: data }));
                renderAboutData(data);
            } catch (e) {
                container.innerHTML = '<div style="text-align:center;padding:16px;color:var(--text-secondary);font-size:12px;">Unable to load product information.</div>';
            }
        }

        function renderAboutData(data) {
            const titleEl = document.getElementById('about-title');
            if (titleEl && data.title) titleEl.textContent = data.title;

            const descEl = document.getElementById('about-description');
            if (descEl && data.description) {
                const years = computeYearsAt(new Date(2006, 7, 14));
                let desc = data.description.replace(/19 years/g, years + ' years');
                desc = desc.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                descEl.innerHTML = desc;
            }

            const container = document.getElementById('about-products');
            if (container && data.products) {
                container.innerHTML = data.products.filter(p => !p.hidden).map(p => `
                    <a href="${p.url}" target="_blank" rel="noopener" class="about-product-item">
                        <img src="data:image/svg+xml;base64,${p.image}" alt="${p.name}" class="about-product-icon">
                        <div class="about-product-info">
                            <div class="about-product-name">${p.name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()).replace(/\b(Svg|Ux|Fm)\b/g, m => m.toUpperCase())}</div>
                            <div class="about-product-desc">${p.description}</div>
                        </div>
                    </a>
                `).join('');
            }

            // Update donate button link from product JSON
            const svgProduct = data.products && data.products.find(p => p.id === PRODUCT_ID);
            if (svgProduct && svgProduct.pricing && svgProduct.pricing.tiers) {
                const donateTier = svgProduct.pricing.tiers.find(t => t.hidden);
                if (donateTier && donateTier.stripe_link) {
                    const coffeeBtn = document.querySelector('.btn-coffee');
                    if (coffeeBtn) coffeeBtn.href = donateTier.stripe_link;
                }
            }
        }

        // --- Release Notes ---
        let _releaseNotesCache = null;

        function showReleaseNotes() {
            const modal = document.getElementById('release-notes-modal');
            modal.classList.add('visible');
            document.addEventListener('keydown', handleReleaseNotesEscape);
            modal.addEventListener('click', handleReleaseNotesOverlayClick);
            fetchReleaseNotes();
        }

        function hideReleaseNotes() {
            const modal = document.getElementById('release-notes-modal');
            modal.classList.remove('visible');
            document.removeEventListener('keydown', handleReleaseNotesEscape);
            modal.removeEventListener('click', handleReleaseNotesOverlayClick);
        }

        function handleReleaseNotesEscape(e) {
            if (e.key === 'Escape') hideReleaseNotes();
        }

        function handleReleaseNotesOverlayClick(e) {
            if (e.target.id === 'release-notes-modal') hideReleaseNotes();
        }

        function fetchReleaseNotes() {
            const list = document.getElementById('release-notes-list');
            if (_releaseNotesCache) {
                renderReleaseNotes(_releaseNotesCache);
                return;
            }
            list.innerHTML = '<div class="release-notes-loading">Loading release notes...</div>';
            fetch('https://api.github.com/repos/weetbicks/elemental-svg/releases')
                .then(r => {
                    if (!r.ok) throw new Error('Failed to fetch releases');
                    return r.json();
                })
                .then(releases => {
                    _releaseNotesCache = releases;
                    renderReleaseNotes(releases);
                })
                .catch(() => {
                    list.innerHTML = '<div class="release-notes-error">Unable to load release notes. Check your internet connection.</div>';
                });
        }

        function renderReleaseNotes(releases) {
            const list = document.getElementById('release-notes-list');
            if (!releases.length) {
                list.innerHTML = '<div class="release-notes-loading">No releases found.</div>';
                return;
            }
            list.innerHTML = releases.map(r => {
                const date = r.published_at ? new Date(r.published_at).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : '';
                const body = (r.body || '').trim() || 'No release notes provided.';
                return `<div class="release-note-entry">
                    <div class="release-note-version">${r.name || r.tag_name}</div>
                    ${date ? `<div class="release-note-date">${date}</div>` : ''}
                    <div class="release-note-body">${simpleMarkdown(body)}</div>
                </div>`;
            }).join('');
        }

        function simpleMarkdown(str) {
            return str
                .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
                .replace(/^### (.+)$/gm, '<div style="font-weight:600;font-size:13px;margin-top:8px;margin-bottom:2px;">$1</div>')
                .replace(/^## (.+)$/gm, '<div style="font-weight:700;font-size:14px;margin-top:10px;margin-bottom:2px;">$1</div>')
                .replace(/^# (.+)$/gm, '<div style="font-weight:700;font-size:15px;margin-top:10px;margin-bottom:2px;">$1</div>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code style="background:var(--bg-tertiary);padding:1px 4px;border-radius:3px;font-size:11px;">$1</code>')
                .replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, '<a href="$2" target="_blank" style="color:var(--accent);text-decoration:underline;">$1</a>')
                .replace(/^- (.+)$/gm, '<div style="padding-left:12px;text-indent:-8px;margin:0;">&#8226; $1</div>')
                .replace(/\n\n/g, '<div style="height:4px;"></div>')
                .replace(/\n/g, '<br>')
                .replace(/<\/div><br>/g, '</div>')
                .replace(/<br><div/g, '<div');
        }

        document.addEventListener('DOMContentLoaded', function () {
            initEditor();
            initExternalLinkHandler();
            sendUsageTracking();
            setTimeout(checkForUpdate, 2000);
            ibRestoreOnLoad();

            // Update donate button from cached products data
            try {
                const cached = localStorage.getItem('elemental-products');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (parsed.data && parsed.data.products) {
                        const svgProduct = parsed.data.products.find(p => p.id === PRODUCT_ID);
                        if (svgProduct && svgProduct.pricing && svgProduct.pricing.tiers) {
                            const donateTier = svgProduct.pricing.tiers.find(t => t.hidden);
                            if (donateTier && donateTier.stripe_link) {
                                const coffeeBtn = document.querySelector('.btn-coffee');
                                if (coffeeBtn) coffeeBtn.href = donateTier.stripe_link;
                            }
                        }
                    }
                }
            } catch (e) { }
            // Adjust height after a short delay to let parent page (e.g. Squarespace) finish layout
            setTimeout(adjustEditorHeight, 100);
            window.addEventListener('resize', adjustEditorHeight);

            // Custom color picker popup (replaces native input[type="color"])
            colorPickerPopup.init();

            var cpBindings = [
                { colorId: 'fill-color', hexId: 'fill-hex', updateFn: updateFillColor },
                { colorId: 'stroke-color', hexId: 'stroke-hex', updateFn: updateStrokeColor },
                { colorId: 'bg-color', hexId: 'bg-hex', updateFn: updateBgColor }
            ];
            cpBindings.forEach(function (b) {
                var swatch = document.getElementById(b.colorId).parentElement;
                swatch.addEventListener('click', function () {
                    colorPickerPopup.open(b, swatch);
                });
                document.getElementById(b.hexId).addEventListener('change', function () {
                    if (colorPickerPopup.isOpenFor(b)) {
                        colorPickerPopup.syncFromHex(this.value);
                    }
                });
            });
        });
    </script>
    <div class="ib-rubber-band" id="ib-rubber-band"></div>
</body>

</html>